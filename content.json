{"pages":[],"posts":[{"title":"BDDMockito given 사용시 주의","text":"문제Test Code1234567891011121314151617181920212223242526@Testvoid testCreateWordFail() throws Exception { // gvien BindingResult bindingResult = new MapBindingResult(new HashMap(), &quot;&quot;); bindingResult.rejectValue(&quot;test&quot;, &quot;test&quot;, &quot;haha&quot;); WordDTO.AddWord addWord = new WordDTO.AddWord(); addWord.setWord(&quot;test&quot;); addWord.setMeaning(&quot;테스트&quot;); given(this.service.getCreateWordBindingResult(addWord, bindingResult)).willReturn(bindingResult); String addWordToJson = getAddWordToJson(); //when ResultActions action = mockMvc.perform(post(&quot;/word/add&quot;) .param(&quot;save&quot;, &quot;&quot;) .content(addWordToJson) .contentType(MediaType.APPLICATION_JSON) .with(csrf())) .andDo(print()); //then action.andExpect(status().isOk()) .andExpect(view().name(&quot;thymeleaf/word/createWordForm&quot;));} 위 코드처럼 this.service.getCreateWordBindingResult(addWord, bindingResult) method가 호출될 때 willdReturn으로 지정한 bindingResult가 return되게 하고 하려했으나 given이 제대로 동작하지 않아서 인지 getCreateWordBindingResult method 안에서 result가 존재하지 않아 NullPointerException이 발생하여 테스트가 실패했다. Test Target1234567891011@PostMapping(value=&quot;/word/add&quot;, params= {&quot;save&quot;})public String createWord(@Valid AddWord word, BindingResult bindingResult) { BindingResult result = service.getCreateWordBindingResult(word, bindingResult); if (result.hasErrors()) { // NullPointerException 발생 return &quot;thymeleaf/word/createWordForm&quot;; } service.insertWord(word); return &quot;thymeleaf/index&quot;;} 해결ArgumentMatchers class에 any()를 이용해서 파라미터를 넘겼더니 정상적으로 동작했다. 1given(this.service.getCreateWordBindingResult(any(WordDTO.AddWord.class), any(BindingResult.class))).willReturn(bindingResult); p.s : 기본 자료형 (int, char)이나 String 등은 any()를 사용하지 않고 그대로 파라미터로 받아도 정상적으로 동작하는 것 같은데 어째서 따로 정의한 클래스만 인식(?) 하지 못해서 willReturn이 먹히지 않고 null이 return 되는지 알 수가 없었다. 전체 코드 https://github.com/jungguji/wordbook","link":"/2020/06/09/BDDMockito-given-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98/"},{"title":"Hexo blog backup 방법","text":"서론많은 블로그 서비스 중 필자는 Git, Github를 활용해서 사용하는 hexo로 github 블로그를 선택했지만, 다른 블로그 서비스들과는 달리 설치형 블로그의 특성상 설치된 PC가 아닌 경우엔 블로그에 글을 작성하는 일이 쉽지 않고, 블로그가 설치된 PC가 고장이라도 나는 날에는 고스라니 블로그를 날려버리는 상황이 닥치는 경우도 왕왕있다. (예로 필자는 블로그를 설치한 HDD가 고장나 블로그를 새로 작성했다.) 이런 경우를 방지하고, 블로그 작성의 확장성을 위해 github을 이용해 Hexo 블로그를 back up 하는 방법을 알아본다. 방법 우선 위 사진처럼 github에서 테마와 post를 저장 할 repository를 생성한다.이 때 테마를 저장 할 저장소의 이름은 테마와 같게 한다. 테마를 저장하기 위해 연결된 원격 저장소의 위치를 확인하고 설치한 테마 폴더 안에서 git 원격 저장소 주소를 변경한다. 변경 후 테마용 저장소에 테마를 push한다. 위 처럼 정상적으로 저장되어 있는지 확인하고 themes 폴더안에서 테마를 삭제한다. git의 submodule 기능을 이용해 저장한 테마를 submodule로 추가하는데 이 때 디렉토리의 위치는 themes 폴더 내로 이동해서 submodule 기능을 실행한다. 1git submodule add 테마 저장소 post를 저장 할 저장소 주소를 추가한다.(cotent) 1git remote add content post 저장소 post 저장용 저장소에 내용을 push하고 정상적으로 저장되었는지 확인한다. 이 후엔 post 작성 후 post만 content 저장소로 push해주면 된다. 결과이제 우리는 불미스러운 사고로 블로그가 설치된 HDD가 고장나거나(ㅠㅠ), 블로그가 설치 안된 다른 PC or 노트북에서도 백업된 theme와 post들을 다운받아 블로그를 작성 할 수 있게 되었다. 여담이지만, 과거로 돌아간다면 나는 velog를 사용 할 듯 싶다. 참고 사이트 Hexo 배포 원리와 백업하기 Git cached 삭제 Git Submodule 삭제방법 Git: fatal: Pathspec is in submodule","link":"/2021/01/02/Hexo-blog-backup-%EB%B0%A9%EB%B2%95/"},{"title":"H2 DB를 이용한 Repository Test","text":"상황프로덕션 환경에서 Mariadb를 활용하고 있었는데, 프로덕션 환경의 DB로 Repository class를 테스트를 진행하니 테스트 데이터는 롤백되어 DB 남지 않았지만, Auto increment로 지정한 ID가 증가돼서 실제 서비스에서 데이터 저장 시 증가된 ID로 데이터가 저장되는 문제가 발생했다. 해서 Test할 때는 사용 할 데이터베이스 H2를 이용하기로 했다. H2 데이터베이스는 인메모리 관계형 데이터베이스로 메모리 안에서 실행되기 때문에 어플리케이션을 시작할 때마다 초기화되어 테스트 용도로 많이 사용된다. 하지만 테스트 환경도 프로덕션 환경과 비슷하게 만들어서 테스트 하는 경우에는 테스트환경에도 프로덕션 DB를 생성해서 사용하는 경우도 있다고 한다. 필자가 okky에 올린 질문글 Repository Test시 ID 자동 증가 Test 환경에서 H2 적용우선 H2 DB를 POM.xml에 추가하여 의존성을 등록한다. 123456&lt;!-- https://mvnrepository.com/artifact/com.h2database/h2 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 그 후 Test 환경에서 사용하는 appication.properties에서 데이터베이스 설정을 H2로 설정해준다. application-test.properties 내용123456789spring.datasource.url=jdbc:h2:mem:testdb;MODE=MySQL;DB_CLOSE_DELAY=-1spring.datasource.driverClassName=org.h2.Driverspring.datasource.username=saspring.datasource.password=spring.h2.console.enabled=truespring.jpa.hibernate.dialect=org.hibernate.dialect.MariaDBDialectspring.jpa.database-platform=org.hibernate.dialect.H2Dialectspring.jpa.hibernate.ddl-auto=create-drop 프로덕션 환경에서 Mariadb를 사용하기 때문에 dialect를 Mariadb로 설정하고 MODE=Mysql로 설정했다. spring.jpa.hibernate.ddl-auto=none으로 설정하면 시작 시 마다 초기화되지 않기 떄문에 테스트 환경에선 꼭 create-drop으로 설정해준다. Repository Test class123456@ExtendWith(SpringExtension.class)@DataJpaTest@TestPropertySource(&quot;classpath:application-test.properties&quot;)class WordRepositoryTest { ...} JPA Test를 위해 JPA 관련된 설정을 불러오는 @DataJpaTest Test환경에선 프로덕션 환경과 다르게 H2 DB를 사용하므로 H2 DB설정을 지정한 application-test.properties를 호출하기 위한 @TestPropertySource 이 정도로 설정하고 Test하면 정상적으로 H2를 이용한 테스트가 성공할 것이다. 여담123456789101112131415161718@BeforeEachvoid setUp() { user = new User(); user.setUsername(&quot;jgji&quot;); user.setPassword(&quot;qwe123&quot;); userRepository.save(this.user); user1 = new User(); user.setUsername(&quot;haha&quot;); user.setPassword(&quot;qwe123&quot;); userRepository.save(this.user1); List&lt;Word&gt; givenWordList = getWordGiven(); this.word = givenWordList.get(0); this.word1 = givenWordList.get(1);} 위 처럼 @Before 메서드를 지정해놓았는데, 각각 Test 메서드를 실행하였을 땐 Auto increment로 지정한 user의 id가 정상적으로 1, 2 이런식으로 생성되었지만 test class 전체로 test를 실행하니 DB가 메서드 마다 각각 실행하고 초기화 되는 것이 아닌지 User Id가 계속 증가해서 테스트가 실패하는 문제가 있었다. 테스트 시 꼭 메서드 각각으로하고 성공한다고 넘어가는게 아니라 클래스 전체로 테스트를 해봐야 할 것 같다. 프로젝트 전체 코드 https://docs.spring.io/spring-boot/docs/2.1.x/reference/html/howto-database-initialization.html 참고 사이트 https://docs.spring.io/spring-boot/docs/2.1.x/reference/html/howto-database-initialization.html","link":"/2020/07/05/H2-DB%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Repository-Test/"},{"title":"Codedeploy 연동 중 발생한 에러","text":"Codedeploy에서 배포그룹 생성 시 인스턴스를 잘못 등록12The deployment failed because no instances were found for your deployment group.Check your deployment group settings to make sure the tags for your Amazon EC2 instances or Auto Scaling groups correctly identify the instances you want to deploy to, and then try again. 배포 그룹에서 태그 그룹으로 인스턴스를 지정할 때 위 사진처럼 일치하는 인스턴스가 존재한다는 문구가 나타나는 걸 확인해야한다. 생성한 버킷 리전과 인스턴스의 리전이 틀려서 에러 발생12payload:&quot;{\\&quot;error_code\\&quot;:5,\\&quot;script_name\\&quot;:\\&quot;\\&quot;,\\&quot;message\\&quot;:\\&quot;The bucket you are attempting to access must be addressed using the specified endpoint. Please send all future requests to this endpoint.\\&quot;,\\&quot;log\\&quot;:\\&quot;\\&quot;}&quot;} 위 에러 로그는 아래 디렉토리에 위치한 파일을 열어서 확인 할 수 있다.shell script에서 작성한 echo도 아래 파일에서 함께 확인 할 수 있다. 1vim /opt/codedeploy-agent/deployment-root/deployment-logs/codedeploy-agent-deployments.log","link":"/2020/06/08/Codedeploy-%EC%97%B0%EB%8F%99-%EC%97%90%EB%9F%AC/"},{"title":"JQPL은 return class로 Inner class는 불가능","text":"결론JPQL의 return 값으로 Inner class를 지정하면 class를 찾을 수 없다는 에러가 발생 하므로 Inner class 말고 따로 class를 생성하고 그 class를 return class로 지정해줘야 한다. 발견아래 처럼 DTO를 생성하고 view별로 inner class로 DTO를 만들고 jpql의 return class로 지정해주었는데 클래스를 찾을 수 없다는 에러가 발생하였다. DTO1234567891011121314151617public class ChannelDTO { @NoArgsConstructor @Getter public static class SubChannelList { private Integer subChannel; private KillTime killTime; @Builder public SubChannelList(Integer subChannel, KillTime killTime) { this.subChannel = subChannel; this.killTime = killTime; } } ...} JPQL 호출 메서드1234567891011public List&lt;SubChannelList&gt; findSubChannelList(Integer dungeonId, Integer mainChannel) { return em.createQuery( &quot;select new com.jungguji.windbossgentimer.web.dto.channel.ChannelDTO.SubChannelList&quot; + &quot;(c.subChannel, k)&quot; + &quot; FROM Channel c left join c.killTimes k&quot; + &quot; WHERE c.dungeon.id = :dungeonId AND c.mainChannel = :mainChannel&quot; + &quot;&quot;, SubChannelList.class) .setParameter(&quot;dungeonId&quot;, dungeonId) .setParameter(&quot;mainChannel&quot;, mainChannel) .getResultList();} 발생한 에러123456789101112Caused by: org.hibernate.hql.internal.ast.QuerySyntaxException: Unable to locate class [com.jungguji.windbossgentimer.web.dto.channel.ChannelDTO.SubChannelList] [select new com.jungguji.windbossgentimer.web.dto.channel.ChannelDTO.SubChannelList(c.subChannel, k) FROM com.jungguji.windbossgentimer.domain.channel.Channel c left join c.killTimes k WHERE c.dungeon.id = :dungeonId AND c.mainChannel = :mainChannel] at org.hibernate.hql.internal.ast.QuerySyntaxException.convert(QuerySyntaxException.java:74) at org.hibernate.hql.internal.ast.ErrorTracker.throwQueryException(ErrorTracker.java:93) at org.hibernate.hql.internal.ast.QueryTranslatorImpl.analyze(QueryTranslatorImpl.java:282) at org.hibernate.hql.internal.ast.QueryTranslatorImpl.doCompile(QueryTranslatorImpl.java:192) at org.hibernate.hql.internal.ast.QueryTranslatorImpl.compile(QueryTranslatorImpl.java:144) at org.hibernate.engine.query.spi.HQLQueryPlan.&lt;init&gt;(HQLQueryPlan.java:113) at org.hibernate.engine.query.spi.HQLQueryPlan.&lt;init&gt;(HQLQueryPlan.java:73) at org.hibernate.engine.query.spi.QueryPlanCache.getHQLQueryPlan(QueryPlanCache.java:162) at org.hibernate.internal.AbstractSharedSessionContract.getQueryPlan(AbstractSharedSessionContract.java:604) at org.hibernate.internal.AbstractSharedSessionContract.createQuery(AbstractSharedSessionContract.java:716) ... 73 more 해결Inner class로 되어있던 DTO를 class로 생성한다. 따로 생성한 DTO123456789101112@NoArgsConstructor@Getterpublic class SubChannelListResponseDTO { private Integer subChannel; private KillTime killTime; @Builder public SubChannelListResponseDTO(Integer subChannel, KillTime killTime) { this.subChannel = subChannel; this.killTime = killTime; }} 결과 P.S 일반적으로 class명과 table명을 헷갈려 대소문자 때문에 발생하는 에러 이므로 대소문자도 잘 확인 하여야 한다.","link":"/2020/11/10/JQPL%EC%9D%80-return-class%EB%A1%9C-Inner-class%EB%8A%94-%EB%B6%88%EA%B0%80%EB%8A%A5/"},{"title":"Junit4 설정 주입 에러","text":"서론현재 작업 중인 프로젝트에서 테스트 코드를 작성해 테스트할 일이 있었는데 프로젝트의 환경은 spring 4.3에 Junit 4.8이었다. 이에 원래 사용하던 junit5로 넘어갈까 하였으나 junit5를 사용하려면 설정을 spring boot으로 해야 한다는 글들이 있어 같은 테스트 환경을 만들기 위해 junit만 4.12 버전으로 업그레이드한 후 테스트를 진행하였는데 spring 프로젝트지만 config 설정들을 boot 처럼 java 파일로 관리하는 형태여서 java 파일과 properties 파일을 동시에 잡아 줄 필요가 있었는데@Contextconfiguration(classes = {블라블라…}, locations = {블라블라…})로 잡으니 에러가 발생하여 해결한 방법을 작성해놓는다. 본론코드1234567@ContextConfiguration(classes = { DatabaseConfig.class, SecurityConfig.class, SocialConfig.class, EnumConfig.class, WebMvcConfig.class}, locations = &quot;classpath:properties/test.properties&quot;) 서론에 적은 것 처럼 classes와 locations를 둘 다 설정하였더니 아래와 같이 에러가 발생하였다. 에러123456789101112131415161718192021222324252627java.lang.IllegalArgumentException: Cannot process locations AND classes for context configuration [ContextConfigurationAttributes@64c87930 declaringClass = 'com.xxxx.xxxImplTest', classes = '{class com.xxxx.config.DatabaseConfig, class com.xxx.config.SecurityConfig, class com.xxx.config.SocialConfig, class com.xxx.config.EnumConfig, class com.xxx.config.WebMvcConfig}', locations = '{classpath:properties/test.properties}', inheritLocations = true, initializers = '{}', inheritInitializers = true, name = [null], contextLoaderClass = 'org.springframework.test.context.ContextLoader']: configure one or the other, but not both. at org.springframework.util.Assert.isTrue(Assert.java:68) at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.processContextConfiguration(AbstractDelegatingSmartContextLoader.java:154) at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildMergedContextConfiguration(AbstractTestContextBootstrapper.java:371) at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildMergedContextConfiguration(AbstractTestContextBootstrapper.java:305) at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildTestContext(AbstractTestContextBootstrapper.java:112) at org.springframework.test.context.TestContextManager.&lt;init&gt;(TestContextManager.java:120) at org.springframework.test.context.TestContextManager.&lt;init&gt;(TestContextManager.java:105) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTestContextManager(SpringJUnit4ClassRunner.java:152) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.&lt;init&gt;(SpringJUnit4ClassRunner.java:143) at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:423) at org.junit.internal.builders.AnnotatedBuilder.buildRunner(AnnotatedBuilder.java:104) at org.junit.internal.builders.AnnotatedBuilder.runnerForClass(AnnotatedBuilder.java:86) at org.junit.runners.model.RunnerBuilder.safeRunnerForClass(RunnerBuilder.java:70) at org.junit.internal.builders.AllDefaultPossibilitiesBuilder.runnerForClass(AllDefaultPossibilitiesBuilder.java:37) at org.junit.runners.model.RunnerBuilder.safeRunnerForClass(RunnerBuilder.java:70) at org.junit.internal.requests.ClassRequest.createRunner(ClassRequest.java:28) at org.junit.internal.requests.MemoizingRequest.getRunner(MemoizingRequest.java:19) at org.junit.internal.requests.FilterRequest.getRunner(FilterRequest.java:36) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:49) at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33) at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230) at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58) 해결@Testpropertysource(classpath:””)로 test properties를 잡아주고@Contextconfiguration(classes = { XXXConfig.class}) 로 Java config 파일들을 잡아준다. 12345678@ContextConfiguration(classes = { DatabaseConfig.class, SecurityConfig.class, SocialConfig.class, EnumConfig.class, WebMvcConfig.class})@Testpropertysource(&quot;classpath:properties/test.properties&quot;)","link":"/2021/01/12/Junit4-%EC%84%A4%EC%A0%95-%EC%A3%BC%EC%9E%85-%EC%97%90%EB%9F%AC/"},{"title":"Junit으로 private 메서드 테스트하기","text":"서론private method도 테스트 해야되는지에 대해선 의견이 많은 것으로 알고 있지만 현재 프로젝트에서 service에서 있는 메서드 중 주요 로직은 private method에 존재하고 public method에선 호출해서 return만 해주는 method가 존재했는데, 이런 경우에 private 메서드를 테스트하기 위한 방법을 정리해둔다. 본론1234567891011121314151617181920212223@Testvoid getPassAndFailWordList_성공() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { //given String[] answerIds = new String[] {&quot;6_1&quot;, &quot;4_1&quot;, &quot;5_1&quot;, &quot;9_3&quot;}; WordService w = new WordServiceImpl(repository, userService); Method method = w.getClass().getDeclaredMethod(&quot;getPassAndFailWordList&quot;, String[].class); method.setAccessible(true); List&lt;Integer&gt; passWordList = Arrays.asList(6,4,5); List&lt;Integer&gt; failWordList = Arrays.asList(9); Object[] obj = new Object[] {answerIds}; //when Map&lt;String, List&lt;Integer&gt;&gt; map = (Map&lt;String, List&lt;Integer&gt;&gt;) method.invoke(w, obj); //than assertThat(map).extracting(&quot;pass&quot;, String.class) .contains(passWordList); assertThat(map).extracting(&quot;fail&quot;, String.class) .contains(failWordList);} test할 private method가 존재하는 class를 직접 생성 getDeclaredMethod()를 이용해서 해당 클래스에 존재하는 private method를 가져오고 setAccessible()로 private method에 접근을 허용 invoke()로 호출하는데 이 때 invoke()의 매개변수가 Object[] 이므로 원래 호출하려던 private method의 매개변수를 Object[]에 담은 후 Object[]을 매개변수로 넘겨줘야함 참고 사이트 https://stackoverflow.com/questions/34571/how-do-i-test-a-private-function-or-a-class-that-has-private-methods-fields-or https://www.crocus.co.kr/1665 https://stackoverflow.com/questions/8189782/wrong-number-of-arguments-error-when-invoking-a-method","link":"/2020/06/23/Junit%EC%9C%BC%EB%A1%9C-private-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EA%B8%B0/"},{"title":"Spring Boot + Maven Travis CI 연동 에러","text":"에러 1./mvnw: Permission denied Spring Boot + Maven 프로젝트 Travis CI 연동 중 발생한 에러 해결12before_install: - chmod +x mvnw 설정으로 권한 부여하여 해결 전체 코드123456789101112131415161718192021222324language: javajdk: - openjdk8branches: only: - master# Travis CI 서버의 Homecache: directories: - $HOME/.m2before_install: - chmod +x mvnw# MAVEN 프로젝트는 필요 없음#script: &quot;./mvnw package&quot;# CI 실행 완료시 메일로 알람notifications: email: recipients: - your@gmail.com 참고 사이트 https://velog.io/@recordsbeat/travis-ci-maven-%EC%97%B0%EB%8F%99","link":"/2020/06/06/Spring-Boot-Maven-Travis-CI-%EC%97%B0%EB%8F%99-%EC%97%90%EB%9F%AC/"},{"title":"RequestBody Annotation 사용 시 boolean 변수 바인딩 에러","text":"서론토이프로젝트 중 @Reqeust 어노테이션을 적용한 DTO에서 boolean 데이터를 제대로 전달 받지 못하는 문제가 발생하여 이를 정리한다. 문제 발생vue.js에서 넘어온 데이터를 @RequestBody 어노테이션을 활용해 DTO 객체로 전달 받으려 하였는데 boolean 타입의 데이터가 정상적으로 넘어오지 않는 문제가 발생하였다. 문제가 발생한 Test Code1234567891011121314151617181920212223@Testpublic void dto_boolean_test() throws Exception { //given RequestDTO dto = RequestDTO.builder() .isTestCase(true) .isNQuantity(true) .isSpaceIncludeNumber(true) .build(); String test = objectMapper.writeValueAsString(dto); System.out.println(test); final ResultActions action = mockMvc.perform(post(&quot;/frame&quot;) .contentType(MediaType.APPLICATION_JSON) .content(test)) .andDo(print()); //then MvcResult result = action .andExpect(status().isOk()) .andExpect(content().json(test)) .andReturn();} 에러 결과 원인 You can annotate any field with @Getter and/or @Setter, to let lombok generate the default getter/setter automatically.A default getter simply returns the field, and is named getFoo if the field is called foo (or isFoo if the field’s type is boolean). Project LombokProject Lombok 위 설명처럼 lombok에서 제공하는 @Getter 혹은 @Setter 어노테이션을 사용 할 경우 자동으로 getter/setter 메서드를 생성해주는데이 때 boolean 타입의 변수에 붙는 prefix는 get이 아닌 is이므로 @RequestBody에서 찾을 수 없어 바인딩 되지 않아 발생하는 문제였다. 실패한 코드 이 처럼 boolean 변수에 is prefix를 붙여놓은 상태에서 @Getter 어노테이션을 사용하니, 내부적으로 isIsTestCase() 같은 이상한 네이밍의 메서드가 생성되서@RequestBody에서 바인딩에 사용하는 Jackson 라이브러리의 ObjectMapper에서 필드를 찾을 수 없어서 바인딩 되지 않아 DTO에 정상적으로 값이 입력되지 않았던 것이다. By default Jackson maps the fields of a JSON object to fields in a Java object by matching the names of the JSON field to the getter and setter methods in the Java object. Jackson removes the “get” and “set” part of the names of the getter and setter methods, and converts the first character of the remaining name to lowercase. Jackson ObjectMapperJackson ObjectMapper 해결 boolean 변수명에서 is prefix를 제거한다. default로 false로 되어 있는 lombok.getter.noIsPrefix=true 설정을 추가한다.이 설정을 추가하면 boolean 변수도 get prefix를 사용한다. 필자는 boolean 변수에서 is prefix를 제거하는 방식으로 처리했다.다른 타입은 자료형에 따라 prefix를 붙이지 않는 상황에서 boolean 변수에만 붙이는 것이 옳지 않다고 생각했기 때문에 1번을 선택했다. 수정된 코드 결과 참고 사이트 https://projectlombok.org/features/GetterSetter https://velog.io/@conatuseus/RequestBody%EC%97%90-%EC%99%9C-%EA%B8%B0%EB%B3%B8-%EC%83%9D%EC%84%B1%EC%9E%90%EB%8A%94-%ED%95%84%EC%9A%94%ED%95%98%EA%B3%A0-Setter%EB%8A%94-%ED%95%84%EC%9A%94-%EC%97%86%EC%9D%84%EA%B9%8C-3-idnrafiw http://tutorials.jenkov.com/java-json/jackson-objectmapper.html#how-jackson-objectmapper-matches-json-fields-to-java-fields","link":"/2020/12/31/RequestBody-Annotation-%EC%82%AC%EC%9A%A9-%EC%8B%9C-boolean-%EB%B3%80%EC%88%98-%EB%B0%94%EC%9D%B8%EB%94%A9-%EC%97%90%EB%9F%AC/"},{"title":"Requestbody Annotation 사용 시 기본 생성자 필요","text":"서론사실, 제목이 결론이다. @Requestbody Annotation을 사용하려면 반드시 해당 DTO에는 기본 생성자가 명시적으로 존재하여야 한다. 뭔가 설정을 잘못했는지는 모르겠지만 intellij 에서 stacktrace가 출력되지 않아 이 사실을 알 수 가 없어서 엄청나게 삽질을 했기에 내용을 정리한다… 본론상황controller 테스트에서 모든 조건을 맞췄는데도 500 에러가 발생하여 테스트를 통과하지 못하는 상황이었는데 @Requestbody annotation을 DTO가 아닌 HashMap으로 변경하니 테스트가 정상적으로 통과되어 JSON이 제대로 DTO로 매핑되지 않아서 발생하는 문제라고 판단했다. 에러 발생 No suitable constructor found for type [simple type, class 클래스명]: can not instantiate from JSON object (missing default constructor or creator, or perhaps need to add/enable type information?) 직역하면 기본 생성자가 존재하지 않아서 에러가 발생했다는 내용이다. 해결 방법빌더패턴을 사용하던 클래스에 @Noargsconstructor annotation을 사용해서 기본 생성자를 생성하게 하였다. 결론@Requestbody와 DTO를 매핑되게 해야 할 경우 많은 조건이 필요하다.이전 포스트에 작성했던 boolean의 변수명이라던가, 지금과 같은 기본 생성자라 라던지… 이게 모두 @Requestbody가 jackson 라이브러리를 이용해 매핑하기 때문이다. 참고 사이트 https://velog.io/@conatuseus/RequestBody%EC%97%90-%EA%B8%B0%EB%B3%B8-%EC%83%9D%EC%84%B1%EC%9E%90%EB%8A%94-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%9C%EA%B0%80","link":"/2021/02/05/Requestbody-Annotation-%EC%82%AC%EC%9A%A9-%EC%8B%9C-%EA%B8%B0%EB%B3%B8-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%84%EC%9A%94/"},{"title":"Spring Controller Test시 CSRF 설정","text":"문제Spring Boot + thymeleaf으로 진행하던 프로젝트를 테스트 하던 중Ajax로 호출하는 Methoed를 Test 하였더니 아래와 같이 403 error가 return 되면서 Test가 실패했다. 원인thymeleaf를 사용하면 기본적으로 CSRF 토큰을 넘겨주기 때문에 따로 csrf 토큰을 생성하지 않았으나, ajax에선 직접 csrf 토큰을 생성해서 넘겨줘야 하기 때문에 csrf 토큰을 생성해서 넘겨주도록 되어 있는데 Test 시에는 그렇지 않아서 403 Forbidden가 발생한 것으로 보인다. thymeleaf config.html12&lt;meta id=&quot;_csrf&quot; name=&quot;_csrf&quot; th:content=&quot;${_csrf.token}&quot;/&gt;&lt;meta id=&quot;_csrf_header&quot; name=&quot;_csrf_header&quot; th:content=&quot;${_csrf.headerName}&quot;/&gt; common.js12const token = $(&quot;meta[name='_csrf']&quot;).attr(&quot;content&quot;);const header = $(&quot;meta[name='_csrf_header']&quot;).attr(&quot;content&quot;); 해결mockMvc.perform에서 get, post 호출 시 SecurityMockMvcRequestPostProcessors 의 csrf()를 with()로 파라미터에 추가한다. 1234567891011121314import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;...//whenResultActions action = mockMvc.perform(post(&quot;/word/add&quot;) .param(&quot;save&quot;, &quot;&quot;) .content(addwordToJson) .contentType(MediaType.APPLICATION_JSON) .with(csrf())) // 이 부분 .andDo(print());... 추가 한 후 다시 테스트 해보면 파라미터에 csrf 토큰이 생성되어 정상적으로 동작하는 것을 확인 할 수 있다. 12345678910MockHttpServletRequest: HTTP Method = POST Request URI = /word/add Parameters = {save=[], _csrf=[6757e021-c0a3-4390-81d9-9c917d89c8c1]} // 이 부분 Headers = [Content-Type:&quot;application/json&quot;, Content-Length:&quot;59&quot;] Body = &lt;no character encoding set&gt; Session Attrs = {SPRING_SECURITY_CONTEXT=org.springframework.security.core.context.SecurityContextImpl@83a38fdf: Authentication: org.springframework.security.authentication.UsernamePasswordAuthenticationToken@83a38fdf: Principal: org.springframework.security.core.userdetails.User@31bf3c: Username: jgji; Password: [PROTECTED]; Enabled: true; AccountNonExpired: true; credentialsNonExpired: true; AccountNonLocked: true; Granted Authorities: ROLE_USER; Credentials: [PROTECTED]; Authenticated: true; Details: null; Granted Authorities: ROLE_USER}... 참고 사이트 https://stackoverflow.com/questions/25605373/unit-testing-controllers-with-csrf-protection-enabled-in-spring-security 전체 코드 ControllerTest config.html common.js","link":"/2020/06/09/Spring-Controller-Test%EC%8B%9C-CSRF-%EC%84%A4%EC%A0%95/"},{"title":"Spring Controller Junit으로 Test하기","text":"평소 Junit의 assertEquals로 알고리즘 코드만 test 하다가토이 프로젝트에서도 Junit을 사용해보기 위해 Spring에서의 Junit Test 방법을 정리 해보자 한다 Test할 Controller123456789101112131415@Controllerpublic class HomeController { @GetMapping(&quot;/&quot;) public String home(Locale locale, Model model) { Date date = new Date(); DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, locale); String formattedDate = dateFormat.format(date); model.addAttribute(&quot;serverTime&quot;, formattedDate ); return &quot;home&quot;; }} index 페이지로 매핑되는 home 메서드만 존재하는 Controller standaloneSetup() 메서드를 활용한 Test123456789101112131415161718public class HomeControllerTest { private MockMvc mockMvc; @Before public void setUp() { this.mockMvc = MockMvcBuilders.standaloneSetup(new HomeController()).build(); } @Test public void homeTest() throws Exception { mockMvc.perform(get(&quot;/&quot;)) .andExpect(status().isOk()) .andExpect(model().attributeExists(&quot;serverTime&quot;)) .andExpect(view().name(&quot;home&quot;)); }} MockMvc 클래스를 통해 HTTP GET, POST 등에 대한 테스트를 할 수 있게 한다 perform() : get 방식으로 url을 호출 status() : http status에 대해 테스트 model() : model에 “serverTime” attribute가 존재하는 지 확인 view() : return하는 view의 name이 “home”인지 확인 위 메서드들을 정상적으로 사용하기 위해선 아래 처럼 메서드들을 import 시켜야한다 1234import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.model;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.view; webAppContextSetup() 메서드를 활용한 Test1234567891011121314151617181920212223242526@RunWith(SpringRunner.class)@ContextConfiguration(locations = {&quot;file:src/main/webapp/WEB-INF/spring/appServlet/servlet-context.xml&quot; , &quot;file:src/main/webapp/WEB-INF/spring/root-context.xml&quot; , &quot;file:src/main/webapp/WEB-INF/spring/spring-security.xml&quot;})@WebAppConfigurationpublic class HomeControllerTest { @Autowired private WebApplicationContext context; private MockMvc mockMvc; @Before public void setUp() { this.mockMvc = MockMvcBuilders.webAppContextSetup(this.context).build(); } @Test public void homeTest() throws Exception { mockMvc.perform(get(&quot;/&quot;)) .andExpect(status().isOk()) .andExpect(model().attributeExists(&quot;serverTime&quot;)) .andExpect(view().name(&quot;home&quot;)); }} @RunWith Junit에 내장된 Runner외에 다른 실행자를 실행시킨다 위 코드에선 SpringRunner 실행자로 Test를 실행하는데 이때 SpringRunner class는 SpringJUnit4ClassRunner class를 상속받고 있다 테스트를 진행할 때 ApplicationContext를 만들고 관리하는데 이 때 싱글톤을 보장한다 @ContextConfiguration 스프링 Bean 설정 파일의 위치를 지정한다 위 코드에서는 Controller는 servlet-context.xml, 그 외 Service, Repository 등은 root-context.xml, 암호화를 위한 bcryptPasswordEncoder bean은 spring-security.xml에 지정되어 있어 3개를 지정했다 @WebAppConfiguration applicationContext의 웹 버전을 작성하는데 사용된다 standalonesetup과 webAppContextSetup의 차이standalonesetup() 메서드는 테스트할 컨트롤러를 수동으로 초기화해서 주입하고, webAppContextSetup() 메서드는 스프링의 ApplicationContext의 인스턴스로 동작한다 standalonesetup() 메서드는 컨트롤러에 집중하여 테스트할 때 사용되고webAppContextSetup() 메서드는 스프링의 DI 컨테이너를 이용해 스프링 MVC 동작을 재현해서 테스트한다 번외 java.lang.NoClassDefFoundError: javax/servlet/SessionCookieConfig 에러12345678910111213java.lang.NoClassDefFoundError: javax/servlet/SessionCookieConfig at org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder.initWebAppContext(StandaloneMockMvcBuilder.java:339) at org.springframework.test.web.servlet.setup.AbstractMockMvcBuilder.build(AbstractMockMvcBuilder.java:139) at com.toon.controller.HomeControllerTest.setUp(HomeControllerTest.java:25) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:24) ... 26 more Spring 4.0 이상에서 Junit으로 테스트 시 servlet 3.0 API를 사용하기 때문에 발생 pom.xml에서 servlet 버전을 3.0.1 이상으로 올려주면 해결 artifactId가 javax.servlet-api 으로 변경 됐으므로 함께 변경해준다. 123456&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 참고 사이트 https://itmore.tistory.com/entry/MockMvc-%EC%83%81%EC%84%B8%EC%84%A4%EB%AA%85 https://jdm.kr/blog/165 https://effectivesquid.tistory.com/entry/Spring-test-%EC%99%80-Junit4%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8 https://www.baeldung.com/spring-webappconfiguration","link":"/2020/05/30/Spring-Controller-Junit-Test/"},{"title":"@SpringBootApplication의 동작 방식","text":"@SpringBootApplication의 동작 방식Spring-Boot의 Main Application 코드에는 @SpringBootApplication이라는 Annotation이 존재한다. 123456@SpringBootApplicationpublic class Demo1Application { public static void main(String[] args) { SpringApplication.run(Demo1Application.class, args); }} @SpringBootApplication 12345678910111213@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication { ...} 이 Annotation의 주된 내용은 아래 3가지 이다. @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan @SpringBootConfiguration @SpringBootConfiguration은 기존 @Configuration과 마찬가지로 해당 클래스가 @Bean 메서드를 정의되어 있음을 Spring 컨테이너에 알려주는 역할을 한다. @Configuration 어노테이션의 대안으로 둘의 차이점은 아래와 같이 설명하고 있다. @SpringBootConfiguration is an alternative to the @Configuration annotation. The main difference is that @SpringBootConfiguration allows configuration to be automatically located. This can be especially useful for unit or integration tests. baeldung,Guide to @SpringBootConfiguration in Spring Boot @EnableAutoConfiguration @ComponentScan에서 먼저 스캔해서 Bean으로 등록하고 tomcat등 스프링이 정의한 외부 의존성을 갖는 class들을 스캔해서 Bean으로 등록한다. 이 때 정의된 class들은 spring-boot-autoconfigure안에 있는 MATE-INF 폴더에 spring.factories라는 파일안에 정의되어 있다. 이 중에서 spring.boot.enableautoconfiguration을 key로하는 외부 의존성 class들이 존재한다. 여기에 정의된 모든 class를 가져오는 게 아니라 class에 내부에 정의된 어노테이션에 따라 그 조건에 부합하는 class들만 생성된다. @ConditionalOnProperty, @ConditionalOnClass, @ConditionalOnBean 등등 123456public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;; ...} spring.factories 위치 1234567891011121314...# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\... 번외. 내장 Tomcat Classspring.factories 파일 안에 보면 1org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\ 가 있고 이 class의 코드를 보면 아래와 같이 tomcatServletWebServerFactoryCustomizer() 메서드를 통해 tomcat을 실행한다는 것을 알 수 있다. 12345678910111213141516171819@Import({ ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class, ServletWebServerFactoryConfiguration.EmbeddedTomcat.class, ServletWebServerFactoryConfiguration.EmbeddedJetty.class, ServletWebServerFactoryConfiguration.EmbeddedUndertow.class })public class ServletWebServerFactoryAutoConfiguration { @Bean public ServletWebServerFactoryCustomizer servletWebServerFactoryCustomizer(ServerProperties serverProperties) { return new ServletWebServerFactoryCustomizer(serverProperties); } @Bean @ConditionalOnClass(name = &quot;org.apache.catalina.startup.Tomcat&quot;) public TomcatServletWebServerFactoryCustomizer tomcatServletWebServerFactoryCustomizer( ServerProperties serverProperties) { return new TomcatServletWebServerFactoryCustomizer(serverProperties); }... @ComponentScan @ComponentScan은 해당 어노테이션 하위에 있는 객체들 중 @Component가 선언된 클래스들을 찾아 Bean으로 등록하는 역할을 한다. 이 때 꼭 @Component가 아니여도 @Component가 선언되어 있는 어노테이션인 @Service, @Repository, @Controller 등등도 포함된다. @EnableAutoConfiguration이 스캔하기 전에 먼저 @ComponentScan이 진행된다. 1234567891011121314151617181920212223@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Service { ...}@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Repository { ...}@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Controller { ...} 참고 사이트 https://www.youtube.com/watch?v=OXILjfY8edw&amp;list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&amp;index=7 https://seongmun-hong.github.io/springboot/Spring-boot-EnableAutoConfiguration http://dveamer.github.io/backend/SpringBootAutoConfiguration.html https://www.baeldung.com/springbootconfiguration-annotation http://wonwoo.ml/index.php/post/20","link":"/2020/05/26/SpringBootApplication-%EC%9D%98-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D/"},{"title":"Spring boot Heroku에 배포하기","text":"서론AWS 프리티어는 이미 다른 서비스가 이용하고 있고 Java를 지원해주는 클라우드 서비스가 없었는데 heroku를 발견하여 사용방법을 정리 해둔다. 참고로 데이터베이스는 한글을 지원하지 않는다. 본론 heroku 회원 가입 App 생성 위에 보이는 create a new app 버튼을 클릭하고 App name을 지정해야 하는데 이미 heroku에 존재하는 service의 name은 생성 할 수 없고,여기서 지정한 App name으로 호스팅 될 URL이 생성된다. ex) appname : backjoonframeautomaticgenerat URL : https://backjoonframeautomaticgenerat.herokuapp.com/ heroku CLI 설치 생성이 완료되면 위 화면처럼 Deploy tab으로 이동되는데 설명되어 있는 것 처럼 먼저 Heroku CLI를 자신의 OS 버전에 맞게 설치한다. Procfile 생성 Heroku는 실행 할 때 마다 port를 자동으로 지정해주는데 port를 고정시키기 위해 우선 application.properties에 port를 바인딩 해준다. application.properties1server.port=${port:8080} 그 후 Procfile을 Project 루트 디렉토리에 확장자 없이 생성하고 아래와 같이 작성한다. 1web: java -Dserver.port=$PORT $JAVA_OPTS -jar [실행될 jar파일 경로] Procfile의 경로 배포 이후엔 heroku의 가이드를 그대로 따라하면 된다. 모든 가이드를 정상적으로 잘 따라하면 위 처럼 접속할 수 있는 URL이 출력되고 해당 URL로 접속하면 확인 https://backjoonframeautomaticgenerat.herokuapp.com/ 정상적으로 실행되어 서비스가 실행되는 것을 확인 할 수 있다. 결론데이터베이스를 사용하지 않는 서비스나, 한글이 입력되지 않는 서비스의 경우 무료로 이용 할 수 있는 좋은 클라우드 서비스 인 것 같다. 참고로 30분간 접속이 없으면 휴면 모드로 전환되어 최초 접속이 다소 느릴 수 있으나 무료 서비스인 만큼 그정도는 감안해주자. 이 글에 소개한 CLI를 이용한 방법 말고 Github와 연결해서 branch에 push하면 자동으로 배포되게 할 수 도 있는 것 같으니 찾아보고 적용하면 이 방법 보다 더 편할 것이다. 참고 사이트 https://jeong-pro.tistory.com/182 https://wedul.site/590","link":"/2021/01/28/Spring-boot-Heroku%EC%97%90-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0/"},{"title":"Vue 개발 순서 정리","text":"서론Spring boot + Vue를 활용해 토이 프로젝트 진행하고 있는데 헷갈리는 부분을 차후 또 Vue로 개발 할 일이 있을 경우 참고하기 위해 글로 남겨 놓는다. 개발 순서 Vue는 설치되어 있다고 가정한다. root 디렉토리에 vue.config.js 생성하고 필요한 설정 추가 vue.config.js1234567891011121314151617181920const path = require(&quot;path&quot;);module.exports = { assetsDir: &quot;static&quot;, outputDir: path.resolve(__dirname, &quot;../backend/src/main/resources/static&quot;), devServer: { proxy: { &quot;/&quot;: { target: &quot;http://localhost:9312&quot;, ws: true, changeOrigin: true } } }, chainWebpack: config =&gt; { const svgRule = config.module.rule(&quot;svg&quot;); svgRule.uses.clear(); svgRule.use(&quot;vue-svg-loader&quot;).loader(&quot;vue-svg-loader&quot;); }}; views/ 에 화면이 될 vue 파일 생성 src/ 에 api 폴더 생성 api/ 에 화면 별로 필요한 js 파일 생성 이 js 파일들엔 각 컴포넌트 별로 필요한 api 주소를 호출 할 수 있는 js 코드를 작성한다. api 호출 시 공통으로 들어갈 header를 포함하는 common.js 생성 common.js123456789import axios from &quot;axios&quot;;const AXIOS = axios.create({ headers: { &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;, &quot;Content-Type&quot;: &quot;application/json; charset = utf-8&quot; }, timeout: 1000}); components/ 에 2번에서 만든 화면에 출력 될 component vue 파일 생성 router/index.js 에 추가한 vue path 추가 rotuer에 추가하지 않으면 화면이 나오지 않음 router/index.js1234567... { path: &quot;/main&quot;, name: &quot;Main&quot;, component: () =&gt; import(&quot;../views/Main&quot;) }...","link":"/2020/11/10/Vue-%EA%B0%9C%EB%B0%9C-%EC%88%9C%EC%84%9C-%EC%A0%95%EB%A6%AC/"},{"title":"Synchronous, Asynchronous와 Blocking, Non-Blocking","text":"결론 Synchronous, Asynchronous 는 두 개 이상의 대상에 대한 시간 을 관리하는 방법이고 Blocking, Non-Blocking 은 직접 제어 할 수 없는 대상을 처리하는 방법에 대한 것이다. Synchronous, Asynchronous 두 개 이상의 대상들의 시간을 처리하는 방식 Synchronous는 두 개 이상의 대상들의 시간을 일치 시키는 것 으로 메서드가 종료되는 시간과 결과를 전달받은 시간이 일치하면 Synchronous(동기) 방식이다. Asynchronous는 두 개 이상의 대상들의 시간을 일치 시키자 않는 것 으로 메서드가 종료되는 시간과 결과를 전달받은 시간이 일치하지 않으면 Asynchronous(비동기) 방식이다. Blocking, Non-Blocking 직접 제어 할 수 없는 대상에 대한 처리 방식 Blocking은 직접 제어 할 수 없는 대상이 작업이 끝날 떄 까지 제어권을 넘기지 않아 작업이 끝날 떄 까지 대기 하는 방식이다. Non-Blocking은 직접 제어 할 수 없는 대상의 작업의 종료와 관계없이 제어권을 바로 다시 얻어와 다른 일을 할 수 있게 하는 방식이다. 본론Synchronous우선 Synchronous의 뜻을 사전에선 아래와 같이 정의하고 있다. 동시 발생하는 네이버 어학사전 이 처럼 두 개 이상의 작업을 동시에 발생시키거나 동시에 종료시키는 행동을 말한다. 동기 방식을 사용 할 경우 메서드를 호출 했을 때 결과를 호출한 쪽에서 스스로 확인하고 처리하기 떄문에 결과를 처리 할 때까지 기다렸다가 결과를 전달받고 메서드를 종료 시킨다. 간단히 요약하면 메서드를 호출하면 그 메서드가 종료되는 시간과 결과가 return 되는 시간이 같다는 것으로 메서드가 종료되는 시간과 결과가 return 되는 시간이 같으므로 동기 방식이라 말한다. 혹은 2개 이상의 일을 각각 실행시켜 A가 끝나는 시간과 B가 시작하는 시간이 같은 경우도 마찬가지로 동기 방식이라고 할 수 있다. Java로 예를 들면 쓰레드를 동기 시키기 위해 사용하는 synchronized가 있고 일반적으로는 일부러 설정하지 않는 한 보통의 메서드 호출은 모두 동기 방식으로 사용된다. AsynchronousAsynchronous 비동기 방식은 부정형 접두사 A를 붙여서 두 개 이상의 대상의 시간을 일치 시키지 않는 방식으로 동기 방식과 반대로 동작한다. 즉 메서드를 호출 했을 때 결과가 리턴되지 않더라도 다른 작업을 수행하거나 메서드를 종료하고 나중에 처리되면 그 때 결과물을 가져온다. 이 때 메서드를 호출한 시간과 리턴 받은 시간이 일치하지 않으므로 이러한 방식을 비동기 방식이라 한다. 보통 ajax를 통해 많이 사용 해봤을 것이고, Java에선 쓰레드를 활용해 비동기적으로 처리 할 수 있고, Spring에선 @Async Annotation을 이용해 비동기 방식을 처리 할 수 있다. Blocking결론에서 말한 것 처럼 Blocking은 직접 제어 할 수 없는 대상이 작업이 끝날 때 까지 제어권을 넘기지 않아 작업이 끝날 때 까지 대기하게 하는 방식이다. 예를 들면 스타크래프트에서 테란의 SCV는 한번 건물을 짓기 시작하면 건설이 끝날 때 까지 다른 동작을 할 수 없으므로, Blocking 상태라고 할 수 있고, Java에선 System.in 같은 I/O 처리를 예로 들 수 있다. Non-BlockingBlocking과 반대되는 방식으로 작업의 처리 여부와 상관없이 작업을 호출한 쪽이 다시 제어권을 가져와서 자유롭게 다른 일을 처리할 수 있는 방식을 Non-Blocking 방식이라고 한다. 예를 들어 프로토스의 프로브는 건물을 짓게 하면 차원 균열만 개방하고 바로 미네라를 캐는 등의 다른 일을 수행 할 수 있으므로 프로브는 Non-Blocking 상태라고 할 수 있다. 참고 사이트 https://velog.io/@codemcd/Sync-VS-Async-Blocking-VS-Non-Blocking-sak6d01fhx https://www.youtube.com/watch?v=HKlUvCv9hvA&amp;t=806s https://nesoy.github.io/articles/2017-01/Synchronized https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/ https://www.notion.so/Sync-vs-Async-Block-vs-Non-block-da3e458e74c84201abfd4bcbf2ed00c2","link":"/2020/11/16/Synchronous-Asynchronous%EC%99%80-Blocking-Non-Blocking/"},{"title":"Spring boot + thymeleaf custom error page 적용","text":"서론기본적으로 was나 spring boot에서 error page를 제공해 주고 있으나 보기 이쁘지도 않을뿐더러 stacktrace 가 그대로 노출되기 때문에 보안상으로도 좋을 것이 없다. 본론하여 보통 에러 페이지를 따로 개발하여 보여주게 되는데 thymeleaf과 spring boot을 사용할 경우 https://www.thymeleaf.org/doc/articles/springsecurity.html 위 주소의 tymeleaf 공식 홈페이지에서 제시한 방법처럼 적용하면 된다. 이 경우 spring security가 전혀 관여하지 않기 때문에 ExceptionHandler를 추가할 것을 권하고 있다. 나는 에러 유형에 따라 이미지 파일을 보여주도록 custom error page 기능을 아래 처럼 적용했다. Controller12345678910111213141516171819202122232425@Controllerpublic class CustomErrorController implements ErrorController { private static String IMAGE_PATH = &quot;images/error/&quot;; @ExceptionHandler(Throwable.class) @GetMapping(&quot;/error&quot;) public String handleError(HttpServletRequest request, Model model) { Object status = request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE); String statusMsg = status.toString(); HttpStatus httpStatus = HttpStatus.valueOf(Integer.valueOf(statusMsg)); model.addAttribute(&quot;msg&quot;, statusMsg + &quot; &quot; + httpStatus.getReasonPhrase()); model.addAttribute(&quot;src&quot;, IMAGE_PATH + statusMsg + &quot;.jpg&quot;); return &quot;thymeleaf/error&quot;; } @Override public String getErrorPath() { // TODO Auto-generated method stub return &quot;/error&quot;; }} View123456789101112&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;title&gt;Error page&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/error.css&quot; th:href=&quot;@{/css/error.css}&quot; /&gt; &lt;/head&gt;&lt;body&gt; &lt;img th:alt=&quot;${msg}&quot; th:src=&quot;${src}&quot;&gt;&lt;/body&gt;&lt;/html&gt; thymeleaf를 사용하지 않는 경우thymeleaf를 사용하지 않을 경우엔 resource 폴더 하위에 static 폴더에 error 페이지를 만들어놓고 CustomController를 아래처럼 IllegalStateException 을 throw 하기만 하면 된다. Controller12345678910111213141516public class CustomErrorController implements ErrorController { private String PATH = &quot;/error&quot;; @GetMapping(&quot;/error&quot;) public String errorpage(){ throw new IllegalStateException(&quot;Error&quot;); } @Override public String getErrorPath() { // TODO Auto-generated method stub return PATH; }} 결론적용 결과 나는 https://http.cat/ 라는 http status code마다 위처럼 고양이 사진을 보여주는 사이트에서 이미지 파일을 가져와 적용하였다. 그 외에 다른 사이트들에선 어떻게 에러 페이지를 보여주는지 확인해보고 각자 에러 페이지를 작성하면 좋을 것이다. [번역] ‘404 에러페이지’ 24가지 분석 -1 참고 사이트 https://docs.spring.io/autorepo/docs/spring-boot/current/reference/htmlsingle/#boot-features-error-handling-custom-error-pages https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc https://www.thymeleaf.org/doc/articles/springsecurity.html https://velog.io/@godori/spring-boot-error https://eblo.tistory.com/50","link":"/2020/04/15/custom-error-page/"},{"title":"Ajax에서 SUCCESS가 JSON이면, 전송 할 때도 JSON으로","text":"문제토이 프로젝트 진행 중 문자열 하나만 서버로 넘겨 받아 처리하면 되는 상황이여서 아래 코드 처럼 dataType을 ‘text’로 설정했다. 12345678910$.ajax({ type:&quot;GET&quot; , url: &quot;/test&quot; , data: data , dataType : 'text' , cache: false , success: function(data) { drawGrid(data); }}); 허나 위 처럼 하니, success에서 받는 data가 json object가 아닌 String type으로 받아지는 문제가 발생했다. 해결1234567891011$.ajax({ type:&quot;GET&quot; , url: &quot;/test&quot; , data: data , contentType: &quot;application/json&quot; , dataType : 'JSON' , cache: false , success: function(data) { drawGrid(data); }}); 결국 위 처럼 dataType을 ‘JSON’으로,contentType도 ‘JSON’으로 변경하고Controller도 json으로 변경하니 success에서 받는 dat도 정상적으로 JSON Object로 넘어왔다. 결론받는 데이터가 json이라면 전송 때 json일 필요가 없어도 json으로 맞춰주자.","link":"/2020/04/20/ajax%EC%97%90%EC%84%9C-json/"},{"title":"Ajax http status 415 Unsupported Media Type","text":"문제![error]](/images/20200505/image.png) 위 화면 처럼 임시 비밀번호 발급 form을 만들어서 버튼엔 onclick, input box엔 enter key event를 달아서 ajax로 처리하였는데, ​클릭 이벤트로는 정상적으로 동작하였으나 enter key 의 경우 http status 415 Unsupported Media Type 에러가 발생하였다 12345678910There was an unexpected error (type=Unsupported Media Type, status=415).Content type 'application/x-www-form-urlencoded;charset=UTF-8' not supportedorg.springframework.web.HttpMediaTypeNotSupportedException: Content type 'application/x-www-form-urlencoded;charset=UTF-8' not supported at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver.readWithMessageConverters(AbstractMessageConverterMethodArgumentResolver.java:225) at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.readWithMessageConverters(RequestResponseBodyMethodProcessor.java:158) at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.resolveArgument(RequestResponseBodyMethodProcessor.java:131) at org.springframework.web.method.support. HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121) at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:167)... 보통 ajax 통신 시 415 에러가 발생 할 경우 ajax에서 설정한 content type과 contoroller에서 설정한 content type이 다를 경우 발생하는 데 이 경우엔 모두 json으로 설정해놓은 상태 하였는데도 불구하고 발생하여 매우 당황스러웠다 ajax1234567891011121314151617181920function resetPassword() { const userName = document.querySelector(&quot;input[name=username]&quot;).value.trim(); const data = { username : userName }; $.ajax({ type:&quot;POST&quot; , url: &quot;/reset/password&quot; , data: JSON.stringify(data) , dataType : &quot;json&quot; , contentType: &quot;application/json&quot; , cache: false , success: function(data) { let alert = document.querySelector(&quot;.mb-0&quot;); alert.innerText = data; document.querySelector(&quot;.alert.alert-success&quot;).style.display = &quot;block&quot;; } }); } Controller12345678910@PostMapping(value=&quot;/reset/password&quot;, produces = &quot;application/json&quot;)@ResponseBodypublic String processResetPasswordForm(@RequestBody User user) throws JsonProcessingException { String tempPassword = userService.setTempPassWord(user); String msg = &quot;임시 비밀번호 : &quot; + tempPassword; System.out.println(msg); ObjectMapper objMapper = getObjectMapperConfig(); return objMapper.writeValueAsString(msg);} 해결하여 헤매던 도중 enter key event를 지정하지 않아도 이벤트가 발생하여 똑같이 415 에러를 뱉어내는 것으로 확인돼서 적용한 thymeleaf나, bootstrap 등 어디선가 submit 을 보내고 있다고 판단하여 preventDefault() function으로 이벤트를 정지시키고 작성한 ajax를 실행시켰더니 정상적으로 동작하였다 form의 submit event에 preventDefault()를 추가12345document.querySelector(&quot;#frm&quot;).addEventListener('submit', function(e) { e.preventDefault(); resetPassword(); }); 정상적으로 실행된 모습![success]]](/images/20200505/image2.png) 전체 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head th:replace=&quot;fragments/config :: configFragment&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;d-flex justify-content-center h-100&quot;&gt; &lt;div class=&quot;card&quot; style=&quot;height:auto;&quot;&gt; &lt;div class=&quot;card-header&quot;&gt; &lt;h3&gt;Reset Password&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;form id=&quot;frm&quot; th:action=@{/reset/password} method=&quot;post&quot;&gt; &lt;div class=&quot;alert alert-success&quot; role=&quot;alert&quot; style=&quot;display:none;&quot;&gt; &lt;h4 class=&quot;alert-heading&quot;&gt;Well done!&lt;/h4&gt; &lt;p&gt;해당 비밀번호는 임시로 생성된 비밀번호 입니다. &lt;br /&gt;로그인 후 꼭 비밀번호를 변경하여 주세요.&lt;/p&gt; &lt;hr&gt; &lt;p class=&quot;mb-0&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;alert alert-danger&quot; role=&quot;alert&quot; style=&quot;float:left; margin-right:1rem; display:none;&quot; &gt;&lt;/div&gt; &lt;div class=&quot;input-group form-group&quot;&gt; &lt;div class=&quot;input-group-prepend&quot;&gt; &lt;span class=&quot;input-group-text&quot;&gt;&lt;i class=&quot;fas fa-user&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/div&gt; &lt;input type=&quot;text&quot; onkeyup=&quot;checkUserName()&quot; class=&quot;form-control&quot; name=&quot;username&quot; placeholder=&quot;username&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;submit&quot; onclick=&quot;resetPassword()&quot; value=&quot;확인&quot; class=&quot;btn float-right login_btn&quot; disabled&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=&quot;card-footer&quot;&gt; &lt;div class=&quot;d-flex justify-content-center links&quot;&gt; Don't have an account?&lt;a href=&quot;/login&quot;&gt;Sign In&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; &lt;link th:href=&quot;@{/css/login.css}&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; &lt;!--Fontawesome CDN--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://use.fontawesome.com/releases/v5.3.1/css/all.css&quot; integrity=&quot;sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;script th:inline=&quot;javascript&quot;&gt; document.querySelector(&quot;#frm&quot;).addEventListener('submit', function(e) { e.preventDefault(); resetPassword(); }); function checkUserName() { const data = document.querySelector(&quot;input[name=username]&quot;).value; let isExist = true; $.ajax({ type:&quot;POST&quot; , url: &quot;/reset/password/check&quot; , data: JSON.stringify(data) , dataType : &quot;json&quot; , contentType: &quot;application/json&quot; , cache: false , success: function(data) { let alert = document.querySelector(&quot;.alert.alert-danger&quot;); if (empty(data)) { alert.innerText = &quot;&quot;; alert.style.display = &quot;none&quot;; isExist = true; document.querySelector(&quot;.btn.float-right.login_btn&quot;).removeAttribute(&quot;disabled&quot;); } else { alert.innerText = data; alert.style.display = &quot;initial&quot;; isExist = false; document.querySelector(&quot;.btn.float-right.login_btn&quot;).setAttribute(&quot;disabled&quot;, &quot;disabled&quot;); } } }); return isExist; } document.querySelector(&quot;input[name=username]&quot;).addEventListener(&quot;keydown&quot;, key =&gt; { if (key.keyCode == 13) { resetPassword(); } }); function resetPassword() { const isExist = checkUserName(); if (!isExist) { return; } const userName = document.querySelector(&quot;input[name=username]&quot;).value.trim(); const data = JSON.stringify({ username : userName }); $.ajax({ type:&quot;POST&quot; , url: &quot;/reset/password&quot; , data: data , dataType : &quot;json&quot; , contentType: &quot;application/json&quot; , cache: false , success: function(data) { let alert = document.querySelector(&quot;.mb-0&quot;); alert.innerText = data; document.querySelector(&quot;.alert.alert-success&quot;).style.display = &quot;block&quot;; } }); } &lt;/script&gt;&lt;/html&gt; 전체 프로젝트 코드 https://github.com/jungguji/wordbook 참고 사이트 https://developer.mozilla.org/ko/docs/Web/HTTP/Status https://developer.mozilla.org/ko/docs/Web/API/Event/preventDefault","link":"/2020/05/05/ajax-content-type-error/"},{"title":"failed to lazily initialize a collection of role","text":"서론연관관계에 있는 객체를 가져와서 set 하는 메서드를 테스트 하는 도중 아래와 같은 에러가 발생하였다. 본론해당 에러12345678910111213141516171819202122232425262728293031323334353637org.hibernate.LazyInitializationException: failed to lazily initialize a collection of role: com.jjlee.wedding.payment.domain.Cost.costOptions, no session or session was closed at org.hibernate.collection.AbstractPersistentCollection.throwLazyInitializationException(AbstractPersistentCollection.java:383) at org.hibernate.collection.AbstractPersistentCollection.throwLazyInitializationExceptionIfNotConnected(AbstractPersistentCollection.java:375) at org.hibernate.collection.AbstractPersistentCollection.readSize(AbstractPersistentCollection.java:122) at org.hibernate.collection.PersistentBag.size(PersistentBag.java:248) at com.xxxxxx.ImplTest.가져와서_셋해야하는지_테스트(CostServiceImplTest.java:89) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26) at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75) at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86) at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:252) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:94) at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329) at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293) at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306) at org.junit.runners.ParentRunner.run(ParentRunner.java:413) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:191) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33) at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230) at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58) 이 때 디버깅을 해보면 연결된 entitiy에서 1Unable to evaluate the expression Method threw 'org.hibernate.LazyInitializationException' exception. 라는 에러가 발생해 있는데 이는 결국 select 한 entitiy가 영속성 컨텍스트 내에 존재하지 않기 때문에 발생한 애러이다.위 에러에서 말하는 세션이 바로 영속성 컨텍스트를 말하는 것이고, 이는 한 트랜잭션안에 해당 entitiy가 존재하지 않다는 것과 같은 말이다. 해결이를 해결하기 위해선 현재 지연로딩으로 되어있는 연관관계를 즉시로딩으로 변경하여 한번에 가져오던가,혹은 Test 메서드에 @Transactional 어노테이션을 줘서 트랜잭션 내에 존재하도록 해주면 테스트가 정상적으로 통과되게 된다. 결과 참고 사이트 https://bebong.tistory.com/entry/JPA-Lazy-Evaluation-LazyInitializationException-could-not-initialize-proxy-–-no-Session https://ankonichijyou.tistory.com/entry/JPA-OneToMany-오류","link":"/2021/01/22/failed-to-lazily-initialize-a-collection-of-role/"},{"title":"백준 11399번: ATM","text":"https://www.acmicpc.net/problem/11399 소스123456789101112public static int solution(int n, int[] times) { Arrays.sort(times); int answer = 0; for (int i = 0; i &lt; times.length; i++) { answer += times[i] * (n-i); } return answer;} 흐름 시간이 짧게 걸리는 사람이 앞에 올수록 전체 수행 시간이 짧아지므로 sorting부터 실행 앞에 사람이 걸리는 시간은 그 뒤 사람들도 그만큼 시간이 + 되는 것이므로 n-i 한 값을 곱함 ex) 첫 번째 사람이 1분 걸리면 2, 3, 4, 5 번째 사람도 1분씩 더 걸리게 됨 다 더한 값을 출력하면 끝","link":"/2020/03/26/%EB%B0%B1%EC%A4%80-11399%EB%B2%88-ATM/"},{"title":"백준 11047번: 동전 0","text":"문제https://www.acmicpc.net/problem/11047 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String coinAndMoney = br.readLine(); String[] coinAndMoneyArray = coinAndMoney.split(&quot; &quot;); int coinAmount = Integer.parseInt(coinAndMoneyArray[0]); long money = Long.parseLong(coinAndMoneyArray[1]); long[] coinCategory = getCoincategory(coinAmount, br); long answer = solution(coinAmount, money, coinCategory); System.out.println(answer);}public static long[] getCoincategory(int coinAmount, BufferedReader br) throws IOException { long[] result = new long[coinAmount]; for (int i = 0; i &lt; coinAmount; i++) { result[i] = Integer.parseInt(br.readLine()); } return result;}public static long solution(int n, long money, long[] array) { long answer = 0; for (int i = n - 1; i &gt;= 0; i--) { if (array[i] &gt; money) { continue; } answer += (money / array[i]); money %= array[i]; if (money == 0) { break; } } return answer;} 흐름 돈의 종류 만큼 돌면서 큰 수 부터 가지고 있는 돈을 나눔 돈의 가치가 더 큰 경우엔 나눌 수 없으므로 continue 돈으로 갖고 있는 돈을 나눈 값을 더하고 남은 값은 다시 나눠야 하므로 money에 다시 저장함 momeny가 0이 되면 나눌 돈이 없는 것이므로 사용한 돈 갯수 return 끝 결과 테스트 케이스12345678910111213141516171819202122long[] array = new long[] {1,5,10,50,100,500,1000,5000,10000,50000};assertEquals(6, test.solution(10, 4200, array));assertEquals(12, test.solution(10, 4790, array));assertEquals(1, test.solution(10, 50000, array));assertEquals(2000, test.solution(10, 100000000, array));array = new long[] {1};assertEquals(2, test.solution(1, 2, array));assertEquals(1, test.solution(1, 1, array));assertEquals(100000000, test.solution(1, 100000000, array));array = new long[] {1, 5};assertEquals(1, test.solution(2, 5, array));array = new long[] {1, 3};assertEquals(2, test.solution(2, 4, array));array = new long[] {1, 100};assertEquals(1, test.solution(2, 100, array));array = new long[] {5000};assertEquals(1, test.solution(1, 5000, array)); 나머지는 입력 값 처리이고 solution 메서드가 주요 로직이므로 solution 메서드를 테스트 이렇게 테스트 할 경우 입력처리 때문에 에러가 발생 할 수 있으니 꼭 java application으로 함께 테스트 해볼 것","link":"/2020/05/26/%EB%B0%B1%EC%A4%80-11047%EB%B2%88-%EB%8F%99%EC%A0%84-0/"},{"title":"백준 11724번: 연결 요소의 개수","text":"문제https://www.acmicpc.net/problem/11724 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int[] nm = convertStringArrayToIntegerArray(br.readLine().split(&quot; &quot;)); int n = nm[0]; int m = nm[1]; boolean[][] graph = new boolean[n+1][n+1]; while (m-- &gt; 0) { int[] xy = convertStringArrayToIntegerArray(br.readLine().split(&quot; &quot;)); graph[xy[0]][xy[1]] = true; graph[xy[1]][xy[0]] = true; } int answer = 0; boolean[] isVisit = new boolean[n+1]; for (int i = 1; i &lt; graph.length; i++) { if (!isVisit[i]) { answer += bfs(isVisit, graph, i); } } System.out.println(answer);}private static int[] convertStringArrayToIntegerArray(String[] args) { int[] array = new int[args.length]; int i = 0; for (String str : args) { array[i++] = Integer.parseInt(str); } return array;}private static int bfs(boolean[] isVisit, boolean[][] graph,int startIndex) { Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.offer(startIndex); isVisit[startIndex] = true; while (!queue.isEmpty()) { int x = queue.poll(); for (int i = 1; i &lt; isVisit.length; i++) { if (isVisit[i]) { continue; } if (graph[x][i]) { queue.offer(i); isVisit[i] = true; } } } return 1;} 흐름 그래프의 연결 관계를 인접행렬로 만들기 위해 정점의 개수 + n한 크기의 2차원 배열을 만들고, 이 문제에서 그래프는 방향이 없는 무방향 그래프이기 때문에 a-&gt;b로 가는 간선이 있으면 b-&gt;a로 가는 간선도 있는 것이므로 대칭이 되도록 배열에 저장한다. 이후 정점의 개수만큼 루프 돌면서 연결요소의 개수를 구하는데 아직 간선이 연결되지 않은 정점일 경우에만 BFS 탐색을 통해 탐색한다. queue를 이용해 bfs를 구현하는데 우선 탐색이 시작되는 정점의 index를 queue에 저장하고, isVisit[] 변수에도 true로 해당 index를 탐색했다고 저장한다. queue가 빌 때 까지 반복하면서 queue에 저장된 index를 poll한다. 정점의 개수 만큼 반복하면서 이미 연결된 정점이면 넘어가고 아직 연결되지 않은 정점이면서 다른 정점과 연결된 정점이면 queue에 해당 index를 저장하고, 방문했으니 true도 저장한다. queue가 비어 루프가 종료되면 연결 요소 하나가 완성된 것이므로 1을 return 하고 bfs를 종료한다. return된 1들을 저장해 모든 정점을 탐색 후 종료한다. 끝 결과 참고 사이트 https://sarah950716.tistory.com/12","link":"/2020/12/08/%EB%B0%B1%EC%A4%80-11724%EB%B2%88-%EC%97%B0%EA%B2%B0-%EC%9A%94%EC%86%8C%EC%9D%98-%EA%B0%9C%EC%88%98/"},{"title":"백준 1406번: 에디터","text":"문제https://www.acmicpc.net/problem/1406 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); char[] input = br.readLine().toCharArray(); LinkedList&lt;Character&gt; list = new LinkedList&lt;&gt;(); for (char c : input) { list.add(c); } ListIterator&lt;Character&gt; it = list.listIterator(); while (it.hasNext()) { it.next(); } int n = Integer.parseInt(br.readLine()); while (n-- &gt; 0) { String command = br.readLine(); switch (command) { case &quot;L&quot; : if (it.hasPrevious()) { it.previous(); } break; case &quot;D&quot; : if (it.hasNext()) { it.next(); } break; case &quot;B&quot; : if (it.hasPrevious() &amp;&amp; !list.isEmpty()) { it.previous(); it.remove(); } break; default: it.add(command.charAt(2)); break; } } StringBuilder sb = new StringBuilder(); for (char c : list) { sb.append(c); } System.out.println(sb);} 이 문제는 로직보다 걸리는 시간이 문제였다. 처음엔 LinkedList를 그대로 사용해 add, remove를 했지만 시간초과로 인해 ListIterator을 이용해 해결했다. ListIterator List를 양방향으로 탐색하고, 루프 중에 리스트를 수정하고, 리스트에서 현재 위치를 가져올 수 있다. 커서는 previous()로 리턴되는 원소와 next()로 리턴되는 원소 사이에 존재한다. 12 Element(0) Element(1) Element(2) ... Element(n-1)cursor positions: ^ ^ ^ ^ ^ remove()와 set()를 호출해도 커서의 위치는 움직이지 않는다. remove() 호출 시 next()혹은 preivous()에 의해 리턴된 마지막 요소를 리스트에서 제거한다. 123456case &quot;B&quot; : if (it.hasPrevious() &amp;&amp; !list.isEmpty()) { it.previous(); it.remove(); } break; 결과 참고 사이트 https://www.acmicpc.net/board/view/59173 https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ListIterator.html","link":"/2020/12/14/%EB%B0%B1%EC%A4%80-1406%EB%B2%88-%EC%97%90%EB%94%94%ED%84%B0/"},{"title":"백준 18870번: 좌표 압축","text":"문제https://www.acmicpc.net/problem/18870 코드123456789101112131415161718192021222324252627282930313233public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); br.readLine(); Integer[] array = convertStringArrayToIntegerArray(br.readLine().split(&quot; &quot;)); List&lt;Integer&gt; list = Arrays.asList(array.clone()); Collections.sort(list); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int index = 0; for (int i : list) { if (!map.containsKey(i)) { map.put(i, index++); } } StringBuilder sb = new StringBuilder(); for (int i : array) { sb.append(map.get(i)).append(&quot; &quot;); } System.out.println(sb.toString());}private static Integer[] convertStringArrayToIntegerArray(String[] args) { Integer[] array = new Integer[args.length]; int i = 0; for (String str : args) { array[i++] = Integer.parseInt(str); } return array;} 흐름 입력받은 좌표를 저장한 리스트로 수정하면 출력 순서를 맞출 수 없으니 우선 좌표 list를 복사한다. 복사한 list를 정렬하고 순서대로 반복하면서 좌표값을 key로 index를 저장한다. {-10 : 0}, {-9, 1}… {4,4} 입력받은 좌표를 순서대로 반복하면서 map에 key로 index를 가져온다. 끝 좌표 압축의 이유 문제의 예제인 좌표 {2 4 -10 4 -9}을 위와 같은 알고리즘으로 압축하면 {2 3 0 3 1}이 되는데 위 그림 처럼 압축된 점들도 같은 동일선상 안에 놓이게 된다. 이렇게 범위가 매우 넓은 좌표의 경우에 좌표를 인덱싱해서 처리 할 경우 손쉽게 처리 할 수 있게 된다. 결과 참고 사이트 https://www.desmos.com/calculator/id7dqtpnmv?lang=ko https://codingdog.tistory.com/entry/%EC%A2%8C%ED%91%9C-%EC%95%95%EC%B6%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B2%94%EC%9C%84%EA%B0%80-%ED%81%B4-%EB%95%8C-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B3%B5%EA%B0%84%EC%9D%84-%EC%A4%84%EC%9D%BC%EA%B9%8C%EC%9A%94","link":"/2020/12/15/%EB%B0%B1%EC%A4%80-18870%EB%B2%88-%EC%A2%8C%ED%91%9C-%EC%95%95%EC%B6%95/"},{"title":"백준 18111번: 마인크래프트","text":"문제https://www.acmicpc.net/problem/18111 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class 마인크래프트 { public static void main(String[] args) throws IOException { try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) { int[] nmb = convertStringArrayToIntegerArray(br.readLine().split(&quot; &quot;)); int n = nmb[0]; int m = nmb[1]; int[][] ground = initGround(br, n, m); int[] minAndMax = getMinAndMax(ground); int[] timeAndHigh = getMinimumConstructionTime(ground, nmb[2], minAndMax[0], minAndMax[1]); System.out.println(timeAndHigh[0] + &quot; &quot; + timeAndHigh[1]); } } private static int[] convertStringArrayToIntegerArray(String[] args) { int[] array = new int[args.length]; int i = 0; for (String str : args) { array[i++] = Integer.parseInt(str); } return array; } private static int[][] initGround(BufferedReader br, int n, int m) throws IOException { int[][] ground = new int[n][m]; for (int i = 0; i &lt; n; i++) { ground[i] = convertStringArrayToIntegerArray(br.readLine().split(&quot; &quot;)); } return ground; } private static int[] getMinAndMax(int[][] ground) { int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for (int[] i : ground) { for (int j : i) { min = min &gt; j ? j : min; max = max &lt; j ? j : max; } } return new int[] {min, max}; } private static int[] getMinimumConstructionTime(int[][] ground, int inventory, int min, int max) { int answerTime = Integer.MAX_VALUE; int answerHigh = 0; for (int currentHigh = min; currentHigh &lt;= max; currentHigh++) { int up = 0; int down = 0; for (int i = 0; i &lt; ground.length; i++) { for (int j = 0; j &lt; ground[0].length; j++) { int high = ground[i][j] - currentHigh; if (high &gt; 0) { down += high; } else if (high &lt; 0) { up -= high; } } } if (down + inventory &gt;= up) { int time = (down * 2) + up; if (answerTime &gt;= time) { answerTime = time; answerHigh = currentHigh; } } } return new int[]{answerTime, answerHigh}; }} 흐름 n * m 크기의 2차원 배열을 만들어서 저장한다. 땅 높이를 저장한 2차원 배열을 돌면서 가장 작은 높이와 가장 큰 높이를 구한다. 우선, 가장 낮은 높이부터 가장 높은 높이 까지 반복하면서 3번에 해당하는 높이를 기준으로 2차원 배열을 2중 루프 돌면서 모든 땅에서 현재 땅 높이를 뺀다. (int high = ground[i][j] - currentHigh;) 그 높이가 0보다 크면 기준이 되는 땅보다 높은 것 이므로 땅을 깎아서 기준이 되는 높이와 맞추기 위해 down 변수에 높이를 더한다. 반대로 0 보다 작으면 기준이 되는 땅 보다 낮은 것이므로 땅을 높여서 기준이 되는 높이와 맞추기 위해 up 변수에 높이를 더해야 하는데 high가 0보다 작으면 - 이므로 up에 높이를 - 해서 더한다. 그렇게 2차원 배열을 전부 반복했으면 땅을 깎으면서 구한 블록과 원래 인벤토리에 있던 블록의 갯수가 쌓아야되는 블록의 갯수보다 크거나 같아야 높이를 맞출 수 있으므로 크거나 같은지 비교해서 땅을 깎는건 2초가 걸리므로 down * 2 한 값에 쌓아야 되는 높이 만큼 더한다. 그렇게 구한 걸리는 시간이 이전에 구한 최소 시간 보다 작으면 최소 시간을 지금 구한 time으로 변경하고 걸리는 시간이 같은 경우엔 가장 높은 높이로 구해야 하므로 높이도 현재 높이로 바꿔준다. 높이는 제일 작은 높이부터 제일 큰 높이로 순차적으로 올라가고 있으므로 나중에 구한 높이가 이전에 구한 높이 보다 무조건 높다. 끝. 결과 P.S BFS로 시도했던 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181package algorithm.baekjoon.class2.bruteforce;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;import java.util.Queue;public class 마인크래프트 { public static void main(String[] args) throws IOException { try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) { int[] nmb = convertStringArrayToIntegerArray(br.readLine().split(&quot; &quot;)); int n = nmb[0]; int m = nmb[1]; int[][] ground = initGround(br, n, m); boolean[][] isPassed = new boolean[n][m]; List&lt;Block&gt; blockList = getBlockList(n, m, ground, isPassed); int[] timeAndHigh = getMinimumConstructionTime(blockList, nmb[2]); System.out.println(timeAndHigh[0] + &quot; &quot; + timeAndHigh[1]); } } private static int[] convertStringArrayToIntegerArray(String[] args) { int[] array = new int[args.length]; int i = 0; for (String str : args) { array[i++] = Integer.parseInt(str); } return array; } private static int[][] initGround(BufferedReader br, int n, int m) throws IOException { int[][] ground = new int[n][m]; for (int i = 0; i &lt; n; i++) { ground[i]= convertStringArrayToIntegerArray(br.readLine().split(&quot; &quot;)); } return ground; } private static List&lt;Block&gt; getBlockList(int n, int m, int[][] ground, boolean[][] isPassed) { List&lt;Block&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (isPassed[i][j]) { continue; } int count = breadthFirstSearch(i, j, ground, isPassed); list.add(new Block(ground[i][j], count)); } } return list; } private static int breadthFirstSearch(int x, int y, int[][] picture, boolean[][] isPassed) { final int[] xAround = new int[]{1, -1, 0, 0}; final int[] yAround = new int[]{0, 0, 1, -1}; int areaRange = 1; Queue&lt;Position&gt; queue = new LinkedList&lt;&gt;(); setPassedArea(isPassed, queue, x, y); while (!queue.isEmpty()) { Position currentPosition = queue.poll(); for (int i = 0; i &lt; xAround.length; i++) { int moveX = xAround[i] + currentPosition.x; int moveY = yAround[i] + currentPosition.y; if (!isSameAreaValidation(moveX, moveY, picture, isPassed, currentPosition)) { continue; } setPassedArea(isPassed, queue, moveX, moveY); ++areaRange; } } return areaRange; } private static void setPassedArea(boolean[][] isPassed, Queue&lt;Position&gt; queue, int x, int y) { isPassed[x][y] = true; queue.offer(new Position(x, y)); } private static boolean isSameAreaValidation(int moveX, int moveY, int[][] picture, boolean[][] isPassed, Position currentPosition) { if (isOutOfPicture(moveX, moveY, picture)) { return false; } if (isPassed[moveX][moveY]) { return false; } if (picture[currentPosition.x][currentPosition.y] != picture[moveX][moveY]) { return false; } return true; } private static boolean isOutOfPicture(int moveX, int moveY, int[][] picture) { if (moveX &lt; 0 || moveY &lt; 0) { return true; } if (picture.length &lt;= moveX || picture[0].length &lt;= moveY) { return true; } return false; } private static int[] getMinimumConstructionTime(List&lt;Block&gt; blockList, int inventory) { int answerTime = Integer.MAX_VALUE; int answerHigh = 0; for (Block currentBlock : blockList) { int currentHigh = currentBlock.high; int up = 0; int down = 0; for (Block loopBlock : blockList) { int loopHigh = loopBlock.high; int loopCount = loopBlock.count; if (currentHigh &gt; loopHigh) { up += (currentHigh - loopHigh) * loopCount; } else if (currentHigh &lt; loopHigh) { down += (loopHigh - currentHigh) * loopCount; } } if (down + inventory &gt;= up) { int time = (down * 2) + up; if (answerTime &gt; time) { answerTime = time; answerHigh = currentBlock.high; } } } return new int[]{answerTime, answerHigh}; } static class Block { private Integer high; private Integer count; public Block(Integer high, Integer count) { this.high = high; this.count = count; } } static class Position { private int x; private int y; public Position(int x, int y) { this.x = x; this.y = y; } }} BFS로 높이 별 갯수를 구한 후 높이 별로 sorting 하여 처리 하려고 했는데 시간 초과로 실패","link":"/2020/11/10/%EB%B0%B1%EC%A4%80-18111%EB%B2%88-%EB%A7%88%EC%9D%B8%ED%81%AC%EB%9E%98%ED%94%84%ED%8A%B8/"},{"title":"백준 1920번: 수 찾기","text":"문제https://www.acmicpc.net/problem/1920 코드1234567891011121314151617181920212223242526272829303132333435363738public static void main(String[] args) throws IOException { try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) { br.readLine(); int[] array1 = convertStringArrayToIntegerArray(br.readLine().split(&quot; &quot;)); br.readLine(); int[] array2 = convertStringArrayToIntegerArray(br.readLine().split(&quot; &quot;)); int[] answer = solution(array1, array2); for (int i : answer) { System.out.println(i); } }}private static int[] convertStringArrayToIntegerArray(String[] args) { int[] array = new int[args.length]; int i = 0; for (String str : args) { array[i++] = Integer.parseInt(str); } return array;}public static int[] solution(int[] array1, int[] array2) { Arrays.sort(array1); int[] answer = new int[array2.length]; int index = 0; for (int i : array2) { answer[index++] = Arrays.binarySearch(array1, i) &lt; 0 ? 0 : 1; } return answer;} 흐름 이진 탐색(Binary Search)을 위해 검색 할 array를 우선 정렬한다. array에 value가 존재하면 1, 없으면 0으로 저장하기 위한 answer array를 생성한다. array에 value가 존재하는 지 확인하기 위해 array2를 돌면서 element를 꺼낸다. 꺼낸 element를 이진 탐색으로 array안에서 검색해서 존재하면 1, 아니면 0을 저장한다. 결과를 return 한다. 끝. Arrays.binarySearch1234567891011121314151617181920212223public static int binarySearch(int[] a, int key) { return binarySearch0(a, 0, a.length, key);}// Like public version, but without range checks.private static int binarySearch0(int[] a, int fromIndex, int toIndex, int key) { int low = fromIndex; int high = toIndex - 1; while (low &lt;= high) { int mid = (low + high) &gt;&gt;&gt; 1; int midVal = a[mid]; if (midVal &lt; key) low = mid + 1; else if (midVal &gt; key) high = mid - 1; else return mid; // key found } return -(low + 1); // key not found.} 기준이 되는 array와 array에서 검색 할 value(key)를 입력 받는다. from index가 to index보다 작거나 같은 동안 반복하면서 두 index를 더한 값을 &gt;&gt;&gt; 연산을 통해 나눈다. ex) 15(10) -&gt; 1111(2), 15 &gt;&gt;&gt; 1 = 1111 &gt;&gt;&gt; 1 이므로, 0111(2)가 되고 이는 10진수 7이므로 15를 2로 나눈 값과 같다. ‘&gt;&gt;’ 연산은 부호 비트를 보존하고, ‘&gt;&gt;&gt;’ 연산은 부호 비트 관계없이 무조건 0으로 채운다. 중간이 되는 index를 구해서 array의 중간 값을 구한 후 현재 값이 중간 값 보다 작은 지 큰지 비교하면서 array에 존재하는지 확인하고 존재한다면 array에서 현재 값의 index를 return하고 존재하지 않는 다면 array에서 현재 값의 가장 가까운 index를 음수로 return 한다. 결과 테스트 케이스1234assertArrayEquals(new int[] {1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0}, test.solution(new int[] {1, 3, 4, 6, 9, 13, 18}, new int[] {3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}));assertArrayEquals(new int[] {1, 1, 0, 0, 1}, test.solution(new int[] {4, 1, 5, 2, 3}, new int[] {1, 3, 7, 9, 5}));assertArrayEquals(new int[] {1}, test.solution(new int[] {1,2}, new int[] {2}));assertArrayEquals(new int[] {0,1,0,1,0,1,0,1,0,1}, test.solution(new int[] {2,4,6,8,10}, new int[] {1,2,3,4,5,6,7,8,9,10}));","link":"/2020/09/01/%EB%B0%B1%EC%A4%80-1920%EB%B2%88-%EC%88%98-%EC%B0%BE%EA%B8%B0/"},{"title":"백준 2805번: 나무 자르기","text":"문제https://www.acmicpc.net/problem/2805 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class 나무_자르기 { public static void main(String[] args) throws IOException { try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) { long[] nm = convertStringArrayToLongArray(br.readLine().split(&quot; &quot;)); long m = nm[1]; long[] trees = convertStringArrayToLongArray(br.readLine().split(&quot; &quot;)); long answer = solution(trees, m); System.out.println(answer); } } private static long[] convertStringArrayToLongArray(String[] args) { long[] array = new long[args.length]; int i = 0; for (String str : args) { array[i++] = Integer.parseInt(str); } return array; } public static long solution(long[] trees, long m) { Arrays.sort(trees); long low = 0; long high = trees[trees.length - 1]; long answer = 0; while (low &lt;= high) { long mid = (low + high) &gt;&gt;&gt; 1; long sum = getTrees(trees, mid); if (sum &lt; m) { high = mid - 1; } else { answer = Math.max(answer, mid); low = mid + 1; } } return answer; } private static long getTrees(long[] trees, long mid) { long sum = 0; for (int i = 0; i &lt; trees.length; i++) { sum += trees[i] &gt; mid ? trees[i] - mid : 0; } return sum; }} 흐름 나무들을 크기가 큰 순서로 정렬한다. 0부터 높이가 제일 큰 나무까지 탐색하기 위해 low와 high 변수를 지정한다. low와 high의 중간 값을 구한다. 나무들을 반복하면서 중간 값 보다 크면 나무 길이와 중간 값을 뺀 값을 더한다. 그렇게 벌목한 나무를 전부 더한 값이 필요한 나무 길이인 m 보다 작으면, 벌복한 나무의 길이가 m보다 크거나 같으면, 벌목한 나무가 남는 것 이므로, 나무를 낭비하지 않기 위해 이전에 구한 중간 값(answer) 와 현재 중간 값 중 큰 값을 저장하고 중간 값 + 1 해서 최소 값을 올린다. 반대로 벌목한 나무의 길이가 m 보다 작은 경우 더 크게 자르기 위해 중간 값 - 1을 high에 저장해서 다음 루프 때 (low + high) &gt;&gt;&gt; 1 에서 더 크게 잘릴 수 있도록 한다. low와 high가 같아질 때 까지 반복한다. 끝 결과 테스트 케이스1234567891011assertEquals(15, test.solution(new long[] {20, 15, 10, 17}, 7));assertEquals(3, test.solution(new long[] {6, 6}, 5));assertEquals(4, test.solution(new long[] {6, 6, 6, 6}, 6));assertEquals(500000000, test.solution(new long[] {900000000, 900000000, 900000000, 900000000, 900000000}, 2000000000));assertEquals(19, test.solution(new long[] {20, 15, 10, 17}, 1));assertEquals(0, test.solution(new long[] {2, 2}, 3));assertEquals(21, test.solution(new long[] {13, 23, 21, 32}, 12));assertEquals(2, test.solution(new long[] {1,4,5,7}, 10));assertEquals(1, test.solution(new long[] {51, 1}, 50));assertEquals(999999999, test.solution(new long[] {1000000000}, 1));assertEquals(0, test.solution(new long[] {2, 2,2,2}, 8));","link":"/2020/11/10/%EB%B0%B1%EC%A4%80-2805%EB%B2%88-%EB%82%98%EB%AC%B4-%EC%9E%90%EB%A5%B4%EA%B8%B0/"},{"title":"백준 2751번: 수 정렬하기 2","text":"문제https://www.acmicpc.net/problem/2751 코드1234567891011121314151617181920public static void main(String[] args) throws IOException { try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) { int amount = Integer.parseInt(br.readLine()); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; amount; i++) { list.add(Integer.parseInt(br.readLine())); } Collections.sort(list); StringBuilder sb = new StringBuilder(); for (int i : list) { sb.append(i).append(&quot;\\n&quot;); } System.out.println(sb); }} Arrays.sort(int[]) vs Arrays.sort(Object[]) and Collections.sort(List)Arrays.sort(int[]) DualPivotQuicksort라는 피벗을 두 개를 정해 구간을 3개로 하는 퀵소트를 사용한다. API에 따르면 이 때 평균 O(n log(n)) 성능을 제공하며 일반적으로 기존 (one-pivot) 쿽소트 보다 빠르다고 한다. 하지만 여전히 최악의 경우 O(n^2)인 것은 여전하다. Arrays.sort(Object[]) and Collections.sort(List) java.util.Arrays.useLegacyMergeSort 설정에 따라 true면 legacyMergeSort를 통해 Merge sort로 정렬하고 false면 TimeSort를 통해 Tim sort로 정렬한다. 이 때 기본적으로 java.util.Arrays.useLegacyMergeSort 설정은 false로 지정되어 있다. Tim sort는 Insertion sort와 Merge sort를 결합하여 만든 정렬로 최선의 경우 O(n), 평균적으로 O(n log(n)), 최악의 경우 O(n log(n))의 성능을 제공한다. Tim sort에 대한 자세한 설명 java.util.Arrays.useLegacyMergeSort 확인12345678910... static final class LegacyMergeSort { private static final boolean userRequested = java.security.AccessController.doPrivileged( new sun.security.action.GetBooleanAction( &quot;java.util.Arrays.useLegacyMergeSort&quot;)).booleanValue(); }... new sun.security.action.GetBooleanAction(“java.util.Arrays.useLegacyMergeSort”)).booleanValue(); 를 sysout으로 출력해보면 false가 return 되는 것을 확인할 수 있다. 결과","link":"/2020/11/12/%EB%B0%B1%EC%A4%80-2751%EB%B2%88-%EC%88%98-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0-2/"},{"title":"백준 1152번: 단어의 개수","text":"문제https://www.acmicpc.net/problem/1152 코드12345678910111213141516public static long solution(String args) { char[] tochar = args.trim().toCharArray(); long answer = 0; if (tochar.length == 0) { return answer; } for (char ch : tochar) { if (ch == ' ') { ++answer; } } return answer + 1;} 흐름 문자열 앞 뒤로 공백이 존재 할 수 있으므로 trim() 공백만 있는 문자열인 경우 0 return char array로 변환된 문자열을 돌면서 공백인 경우 count 증가 공백을 기준으로 단어가 만들어졌으니 공백 개수 + 1 return ex) hello, wolrd! = 공백 1개, 문자 2개 끝 결과 테스트 케이스12345assertEquals(6, test.solution(&quot;The Curious Case of Benjamin Button&quot;));assertEquals(3, test.solution(&quot; Mazatneunde Wae Teullyeoyo&quot;));assertEquals(2, test.solution(&quot;Teullinika Teullyeotzi &quot;));assertEquals(7, test.solution(&quot; a b c d e f g &quot;));assertEquals(0, test.solution(&quot; &quot;)); 전체 코드https://github.com/jungguji/algorithm_training/blob/master/src/main/java/algorithm/baekjoon/string/%EB%8B%A8%EC%96%B4%EC%9D%98_%EA%B0%9C%EC%88%98.java","link":"/2020/05/23/%EB%B0%B1%EC%A4%80-%EB%8B%A8%EC%96%B4%EC%9D%98-%EA%B0%9C%EC%88%98/"},{"title":"백준 5525번: IOIOI","text":"문제https://www.acmicpc.net/problem/5525 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); br.readLine(); int answer = solution(n, br.readLine()); System.out.println(answer);}public static int solution(int n, String target) { int answer = 0; char[] s = target.toCharArray(); char[] targetString = getTargetString(n).toCharArray(); int[] fail = failFunction(targetString); int start = 0; int m = 0; while (start &lt;= s.length - targetString.length) { if (m &lt; targetString.length &amp;&amp; s[start + m] == targetString[m]) { ++m; if (m == targetString.length) { answer++; } } else { if (m == 0) { start++; } else { start += (m - fail[m - 1]); m = fail[m - 1]; } } } return answer;}private static String getTargetString(int n) { StringBuilder sb = new StringBuilder(); sb.append(&quot;I&quot;); while (n-- &gt; 0) { sb.append(&quot;OI&quot;); } return sb.toString();}private static int[] failFunction(char[] target) { int n = target.length; int[] fail = new int[n]; int start = 1; int m = 0; while (start + m &lt; n) { if (target[start + m] == target[m]) { m++; fail[start + m - 1] = m; } else { if (m == 0) { start++; } else { start += (m - fail[m - 1]); m = fail[m - 1]; } } } return fail;} 흐름 KMP 알고리즘 을 이용해 해결 S에서 찾을 문자열(targetString)을 만든다. 찾을 문자열에서 실패함수 값을 구한다. 배열의 범위를 벗어나기 전까지 반복한다. 검색 할 문자열 s에서 찾을 단어을 한 문자씩 비교한다. 한 문자가 같으면, 그 다음 문자를 비교 할 수 있게 m을 1씩 더해서 최종적으로 문자열에 단어가 포함되어 있으면 answer를 증가시킨다. 문자가 일치하지 않으면 m이 0이면 시작도 못해본거니깐 검색 할 문자열에서 한 문자 뒤로 간다.ex) S = ABCDEF 일 경우, B부터 검색하도록 start를 증가 0이 아니면 단어에서 어느정도 일치한 문자열이 존재한 것이므로 비교 시작 할 문자의 index를 m에서 실패함수 값을 빼서 구한다. 일치한 문자열 뒤 부터 검색하면 되므로 m도 실패함수 값에서 구한다. 반복이 끝나면 answer 값을 return 한다. 끝. KMP 알고리즘 해설문자열에서 특정 패턴을 찾아내는 문자열 검색 알고리즘 위키백과 비교한 정보를 최대한 활용 문자열 S = OOIOIIOIOIOIOIOIOIOIOOIOI 에서 패턴 M = IOIOI 를 찾는다고 가정 우선 패턴 M의 실패함수를 구하기 위해 IOIOI에서 접두사와 접미사의 길이가 가장 긴 부분을 구한다. 실패함수1234567891011121314151617181920212223private static int[] failFunction(char[] target) { int n = target.length; int[] fail = new int[n]; int start = 1; int m = 0; while (start + m &lt; n) { if (target[start + m] == target[m]) { m++; fail[start + m - 1] = m; } else { if (m == 0) { start++; } else { start += (m - fail[m - 1]); m = fail[m - 1]; } } } return fail;} IOIOI 패턴에서 index 1에 저장된 ‘O’와 0에 저장된 ‘I’는 같지 않으므로 비교가 시작되는 위치를 1 증가 시킨다. (현재 start = 2, m = 0) 루프에 의해 다시 비교하면 2에 저장된 ‘I’와 0에 저장된 ‘O’는 같으니 m을 증가시키고 접두사와 접미사가 일치한 값인 m를 저장한다. (현재 start = 2, m = 1) IOIOI에서 IOI까지 진행한 상태에서 I와 I가 일치 했으므로 길이 1이 일치한 것 3에 저장된 ‘O’과 1에 저장된 ‘O’가 같으므로, 다시 m을 1 증가 시키고 접두사와 접미사가 일치한 값인 m을 저장한다. (현재 start = 2, m = 2) IOIOI에서 IOIO까지 진행한 상태에서 ‘IO’와 ‘IO’가 같으므로 길이 2가 일치한 것 4에 저장된 ‘I’과 2에 저장된 ‘I’가 같으므로, 다시 m을 1 증가 시키고 접두사와 접미사가 일치한 값인 m을 저장한다. (현재 start = 2, m = 3) IOIOI는 접두사 ‘IOI’와 ‘IOI’의 길이가 3이므로 3 array return 끝 KMP 알고리즘 실패함수 값 구하는 것과 동일하다. 12345678910111213141516171819202122232425262728public static int solution(int n, String target) { int answer = 0; char[] s = target.toCharArray(); char[] targetString = getTargetString(n).toCharArray(); int[] fail = failFunction(targetString); int start = 0; int m = 0; while (start &lt;= s.length - targetString.length) { if (m &lt; targetString.length &amp;&amp; s[start + m] == targetString[m]) { ++m; if (m == targetString.length) { answer++; } } else { if (m == 0) { start++; } else { start += (m - fail[m - 1]); m = fail[m - 1]; } } } return answer;} 실패함수 array [0, 0, 1, 2, 3] m이 패턴의 길이보다 작고, 문자열 s(OOIOIIOIOIOIOIOIOIOIOOIOI) 에서 start+m 한 index의 문자와 비교할 패턴(IOIOI)의 m 번째 문자가 같지 않으므로 s에서 비교가 시작되는 위치를 1 증가 시킨다. (현재 start = 1, m = 0) S의 1와 패턴의 0을 비교해도 여전히 같지 않으므로 시작 위치를 또 증가 시킨다. (start = 2, m = 0) S의 2와 패턴의 0을 비교하면 둘다 ‘I’로 같으므로 m을 증가 시키고 패턴의 길이와 같을 때 까지 반복한다. (start = 2, m = 1) S의 3와 패턴의 1을 비교하면 둘다 ‘O’로 같으므로 m을 증가 시키고 패턴의 길이와 같을 때 까지 반복한다. (start = 2, m = 2) S의 4와 패턴의 2을 비교하면 둘다 ‘I’로 같으므로 m을 증가 시키고 패턴의 길이와 같을 때 까지 반복한다. (start = 2, m = 3) S의 5와 패턴의 3을 비교하면 같지 않고 이제 m이 0이 아니므로, s의 시작 위치를 증가 시켜야 하는데 1을 증가 시키는게 아니라 이전에 구한 실패 함수 값에서 찾아온다. (m(3) - 실패함수 값 array[m(3) - 1]) = 2 즉 현재 시작 위치에서 1을 더한 값이 아닌 2를 더한다. 이미 index 4까지는 접두사 접미사가 2 자리까지 같기 때문에 m 역시 실패함수 값을 가져온다. IOIOI에서 IOIO까지 비교한 값에서 실패했기 떄문에 그 이전 접미사 접두사 길이만큼으로 비교한다. 이 시점에서 start = 4, m = 1이 되고 루프를 반복한다. 4와 1은 같지 않으므로 다시 7번부터 8번까지 반복해서 start와 m을 조정한다. 이 예제로 하면 처음부터 같지 않았으므로 start는 한칸만 뒤로 가고 m 역시 접두사 접미사 1 짜리도 실패했으므로 처음부터 비교한다. (start = 5, m = 0) (5, 0), (6, 1), (7, 2), (8, 3), (9, 4) 이 쭉~ 같으므로 드디어 문자열 s에서 패턴을 찾은 것이므로 answer을 증가 시킨다. 그 이후로 다시 비교하면 m의 길이가 패턴의 길이를 넘어 갔으므로, start와 m의 위치를 다시 조정한다. 반복 끝. 결국 정리하면, 처음 말한 것 처럼 이미 비교한 값은 다시 비교하지 않고 그 다음 부터 비교하는 방식으로 시간을 줄인다. 더 자세한 설명들은 글 마지막 참고 사이트를 찾아가면 다른 분들이 매우 자세하게 설명해주시고 계신다. 결과 테스트 케이스123assertEquals(4, test.solution(1, &quot;OOIOIOIOIIOII&quot;));assertEquals(6, test.solution(2, &quot;OOIOIIOIOIOIOIOIOIOIOOIOI&quot;));assertEquals(7, test.solution(1, &quot;IOIOIOIOIOIOIOI&quot;)); 참고 사이트 https://m.blog.naver.com/tpinlab/10119424299 https://blog.naver.com/PostView.nhn?blogId=kks227&amp;logNo=220917078260&amp;categoryNo=299&amp;parentCategoryNo=0&amp;viewDate=&amp;currentPage=4&amp;postListTopCurrentPage=&amp;from=menu&amp;userTopListOpen=true&amp;userTopListCount=5&amp;userTopListManageOpen=false&amp;userTopListCurrentPage=4 https://baeharam.github.io/posts/algorithm/kmp/ https://vvshinevv.tistory.com/2","link":"/2020/12/02/%EB%B0%B1%EC%A4%80-5525%EB%B2%88-IOIOI/"},{"title":"백준 2869번: 달팽이는 올라가고 싶다","text":"문제https://www.acmicpc.net/problem/2869 코드123456789101112131415161718192021222324252627282930public class 달팽이는_올라가고_싶다 { public static void main(String[] args) throws IOException { String[] input = getInputData(System.in).split(&quot; &quot;); int[] abv = convertStringArrayToIntegerArray(input); System.out.println(solution(abv)); } public static String getInputData(InputStream in) throws IOException { try (BufferedReader br = new BufferedReader(new InputStreamReader(in))) { return br.readLine(); } } private static int[] convertStringArrayToIntegerArray(String[] args) { int[] array = new int[args.length]; int i = 0; for (String str : args) { array[i++] = Integer.parseInt(str); } return array; } public static int solution(int[] abv) { return (abv[2] - abv[1] - 1) / (abv[0] - abv[1]) + 1; }} 흐름 달팽이는 하루에 A 만큼 올라가는데 자면서 B만큼 미끄러지므로 하루에 (A - B) 만큼 씩 올라가서 V미터 만큼 올라가면 된다. 하지만 꼭대기에 도달하면 미끄러지지 않는다고 하였으므로, 꼭대기(V) 에서 미끄러지는 만큼(B) 을 뺀 거리만큼만 올라가면 된다. (V - B) 그럼 수식은 (V - B) / (A / B)가 되고 int형은 소수점을 없애므로 나누어떨어지지 않으면 + 1을 하는데 (V - B)에서 - 1을 먼저하고 무조건 1을 더한다. (V - B - 1) / (A - B) + 1 V-B를 X, A-B를 y로 가정 x/y가 나누어 떨어지는 경우 x / y = d 일 때 (x-1)/y 는 반드시 d보다 작다. int형은 소수점 아래를 없애므로 x-1 /y = d - 1이 되고, +1을 하면 d가 된다. x/y가 나누어 떨어지지 않는 경우 x / y = d + f 일 때 y를 양변에 곱하면 x = y(d + f) 여기서 양변에 1을 빼면, x - 1 = y(d + f) - 1 여기서 y를 양변에 나누면 (x - 1) / y = (d + f) -1 / y 이 된다. 이 때 1 / y 는 y &gt;= 2 이고 int형은 소수점 아래를 없애버리므로 1 / y 는 없어진다. y &gt;= 2 인 이유는 현재 x / y가 나누어 떨어지지 않는 경우임을 상정하고 있으므로 y가 1이면 나누어 떨어지기 때문에 y는 2보다 크게 된다. 그럼 (x - 1) / y = d + f 이 되고 +1을 하면, (x - 1) / y + 1 = d + f + 1 된다. 결과 테스트 케이스1234567assertEquals(4, test.solution(new int[] {2,1,5}));assertEquals(2, test.solution(new int[] {5,1,6}));assertEquals(999999901, test.solution(new int[] {100,99,1000000000}));assertEquals(1, test.solution(new int[] {5,0,5}));assertEquals(4, test.solution(new int[] {3,2,6}));assertEquals(2, test.solution(new int[] {100,1,101}));assertEquals(3, test.solution(new int[] {3,1,6})); 참고 사이트 https://hyunah030.tistory.com/8","link":"/2020/08/20/%EB%B0%B1%EC%A4%80-%EB%8B%AC%ED%8C%BD%EC%9D%B4%EB%8A%94-%EC%98%AC%EB%9D%BC%EA%B0%80%EA%B3%A0-%EC%8B%B6%EB%8B%A4/"},{"title":"프로그래머스: 자연수 뒤집어 배열로 만들기","text":"https://programmers.co.kr/learn/courses/30/lessons/12932 소스123456789public int[] solution(long n) { List&lt;Long&gt; list = new ArrayList&lt;Long&gt;(); while (n &gt; 0) { list.add(n % 10); n /= 10; } return list.stream().mapToInt(i -&gt; (int) (long) i).toArray();} 흐름 n은 10,000,000,000이하인 자연수이므로 몇 자리의 수가 올지 알 수 없으므로 배열이 아닌 ArrayList를 생성 n mode 10한 값을 저장하고 n을 10 나눔 ex) 12345 mod 10 = 5, 12345 / 10 = 1234 List를 stream()을 활용하여 int array로 변경함 다른 풀이12345678910public int[] solution(long n) { int[] arrays = new int[String.valueOf(n).length()]; int i = 0; while (n &gt; 0) { arrays[i++] = (int) (n % 10); n /= 10; } return arrays;} n이 몇 자리의 수가 올지 알 수 없으므로 n을 String으로 변환 후 String의 length를 구해서 array의 크기를 구함 이하 상동 시간 비교첫 번째 풀이 번호 속도 테스트 1 통과 (5.56ms, 50.8MB) 테스트 2 통과 (5.78ms, 50.2MB) 테스트 3 통과 (5.51ms, 50.9MB) 테스트 4 통과 (4.88ms, 52.9MB) 테스트 5 통과 (6.73ms, 52.3MB) 테스트 6 통과 (5.79ms, 52.6MB) 테스트 7 통과 (6.36ms, 50.7MB) 테스트 8 통과 (5.06ms, 50.7MB) 테스트 9 통과 (5.75ms, 52.5MB) 테스트 10 통과 (4.99ms, 50.6MB) 테스트 11 통과 (5.25ms, 52.7MB) 테스트 12 통과 (5.65ms, 52.4MB) 테스트 13 통과 (5.75ms, 55MB) 두 번째 풀이 번호 속도 테스트 1 통과 (1.34ms, 52.5MB) 테스트 2 통과 (1.57ms, 49.9MB) 테스트 3 통과 (1.52ms, 50.3MB) 테스트 4 통과 (1.36ms, 53.1MB) 테스트 5 통과 (1.52ms, 52.3MB) 테스트 6 통과 (1.42ms, 52.4MB) 테스트 7 통과 (1.52ms, 50.4MB) 테스트 8 통과 (1.43ms, 50.4MB) 테스트 9 통과 (1.37ms, 52.2MB) 테스트 10 통과 (1.50ms, 50.2MB) 테스트 11 통과 (1.42ms, 49.9MB) 테스트 12 통과 (1.72ms, 52.2MB) 테스트 13 통과 (1.73ms, 50.7MB) Stream()이 생각보다 더 느리게 동작하는 듯 싶다.","link":"/2020/04/02/%EC%9E%90%EC%97%B0%EC%88%98-%EB%92%A4%EC%A7%91%EC%96%B4-%EB%B0%B0%EC%97%B4%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"title":"프로그래머스: 스킬트리","text":"https://programmers.co.kr/learn/courses/30/lessons/49993?language=java 소스1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public int solution(String skill, String[] skill_trees) { char[] ch = skill.toCharArray(); List&lt;ArrayList&lt;Skill&gt;&gt; l = new ArrayList&lt;ArrayList&lt;Skill&gt;&gt;(); for (String element : skill_trees) { ArrayList&lt;Skill&gt; list = new ArrayList&lt;Skill&gt;(); for (int i = 0; i &lt; ch.length; i++) { Skill s = new Skill(); s.skill = ch[i]; s.index = element.indexOf(ch[i]); if (s.index != -1) { list.add(s); } } l.add(list); } int answer = 0; for (ArrayList&lt;Skill&gt; list : l) { Collections.sort(list, new Comparator&lt;Skill&gt;() { @Override public int compare(Skill o1, Skill o2) { return o1.getIndex().compareTo(o2.getIndex()); } }); StringBuilder sb = new StringBuilder(); for (Skill s : list) { sb.append(s.getSkill()); } if (skill.startsWith(sb.toString())) { answer++; } } return answer;}public class Skill { private int index; private char skill; public Integer getIndex() { return index; } public void setIndex(int index) { this.index = index; } public char getSkill() { return skill; } public void setSkill(char skill) { this.skill = skill; }} 흐름 스킬트리에 있는 스킬들을 선행스킬 만큼 반복한다. 돌면서 스킬들에서 선행스킬의 index와 선행스킬명을 저장하는 클래스(Skill)에 저장하고 그 클래스를 List에 저장한다. ex) List = [{index = 1, skill = A}, {index = 7, skill = Q}, …] 선행스킬명을 저장한 List를 다른 List(AllSkillList)에 저장한다. 전체 스킬을 저장해야 하므로 ex) AllSkillList = [List1, List2, List3, …] 전체 스킬이 저장된 List(AllSkillList)를 돌면서 저장된 List의 Skill의 Index 순으로 정렬 시킨다. 정렬된 List를 돌면서 StringBuilder에 스킬명을 담는다. 입력받은 선행스킬과 비교하여 일치하면 answer을 증가 시킨다. 끝 다른 분의 소스12345678910111213public int solution(String skill, String[] skill_trees) { int answer = 0; ArrayList&lt;String&gt; skillTrees = new ArrayList&lt;String&gt;(Arrays.asList(skill_trees)); Iterator&lt;String&gt; it = skillTrees.iterator(); while (it.hasNext()) { if (skill.indexOf(it.next().replaceAll(&quot;[^&quot; + skill + &quot;]&quot;, &quot;&quot;)) != 0) { it.remove(); } } answer = skillTrees.size(); return answer;} 로직 스킬트리에 있는 스킬들 중 선행스킬이 아닌 녀석들을 없애버리고 선행스킬과 일치하는 지 확인해서 일치하지 않으면 List에서 삭제하고 List의 갯수를 return 하는 것으로 끝을 낸다. ex) “CBD” 인 경우 “BACDE”에서 “C”, “B”, “D”가 아닌 녀석들은 삭제되서 “BCD”가 남지만 “CBD”.indexOf(“BCD”) 할 경우 “CBD”에 “BCD”가 존재 하지 않으므로 1을 return 하고 -1은 0이 아니므로 List에서 삭제된다. “BDA” 인 경우엔 “CBD”.indexOf(“BD”) 할 경우 “CBD”에 존재하지만 1 번째 index에 존재하므로 1을 return 하고 List에서 삭제된다. 직관적이고 가독성이 좋다. 정규표현식 활용도 굿 결과1 번 번호 속도 테스트 1 통과 (1.40ms, 52.1MB) 테스트 2 통과 (1.37ms, 50.1MB) 테스트 3 통과 (1.29ms, 52.7MB) 테스트 4 통과 (1.11ms, 52.3MB) 테스트 5 통과 (1.42ms, 50.6MB) 테스트 6 통과 (1.33ms, 52.4MB) 테스트 7 통과 (1.38ms, 50.5MB) 테스트 8 통과 (1.38ms, 50.8MB) 테스트 9 통과 (1.46ms, 52MB) 테스트 10 통과 (1.26ms, 52.4MB) 테스트 11 통과 (1.36ms, 54.3MB) 테스트 12 통과 (1.72ms, 52.5MB) 테스트 13 통과 (1.27ms, 52.3MB) 테스트 14 통과 (1.31ms, 52.2MB) 2 번 번호 속도 테스트 1 통과 (17.73ms, 54.5MB) 테스트 2 통과 (18.75ms, 52.2MB) 테스트 3 통과 (17.83ms, 52.4MB) 테스트 4 통과 (19.98ms, 54.3MB) 테스트 5 통과 (20.10ms, 52.3MB) 테스트 6 통과 (20.89ms, 52.5MB) 테스트 7 통과 (20.94ms, 54.3MB) 테스트 8 통과 (18.68ms, 52.2MB) 테스트 9 통과 (19.60ms, 52.8MB) 테스트 10 통과 (20.75ms, 54.4MB) 테스트 11 통과 (18.02ms, 52.3MB) 테스트 12 통과 (18.70ms, 54.3MB) 테스트 13 통과 (18.79ms, 52.5MB) 테스트 14 통과 (19.85ms, 54.8MB) 2 번의 경우 Arrays.asList(skill_trees) 와 replace 때문에 속도가 살짝 느려진 것으로 판단된다. 테스트 케이스123456assertEquals(3, test.solution(&quot;CBD&quot;, new String[] {&quot;BACDE&quot;, &quot;CBADF&quot;, &quot;AECB&quot;, &quot;BDA&quot;, &quot;ASF&quot;, &quot;BDF&quot;,&quot;CEFD&quot;}));assertEquals(4, test.solution(&quot;C&quot;, new String[] {&quot;BACDE&quot;, &quot;CBADF&quot;, &quot;AECB&quot;, &quot;BDA&quot;}));assertEquals(2, test.solution(&quot;CBD&quot;, new String[] {&quot;C&quot;, &quot;D&quot;, &quot;CB&quot;, &quot;BDA&quot;}));assertEquals(2, test.solution(&quot;AC&quot;, new String[] {&quot;ABC&quot;, &quot;CA&quot;, &quot;ATEW&quot;, &quot;SFCQTA&quot;}));assertEquals(2, test.solution(&quot;ACHQ&quot;, new String[] {&quot;TWER&quot;, &quot;FGCHQEA&quot;, &quot;ATEW&quot;, &quot;SFCQTA&quot;}));assertEquals(4, test.solution(&quot;CBDK&quot;, new String[] {&quot;CB&quot;, &quot;CXYB&quot;, &quot;BD&quot;, &quot;AECD&quot;, &quot;ABC&quot;, &quot;AEX&quot;, &quot;CDB&quot;, &quot;CBKD&quot;, &quot;IJCB&quot;, &quot;LMDK&quot;})); 임의로 만든 테스트 케이스 이므로 위 테스트 케이스를 통과해도 시험에서 통과하지 못할 가능성이 있다.","link":"/2020/04/21/%EC%8A%A4%ED%82%AC%ED%8A%B8%EB%A6%AC/"},{"title":"프로그래머스: 최대공약수와 최소공배수","text":"https://programmers.co.kr/learn/courses/30/lessons/12940 소스123456789101112public int[] solution(int n, int m) { int big = n &gt; m ? n : m; int small = n &lt; m ? n : m; while (m != 0) { int r = n % m; n = m; m = r; } return new int[] {n, n * (big / n) * (small / n)};} 흐름 유클리드 호제법으로 처리 두 양의 정수 $$ a, b (a &gt; b) $$ 에 대하여 $$ a = bq + r(0 ≤ r &lt; a) $$라 하면, a, b 의 최대공약수는 b, r의 최대공약수와 같다. 두 수를 중 큰 수와 작은 수 구분 큰 수 a의 최대공약수는 b와 r(a mod b)의 최대 공약수와 같으므로 작은 수 m이 0이 될 때 까지 반복 최소공배수는 최대공약수(G) * (a / G) * (m / G) 이므로 계산해서 배열에 할당한다. $$ (a * b) / G $$ 로 하면 수가 큰 경우 overflow가 발생 할 가능성이 있음. 끝 유클리드 호제법 두 양의 정수 $$ A, B (A &gt; B) $$ 에 대하여 $$ A = Bq + R(0 ≤ R &lt; a) $$라 하면, A, B 의 최대공약수는 B, R의 최대공약수와 같다. 이 때 R은 A mod B 한 값으로 식으로 나타내면 아래와 같다. $$ G(A,B) = G(B,R) $$ A와 B에게 최대공약수 G가 있다면, $$ A = aG, B = bG $$ 과 같이 나타 낼수 있고 이 때 a와 b는 반드시 서로소 여야 한다.위에서 A mod B 한 값이 R 이라고 정의했고 A와 B를 나눈 값을 q라고 한다면, $$ A = Bq + R $$$$ aG = bGq + R $$$$ R = G(a-bq) $$ 처럼 전개 될 수 있고, 이 경우 R과 B가 G 라는 최대 공약수를 갖기 떄문에 $$ a-bq $$ 와 b가 서로소 임을 증명하면 된다. 만약 $$ a-bq $$ 와 b가 서로소가 아니라면, 둘은 공약수가 존재 하기 떄문에 아래와 같이 표현 할 수 있다. $$ a-bq = pm , b = pn $$$$ a = bq + pm $$$$ a = pnq + pm $$$$ a = p(nq + m), b = pn $$ 이 때 a와 b는 서로소인데 p 라는 공약수를 갖게 되므로a와 b가 서로소라는 전제가 모순되어 $$ a-bq $$ 와 b는 서로소임이 증명되고 B와 R의 최대 공약수가 G 인 것이 된다. 참고 사이트 https://sexycoder.tistory.com/65 https://blog.naver.com/PostView.nhn?blogId=papers&amp;logNo=140207307545&amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F https://namu.wiki/w/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C%20%ED%98%B8%EC%A0%9C%EB%B2%95","link":"/2020/04/06/%EC%B5%9C%EC%86%8C%EA%B3%B5%EC%95%BD%EC%88%98%EC%99%80-%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98/"},{"title":"토비의 스프링 reading (4)","text":"스프링의 정의자바 엔터프라이즈 개발을 편하게 해주는 오플ㄴ소스 경량급 애플리케이션 프레임워크 이일민토비의 스프링 애플리케이션 프레임워크 특정 계층이나, 기술, 업무 분야에 국한되지 않고 애플케이션의 전 영역을 포괄하는 범용적인 프레임워크 애플리케이션 개발의 전 과정을 빠르고 편리하며 효율적으로 진행하는데 목표를 두는 프레임워크 단지 여러 계층의 다향한 기술을 한데 모아뒀기 때문에 그렇게 불리는 게 아님 스프링의 일차적인 존재 목적은 핵심 기술에 담긴 프로그래밍 모델을 일관되게 적용해서 엔터프라이즈 애플리케이션 전 계층과 전 여영ㄱ에 전략과 기능을 제공해줌으로써 애플리케이션을 편리하게 개발하게 해주는 애플리케이션 프레임워크로 사용되는 것 경량급 자체가 가렵다거나 작은 규모의 코드로 이뤄졌다는 뜻이 아님 불필요하게 무겁지 않다는 의미 EJB에 비해 단순한 개발툴과 기본적인 개발환경으로도 엔터프라이즈 개발에서 필요로 하는 주요한 기능을 갖춘 애프리케이션을 개발하기 충분 자바 엔터프라이즈 개발을 편하게 개발자가 복잡하고 실수하기 쉬운 로우레벨 기술에 많은 신경을 쓰지 않게함 애플리케이션의 핵심인 사용자의 요구사항, 즉 비즈니스 로직을 빠르고 효과적으로 구현하는 것 스프링이 제공하는 기술이 아니라 자신이 작성하는 애플리케이션의 로직에 더 많은 관심과 시간을 투자하게 함 초기에 기본 설정과 적용 기술만 선택하고 준비해두면 이후에 개발자가 신경 쓸 일이 없음 결국 스프링의 목적은 스프링을 할용해서 엔터프라이즈 애플리케이션 개발을 편하게 하는 것그렇다면 스프링은 어떻게 복잡한 엔터프라이즈 개발을 편하게 해주는가? 복잡함의 근본적인 이유 기술적인 제약조건과 요구사항이 늘어남 애플리케이션이 구현해야 할 핵심기능인 비즈니스 로직의 복잡함이 증가함 자바 엔터프라이즈 시스템 개발이 어려운 가증 큰 이유는 근본적인 비즈니스 로직과 엔터프라이즈 기술이라는 두 가지 복잡함이 한데 얽혀 있기 때문 해결책 기술의 적용 사실이 코드에 직접 반영되지 않는 비침투적 기술 사용 어딘가에는 기술의 적요에 따라 필요한 작업을 해줘야하겠지만, 애플리케이션 코드 여기저기에 불쑥 등장하거나, 코드의 설꼐와 구현 방식을 제한하지 않는다는 게 비침투적인 기술의 특징 반대로 침투적인 기술은 어떤 기술을 적용했을 떄 그 기술과 관련된 코드나 규약 등이 코드에 등장하는 경우 즉 스프링의 기본적인 전량근 비즈니스 로직을 담은 애플리케이션 코드와 엔터프라이즈 기술을 처리하는 코드를 분리시키는 것 기술적 복잡함을 상대하는 전략서비스 추상화 일관성 없는 기술과 서버환경의 변화에 대한 스프링의 공략 방법은 서비스 추상화 추상화를 통해 로우레벨의 기술 구현 부분과 기술을 사용하는 인터페이스를 분리하고, 환경과 세부기술에 독립적인 접근 인터페이스를 제공하는 것이 가장 좋은 해결책 AOP 비즈니스 로직 전후로 경계가 설정돼야하는 트랜잭션 비즈니스 로직에 대한 보안 적용 계층 사이에 주고받는 데이터와 예외의 일괄 변환이나 로징이나 감사 기능 등 이런 기술과 비즈니스 로직의 혼재로 발생하는 복잡함을 해결하기 위한 스프링의 접근 방법이 AOP 비즈니스와 애플리케이션 로직의 복잡함을 상대하는 전략객체지향과 DI 기술적인 복잡함을 효과적으로 다루게 해주는 기법은 모두 DI를 바탕으로 함 서비스 추상화, 템플릿/콜백, AOP 등 그리고 DI는 객체지향 프로그래밍 기법일 뿐 DI를 적용해서 오브젝트를 분리하고, 인터페이스를 동비하고, DI로 관계를 연결 결국 DI는 좋은 오브젝트 설계의 결과물이기도 하지만, 반대로 DI를 적용하다보면 객체지향 설계의 원칙을 잘 따르고 그 장점을 살린 설계가 나올 수 있음 결국 스프링의 기술과 전략은 객체지향이라는 자바 언어가 가진 강력한 도구를 극대화해서 사용할 수 있도록 돕는 것 이고 스프링은 단지 거들 뿐이다.","link":"/2020/05/20/%ED%86%A0%EB%B9%84%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%81-reading-4/"},{"title":"토비의 스프링 reading (2)","text":"팩토리 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 오브젝트 디자인 패턴의 추상 팩토리 패턴이나 팩토리 메서드 패턴과는 다름 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 분리하려는 목적으로 사용하는 것 애플리케이션의 컴포넌트 역할을 하는 오브젝트와 애플리케이션의 구조를 결정하는 오브젝트를 분리한다는 데 의미가 있음 제어관계 역전 일반적인 프로그램의 흐름은 프로그램의 시작지점(main method 등)에서 다음에 사용할 오브젝트 결정 결정한 오브젝트 생성 만들어진 오브젝트에 있는 메서드를 호출 메서드 안에서 다음에 사용할 것을 결정하고 호출 이는 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정 언제 어떻게 그 오브젝트를 만들지를 스스로 관장 모든 종류의 작업을 사용하는 쪽에서 제어하는 구조 제어의 역전(Ioc)이란 이런 제어 흐름의 개념을 거꾸로 뒤집는 것 스프링 Ioc ApplicationContext 왜 사용? 범용적이고 유연한 방법으로 Ioc 기능을 확장하기 위해 애플리케이션이 고도화되면 Ioc를 적용한 오브젝트도 계속 추가 될텐데 매번 어떤 팩토리 클래스를 사용해야 하는 지 알아야하고 필요할 때마다 팩토리 오브젝트를 생성해야하는 번거로움이 있음applicationContext는 알거나 직접 사용할 필요가 없고 일관된 방식으로 원하는 오브젝트를 가져올 수 있음 생성, 관계설정만 하는 것이 아닌 만들어지는 방식, 시점, 전략, 부가적으로 자동생성, 오브젝트에 대한 후 처리 등 효과적으로 활용할 수 있는 다양한 기능을 제공 bean을 검색하는 다양한 방법을 제공 스프링 Ioc 용어 정리빈(bean) 스프링이 Ioc 방식으로 직접 그 생성과 제어를 담당하는 오브젝트 빈 팩토리(bean factory) 스프링의 Ioc를 담당하는 핵심 컨테이너 빈을 등록, 생성, 조회하고 돌려주고 부가적인 빈을 관리하는 기능을 담당 보통 applicationContext를 사용 애플리케이션 컨텍스트(application context) 빈 팩토리를 확장한 Ioc 컨테이너 빈 팩토리에 스프링이 제공하는 각종 부가 서비스를 추가로 제공한 것 스프링이 싱글톤으로 빈을 생성하는 이유 매번 클라이언트에서 요청이 올 때 마다 각 로직을 담당하는 오브젝트를 새로 만들어서 사용한다면 서버가 부하를 감당하기 어려움 그래서 제한된 수(보통 한 개)의 오브젝트만 만들어서 사용하도록 싱클톤을 사용 Java 싱글톤 패턴의 한계 private 생성자를 갖고 있기 때문에 상속 할 수 없음 초기화 과정에서 생성자 등을 통해 사용할 오브젝트를 다이나믹하게 주입하기도 힘들기 때문에 필요한 오브젝트는 직접 오브젝트를 만들어서 사용 할 수 밖에 없어 테스트가 힘듬 서버에서 클래스 로더를 어떻게 구성하고 있느냐에 따라 싱글톤 클래스여도 하나 이상의 오브젝트가 만들어질 수 있음 싱글톤의 static 메서드를 이용해 전역 상태로 사용되기 쉬우므로, 아무 객체나 자유롭게 접근하고 수정하고 공유할 수 잇는 전역 상태를 갖는 것은 객체지향 프로그래밍에서 권장되지 않음 싱글톤 레지스트리 스프링에서 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능 싱글톤 레지스트리의 장점 오브젝트 생성에 대한 모든 권한은 Application Context에 있기 때문에 static 메서드와 private 생성자를 사용하는 것이 아닌 평범한 자바 클래스를 싱글톤으로 활용하게 해줌 스프링이 빈을 싱글토으로 만드는 것은 결국 오브젝트의 생성 방법을 제어하는 Ioc 컨테이너로서의 역할 오브젝트의 상태 멀티스레드 환경이라면 여러 스레드가 동시에 싱글톤에 접근해서 사용할 수 있으므로 상태 관리에 주의해야 함 기본적으로 상태정보를 내부에 갖고 있지 않는 무상태 방식으로 생성되어야 함 서로 값을 덮어쓰고자신이 저장하지 않은 값을 읽어올 수 있기 때문에 기본적으로 인스턴스 필드의 값을변경하고 유지하는 상태유지 방식으로 만들지 않음 상태가 없는 방식으로 만드는 경우 생성한 정보는 파라미터와 지역변수, 리턴 값으로 이용함 파라미터나 지역변수는 매번 새로운 값을 저장할 독립적인 공간이 만들어지기 때문에 싱글톤이라고 해도 여러 스레드가 변수의 값을 덮어 쓸일이 없음 읽기전용 정보인 자신이 사용하는 다른 싱글톤 빈을 저장하려는 용도라면 인스턴스 변수를 사용해도 무방함 의존관계 A -&gt; B 이면 B가 변하면 그것이 A에도 영향을 미친다는 것 어린 자식은 부모에 의존적이므로 부모가 변하면 자식도 변하게 됨 의존관계에는 방향성이 있음 (자식 -&gt; 부모) 자바에서는 Interface를 통해 의존관계를 줄일 수 있음, 이것이 낮은 결합도 모델이나 코드에서 클래스와 인터페이스를 통해 드러나는 의존관계말고 런타임 시에 오브젝트 사이에서 만들어지는 의존관계도 있음 런타임 의존관계 혹은 오브젝트 의존관계라고 함 의존 오브젝트 프로그램이 시작되고 오브젝트가 만들어지고 런타임 시에 의존관계를 맺는 대상, 즉 실제 사용대상인 오브젝트 의존관계 주입 구체적인 의존 오브젝트와 그것을 사용할 주체, 보통 클라이언트라고 부르는 오브젝트를 런타임 시에 연결해주는 작업 클래스 모델이나 코드에는 런타임 시점에 의존관계가 드러나지 않으므로 인터페이스에만 의존하고 있어야 함 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어짐 핵심은 설계 시점에는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제 3의 존재가 있다는 것 application context 빈 팩토리 Ioc 컨테이너 등 의존관계 검색 외부로부터의 주입이 아니라, 스스로 검색 런타임 시 의존관계를 맺을 오브젝트를 검색하는 것과 오브젝트의 생성 작업은 외부 컨테이너에게 Ioc로 맡기지만, 이를 가져올 떄는 메서드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법을 사용 미리 준비된 메서드를 호출하면 되니 단순히 요청으로 보이겠지만, 이런 작업을 일반화한 스프링의 application context라면 미리 정해놓은 일므을 전달해서 그 이림에 해당하는 오브젝트를 찾게 됨. getBean() 의존관계 검색 방식에서는 검색하는 오브젝트는 자신이 스프링의 빈일 필요가 없음 반면 의존관계를 주입하기 위해선 생성과 초기화 권한을 갖고 있어야하고, 그러려면 Ioc 방식으로 컨테이너에서 생성되는 오브젝트, 즉 빈이어야 하기 때문 DI를 원하는 오브젝트는 먼저 자기 자신이 컨테이너가 관리하는 빈이 돼야 한다는 사실을 잊지 말자. 의존관계 주입의 장점 코드에는 런타임 클래스에 대한 의존관계가 나타나지 않음 인터페이스를 통해 결합도가 낮은 코드가 되므로 의존관계에 있는 대상이 바뀌거나 변경되더라도 자신이 영향 받지 않음 변경을 통한 다양한 확장에는 자유로움 1장 마무리 스프링이란, 어떻게 오브젝트가 설계되고, 만들어지고, 어떻게 관계를 맺고 사용되는 지에 관심을 갖는 프레임워크","link":"/2020/04/22/%ED%86%A0%EB%B9%84%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%81-reading-2/"},{"title":"토비의 스프링 reading (3)","text":"AOP란 AOP는 Ioc, DI, 서비스 추상화와 더불어 스프링의 3대 기반 기술 선언적 트랜잭션 기능이 대표적 트랜잭션 코드의 분리 비즈니스 로직 전 후에 로직과 전혀 상관없는 트랜잭션 경계를 설정해야 하기 때문에 필연적으로 코드가 지저분해짐 메서드 분리를 이용해 분리 비즈니스 로직을 담당하는 코드만 따로 메서드로 추출 하지만 여전히 비즈니스 로직이 아닌 보일 필요가 없는 트랜잭션 코드가 남아있음 그렇다면 클래스에서 빼서 아예 눈에 안띄게 해버리자 DI를 이용한 클래스의 분리 DI의 기본 아이디어는 실제 사용할 오브젝트의 클래스 정체는 감춘 채 인터페이스를 통해 간접으로 접근하는 것 그 덕분에 구현 클래스는 얼마든지 외부에서 변경 가능 UserService 인터페이스를 상속 받는 클래스를 2 가지로 나눔 ServiceImpl(비즈니스 담당) ServiceTx(트랜잭션 담당) Impl에선 비즈니스 로직을 담당하는 메서드만 남겨두고 Tx에선 userService를 구현한 다른 오브젝트를 주입 받고 트랜잭션 안에서 동작할 수 있도록 메서드 안에서 트랜잭션 경계를 설정 1234567public void upgardeLevels() { 트랜잭션 스타트(); 주입받은 userService를 구현한 오브젝트(Impl).upgrardeLevels(); commit() or rollback();} DI를 이용한 트랜잭션 경계설정 코드 분리의 장점 비즈니스 로직만 담긴 Impl 클래스에선 코드을 작성 시 트랜잭션 같은 비즈니스 로직과 관계 없는 부분에 대해 전혀 신경 쓰지 않아도 됌 테스트가 쉬워짐 다시 돌아와 AOP: 애스펙트(aspect) 지향 프로그래밍 부가기능 모듈화 작업 핵심기능에 부가되어 의미를 갖는 특별한 모듈 에스펙트는 부가될 기능을 정의한 코드인 어드바이스, 어드바이스를 어디에 적용할지를 결정하는 __포인터컷__을 함께 갖고 있음 위에서 트랜잭션 코드는 비즈니스 로직에 상관없는 기능인데 핵심기능에 침투해 들어가면서 설계와 코드가 모두 지저분해짐 이런 부가기능 코든는 여기저기 메서드에 마구 흩어져서 나타나고 코드는 중복됌 런타임 시에는 각 부가기능 에스펙트는 자기가 필요한 위치에 다이내믹하게 참여 하지만 설계와 개발은 다른 특성을 띤 에스펙트들을 독립적인 관점으로 작성 AOP는 에스펙트를 분리함으로써 핵심기능을 설계하고 구현할 때 객체지향적인 가치를 지킬 수 있도록 도와주는 것 애플리케이션을 특정한 관점을 기준으로 바라볼 수 있게 해준다는 의미에서 관점 지향 프로그래밍이라고도 함 프록시를 이용한 AOP 스프링은 다양한 기술을 조합해 AOP를 지원하는데 가장 핵심은 프록시를 이용한다는 것 프록시로 만들어서 DI로 연결된 빈 사이에 적용해 타깃의 메서드를 호출 과정에 참여 해서 부가기능을 제공 스프링 AOP의 부가기능을 담은 어드바이스가 적용되는 대상은 오브젝트의 메서드 바이트코드 생성과 조작을 통한 AOP AspectJ는 컴파일된 타깃의 클래스 파일 자체를 수정하거나 JVM에 로딩되는 시점을 가로채서 바이트코드를 조작하는 방식을 사용 이 때 장점은, DI 컨테이너의 도움을 받아서 자동 프록시 생성방식을 사용하지 않아도 AOP 적용 가능하기 때문에 컨테이너가 없는 환경에서도 AOP의 적용 가능 프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능, 프록시는 부가기능을 부여할 대상은 클라이언트가 호출 할 떄 사용하는 메서드로 제한되지만, 바이트코드를 직접 조작하기 떄문에 오브젝트의 생성, 필드 값으 조회와 조작, static 초기화등의 다양한 작업에 부가기능 부여 가능 AOP 용어 정리 타깃 부가기능을 부여할 대상 어드바이스 타깃에게 제공할 부가기능을 담을 모듈 조인 포인트 어드바이스가 적용될 수 잇는 위치 스프링 AOP의 조인 포인트는 메서드의 실행단계 타깃 오브젝트가 구현한 인터페이스의 모든 메서드는 조인 포인트가 됌 포인트컷 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈 메서드의 시그니처를 비교하는 방법을 주로 사용 프록시 클라이언트와 타깃 사이에 투명하게 존재하면서 부가기능을 제공하는 오브젝트 어드바이저 포인트컷과 어드바이스를 하나씩 갖고 있는 오브젝트 어떤 부가기능(어드바이스)를 어디에(포인트 컷) 전달할 것인가를 알고 있는 AOP의 가장 기본이 되는 모듈 애스펙트 AOP의 기본 모듈 한 개 또는 그 이상의 포인트 컷과 어드바이스를 조합 보통 싱글톤 형태의 오브젝트","link":"/2020/05/13/%ED%86%A0%EB%B9%84%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%81-reading-3/"},{"title":"토비의 스프링 reading (5)","text":"스프링의 정수는 엔터프라이즈 서비스 기능을 POJO에 제공하는 것 Professional SPring FrameworkRod Johnson 외 4명 스프링의 주요 기술인 Ioc/DI, AOP와 PSA(Portable Service Abstraction)는 애플리케이션을 POJO로 개발할 수 있게 해주는 가능 기술이라고 불린다 POJO란 Plain Old Java Object의 약자 직역하면 평범한 오래된 자바 객체다 POJO의 조건 특정 규약에 종속되지 않는다. 객체지향 설계의 자유로운 적용이 가능한 오브젝트여야만 POJO라고 불릴 수 있다. 특정 환경에 종속되지 않는다 환경에 독립적이어야 한다. 특히 비즈니스 로직을 담고 있는 POJO 클래스는 웹이라는 환경정보나 웹 기술을 담고 있는 클래스나 인터페이스를 사용해서는 안된다. 설령 나중에 웹 컨트롤러와 연결돼서 사용될 것이 뻔하도 할지라도 비즈니스 로직을 담은 코드에 HttpServletRequest나 HttpSession, 캐시와 관련된 API가 등장하거나 웹 프레임워ㅏ크의 클래스를 직접 이용하는 부분이 있다면 그것은 진정한 POJO라고 볼 수 없다. 진정한 POJO란 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트를 말한다 POJO의 장점 특정한 기술과 환겨엥 종속디지 않는 오브젝트는 그만큼 깔끔한 코드가 될 수 있다. POJO로 개발된 코드는 자동화된 테스트에 매우 유리하다. 객체지향적인 설계를 자유롭게 적용할 수 있다. POJO 프레임워크 POJO 프로그래밍이 가능하도록 기술적인 기반을 제공하는 프레임워크 스프링 프레임워크와 하이버네이트 등 POJO를 가능하게 하는 스프링의 기술 Ioc/DI AOP PSA 제어의 역전(Ioc) / 의존관계 주입(DI) 왜 두개의 오브젝트를 분리해서 만들고, 인터페이스를 두고 느슨하게 연결한 뒤, 실제 사용할 대상은 DI를 통해 외부에서 지정하는 걸까? 이렇게 DI 방식으로 하는 것이 직접 사용할 오브젝트를 new 키워드로 생성해서 사용하는 강한 결합을 쓰는 방법보다 나은 점은 무엇일까? = 유연한 확장이 가능하게 하기 위해 A-&gt;B라는 의존관계가 있을 떄 확장은 B가 자유롭게 변경될 수 있음을 의미 이는 B가 변경되어도 A는 아무 영향이 없고 그대로 유지 가능B 관점에선 유연한 확장이고, A 관점에서는 변경 없이 재사용이 가능함 개방 폐쇄 원칙(OCP)라는 객체지향 설계 원칙으로 설명할 수 있음 애스펙트 지향 프로그래밍(AOP) 객체지향 기술만으로는 애플리케이션의 요구조건과 기술적인 난해함을 모두 해결하는데 한계가 있음 이를 도와주는 보조적인 프로그래밍 기술이 AOP 스프링의 AOP는 스프링이 POJO 프로그래밍을 지원하려는 그 핵심 목적을 위해 중요한 역할을 하고 있음 포터블 서비스 추상화(PSA) POJO로 개발된 코드는 특정 환경이나 구현 방식에 종속적이지 않아야 함 환경과 세부 기술의 변화에 관계없이 일관된 방식으로 기술에 접근 할 수 있게 해주는게 PSA 단순히 구체적인 기술에 종속되지 않게 하기 위해서 말고 테스트가 어렵게 만들어진 API나 설정을 통해 주요 기느을 외부에서 제어하게 만들고 싶을 때도 이용할 수 있음","link":"/2020/05/22/%ED%86%A0%EB%B9%84%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%81-reading-5/"},{"title":"토비의 스프링 reading (1)","text":"관심사 분리 관심이 같은 것 끼리는 하나의 객체 안으로 또는 친한 객체로 모이게하고,관심이 다른 것은 가능한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것 템플릿 메서드 패턴 슈퍼클래스에 기본적인 로직의 흐름을 만들고,그 기능의 일부를 추상 메서드나 오버라이딩 가능한 protected 메서드 등으로 만든 뒤 서브클래스에서 이런 메서드를 필요에 맞게 구현해서 사용하도록 하는 방법 팩토리 메서드 패턴 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것 중요한 건 디자인 패턴이 아닌 상속구조를 통해 성격이 다른 관심사항을분리한 코드를 만들어내고, 서로 영향을 덜 주도록 했는지를 이해하는 것 상속을 통한 확장의 문제점 만약 다른 목적을 위해 이미 상속을 사용하고 있다면? 상속을 통한 상하위 클래스의 관계는 생각보다 밀접 서브클래스는 슈퍼클래스의 기능을 직접 사용할 수 있음그래서 슈퍼클래스 내부의 변경이 있을 때 모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도 있음반대로 그런 변화에 따른 불편을 주지 않기 위해 슈퍼클래스가 더 이상 변화하지 않도록 제약을 가해야 할지도 모름 추상 클래스를 만들고 이를 상속한 서브클래스에서변화가 필요한 부분을 바꿔서 쓸수 있게 만든 이유는변화의 성격이 다른 것을 분리해서 서로 영향을 주지 않은 채로각각 필요한 시점에 독립적으로 변경할 수 있게 하기 위해서 그렇다면 아예 클래스로 따로 때 버린다면? 코드로 새로 만든 클래스에 종속되어 버림 상속 했을 때 처럼 코드 수정없이 기능을 변경할 방법이 없음 클래스를 통한 확장의 문제점 현재 a 메서드를 사용해 기능을 제공하고 있는데만약 a 메서드 대신 b 메서드를 사용하도록 수정 된다면일일이 a 메서드를 사용한 수십 수백개의 메서드를 수정해야 함 기능을 제공하는 클래스가 어떤 것인지 클라이언트가 구체적으로 알고 있어야 함만약 다른 클래스를 구현하면 또 클라이언트 자체를 수정해야 함 근본적인 원인은 클라이언트가 바뀔 수 있는 정보(db 커넥션 등)을 가져오는 클래스에 대해 너무 많이 알고 있기 때문 해결 두 클래스가 서로 긴밀하게 연결되지 않도록 중간에 추상적인 연결고리를 만드는 것(java의 interface) 클라이언트 입장에서는 인터페이스를 상속 받는 클래스의 오브젝트라면 어떤 클래스로 만들었건메서드를 호출하기만 하면 약속된 오브젝트를 만들어서 돌려줄 것으로 기대함 Interface를 통한 확장의 문제점 아직도 클래스의 생성자를 호출해서 오브젝트를 생성하는 코드가 남아있음 초기에 한번 어떤 클래스의 오브젝트를 사용할지를 결정하는 생성자의 코드는 남아 있음 ex) conntion = new DConnectionMaker(); 결국 클라이언트가 어떤 구현 클래스의 오브젝트를 이용하게 할지 결정하는 관심사가 남아 있음 해결 오브젝트와 오브젝트 사이에 관계를 설정해야함 오브젝트 사이의 관계는 런타임 시에 한쪽이 다른 오브젝트의 레퍼런스를 갖고 잇는 방식으로 만들어짐(보통 알고 있는 인스턴스 생성 방식) ex)conntion = new DConnectionMaker(); DConnectionMaker의 오브젝트의 레퍼런스를 클라이언트의 connection 변수에 넣어서 사용하게 함 클래스 사이의 관계는 코드에 다른 클래스 이름이 나타나기 때문에 만들어지는 것오브젝트 사이의 관계는 코드에서는 특정한 클래스를 전혀 알지 못하더라도 해당 클래스가 구현한 인터페이스를 사용했다면, 그 클래스의 오브젝트를 인터페이스 타입을 받아서 사용 할 수 있음 이것이 객체지향의 다형성 개방 폐쇄 원칙 클래스나 모듈은 확장에는 열려 있어야하고 변경에는 닫혀 있어야 함 높은 응집도와 낮은 결합도높은 응집도 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있음 작업은 항상 전체적으로 일어나고 무엇을 변경할지 명확하며, 그것이 클라이언트의 다른 로직에 수정을 요구하지 않을 뿐더라기능에 영향을 주지 않음 변경이 일어난 경우에 이를 검증하려고 하면 변경한 구현 클래스만 직접 테스트 해보는 것으로 충분하기 때문 응집도를 높인 덕분 낮은 결합도 하나의 오브젝트가 변경이 일어날 떄에 관계를 맺고 잇는 다른 오브젝트에게 변화를 요구하는 정도 하나의 변경이 발생할 때 여타 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태 책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도를 유지해야 함 느슨하게 연결된 형태를 유지하는 것이 바람직 꼭 필요한 최소한의 방법만 제공 결합도가 낮아지면 대응하는 속도가 높아지고 구성이 깔금해짐 전략패턴 자신의 기능 맥락(context)에서 필요에 따라 변경이 필요한 알고리즘을 인터페스를 통해 통째로 외부로 분리시키고 이률 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔 사용할 수 있게 하는 디자인 패턴","link":"/2020/04/20/%ED%86%A0%EB%B9%84%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%81-reading/"},{"title":"프로그래머스: n진수 게임","text":"문제https://programmers.co.kr/learn/courses/30/lessons/17687 코드123456789101112131415161718192021222324252627282930313233343536373839private static final String[] ABCDEF = new String[] {&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;};public String solution(int n, int t, int m, int p) { int limit = t * m; String speakString = make(n, limit); char[] toChar = speakString.toCharArray(); StringBuilder answer = new StringBuilder(); int index = p - 1; for (int i = 0; i &lt; t; i++) { answer.append(toChar[index]); index += m; } return answer.toString();}public String make(int n, int limit) { StringBuilder sb = new StringBuilder().append(0); for (int i = 1; i &lt; limit; i++) { sb.append(changeDecimal(i, n)); } return sb.toString();}public char[] changeDecimal(int currentNumber, int n) { StringBuilder sb = new StringBuilder(); while(currentNumber &gt; 0) { int remain = currentNumber % n; sb.append(remain &gt;= 10 ? ABCDEF[remain-10] : remain); currentNumber /= n; } return sb.reverse().toString().toCharArray();} 흐름 진법 n, 미리 구할 숫자의 갯수 t, 게임에 참가하는 인원 m, 튜브의 순서 p 미리 구할 숫자의 갯수와 참가 인원 수를 곱해서 구해야 할 수의 갯수를 구한다. 1부터 구해야 될 수까지 반복한다. 반복하면서 숫자를 진법으로 나눈 나머지를 구한다. 나머지가 10 이상이면 A, B, C … 으로 치환한다. 현재 수를 n 진법의 값만큼 나눈다. 작은 수부터 역순으로 저장되어야 하므로 reverse() 메서드로 역순으로 돌린다. 0부터 미리 구할 숫자 갯수만큼 반복하면서 n진법으로 치환한 문자열에서 참가인원 숫자만큼 더하면서 숫자를 뽑아 저장한다. 끝 결과 번호 속도 테스트 1 통과 (0.87ms, 50.6MB) 테스트 2 통과 (1.15ms, 50.5MB) 테스트 3 통과 (1.02ms, 52MB) 테스트 4 통과 (1.07ms, 52.1MB) 테스트 5 통과 (4.60ms, 52.6MB) 테스트 6 통과 (4.40ms, 52.2MB) 테스트 7 통과 (4.55ms, 53MB) 테스트 8 통과 (2.62ms, 52.3MB) 테스트 9 통과 (2.45ms, 52.6MB) 테스트 10 통과 (2.57ms, 52.3MB) 테스트 11 통과 (2.49ms, 52MB) 테스트 12 통과 (2.45ms, 52.7MB) 테스트 13 통과 (5.32ms, 50.3MB) 테스트 14 통과 (69.61ms, 77.9MB) 테스트 15 통과 (75.19ms, 75.8MB) 테스트 16 통과 (70.55ms, 78.1MB) 테스트 17 통과 (17.09ms, 53.3MB) 테스트 18 통과 (15.42ms, 52.7MB) 테스트 19 통과 (6.46ms, 52.6MB) 테스트 20 통과 (13.17ms, 53MB) 테스트 21 통과 (29.51ms, 58.7MB) 테스트 22 통과 (21.20ms, 56.5MB) 테스트 23 통과 (41.04ms, 64.1MB) 테스트 24 통과 (59.00ms, 77.4MB) 테스트 25 통과 (74.66ms, 80MB) 테스트 26 통과 (24.89ms, 54.3MB) 테스트 케이스123assertEquals(&quot;0111&quot;, test.solution(2,4,2,1));assertEquals(&quot;02468ACE11111111&quot;, test.solution(16,16,2,1));assertEquals(&quot;13579BDF01234567&quot;, test.solution(16,16,2,2)); 참고사이트 https://tech.kakao.com/2017/11/14/kakao-blind-recruitment-round-3/","link":"/2020/08/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-n%EC%A7%84%EC%88%98-%EA%B2%8C%EC%9E%84/"},{"title":"프로그래머스: 가장 큰 수","text":"문제https://programmers.co.kr/learn/courses/30/lessons/42746 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public String solution(int[] numbers) { List&lt;Numbers&gt; list = new ArrayList&lt;Numbers&gt;(); for (int i = 0; i &lt; numbers.length; i++) { int number = numbers[i]; char[] str = String.valueOf(number).toCharArray(); StringBuilder fourDigitString = new StringBuilder(); fourDigitString.append(str); if (str.length &lt; 4) { for (int j = 0; j &lt; 4 - str.length; j++) { fourDigitString.append(str[((j) % str.length)]); } } list.add(new Numbers(i, Integer.parseInt(fourDigitString.toString()))); } Collections.sort(list, new Comparator&lt;Numbers&gt;() { @Override public int compare(Numbers o1, Numbers o2) { return o2.value.compareTo(o1.value); } }); StringBuilder sb = new StringBuilder(); int sum = 0; for (Numbers n : list) { sum += n.value; sb.append(numbers[n.postion]); } if (sum == 0) { sb.setLength(0); sb.append(0); } return sb.toString();}class Numbers { public Integer postion; public Integer value; public Numbers(Integer postion, Integer value) { this.postion = postion; this.value = value; }} 흐름 문제에서 numbers의 원소 값이 1000 이하라고 했으므로 numbers 크기 만큼 돌면서 numbers 안에 값이 4자리가 아닌 경우 자기 숫자를 뒤에 덧붙여서 4자리로 만듬 ex) 121 &gt; 1212, 1 &gt; 1111, 23 &gt; 2323, … 현재 배열의 index와 값을 비교하기 위에 inner class를 하나 만들어서 index와 value를 저장하고 class를 list에 추가 list를 class의 value 값으로 큰 수부터 나오도록 정렬 list를 돌면서 value를 StringBuilder로 붙임 이 때, 0 0 0 0 일 경우 0 이 되어야 하므로 value들을 모두 더했을 때 값이 0이라면 0 만 붙임 toString() 으로 String형으로 return 끝 다른 분들의 해결방법다른분의 코드12345678910111213141516171819202122public String solution(int[] numbers) { String answer = &quot;&quot;; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; numbers.length; i++) { list.add(numbers[i]); } Collections.sort(list, (a, b) -&gt; { String as = String.valueOf(a), bs = String.valueOf(b); return -Integer.compare(Integer.parseInt(as + bs), Integer.parseInt(bs + as)); }); StringBuilder sb = new StringBuilder(); for(Integer i : list) { sb.append(i); } answer = sb.toString(); if(answer.charAt(0) == '0') { return &quot;0&quot;; }else { return answer; }} 위 코드의 로직 list에 numbers array를 그대로 저장하고 list의 저장된 element를 앞뒤로 붙여서 정수로 바꾼 후 비교해서 정렬 String을 다루는 부분이 많아서 속도는 살짝 떨어지는 듯 결과1 번 번호 속도 테스트 1 통과 (139.80ms, 83.2MB) 테스트 2 통과 (88.71ms, 67MB) 테스트 3 통과 (167.96ms, 82.4MB) 테스트 4 통과 (17.95ms, 50.7MB) 테스트 5 통과 (129.09ms, 77.4MB) 테스트 6 통과 (116.84ms, 71.2MB) 테스트 7 통과 (1.44ms, 52.3MB) 테스트 8 통과 (1.38ms, 52.7MB) 테스트 9 통과 (1.20ms, 50.2MB) 테스트 10 통과 (1.46ms, 52.6MB) 테스트 11 통과 (1.65ms, 52.9MB) 2 번 번호 속도 테스트 1 통과 (340.75ms, 105MB) 테스트 2 통과 (236.67ms, 82.1MB) 테스트 3 통과 (350.56ms, 126MB) 테스트 4 통과 (80.72ms, 59.7MB) 테스트 5 통과 (300.18ms, 110MB) 테스트 6 통과 (280.61ms, 87.6MB) 테스트 7 통과 (31.26ms, 57.2MB) 테스트 8 통과 (35.88ms, 53.4MB) 테스트 9 통과 (34.27ms, 55.3MB) 테스트 10 통과 (30.44ms, 55.6MB) 테스트 11 통과 (40.16ms, 55.3MB) 테스트 케이스123456789assertEquals(&quot;6210&quot;, test.solution(new int[] {6, 10, 2}));assertEquals(&quot;9534330&quot;, test.solution(new int[] {3, 30, 34, 5, 9}));assertEquals(&quot;220200&quot;, test.solution(new int[] {2,200,20}));assertEquals(&quot;2200&quot;, test.solution(new int[] {2,0,20}));assertEquals(&quot;0&quot;, test.solution(new int[] {0,0,0}));assertEquals(&quot;21212&quot;, test.solution(new int[] {12, 212}));assertEquals(&quot;21221&quot;, test.solution(new int[] {212, 21}));assertEquals(&quot;7000&quot;, test.solution(new int[] {0, 0, 70}));assertEquals(&quot;1000000&quot;, test.solution(new int[] {0, 0, 0, 1000}));","link":"/2020/05/07/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%88%98/"},{"title":"프로그래머스: 가장 큰 정사각형 찾기","text":"문제https://programmers.co.kr/learn/courses/18/lessons/1879 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public int solution(int[][] board) { if (board.length &lt; 2 || board[0].length &lt; 2) { return smallSquare(board); } int answer = nomalSquare(board); return answer * answer;}private int smallSquare(int[][] board) { int size = 0; for (int i = 0; i &lt; board.length; i++) { for (int j = 0; j &lt; board[0].length; j++) { if (board[i][j] == 1) { size = 1; break; } } if (size == 1) { break; } } return size;}private int nomalSquare(int[][] board) { int answer = 0; int min = Integer.MAX_VALUE; for (int i = 1; i &lt; board.length; i++) { for (int j = 1; j &lt; board[0].length; j++) { if (board[i][j] == 0) { continue; } board[i][j] = Math.min(board[i-1][j-1], Math.min(board[i-1][j], board[i][j-1])) + 1; if (board[i][j] &gt; answer) { answer = board[i][j]; } } } return answer;} 흐름 배열의 크기가 2보다 작은 경우엔 크기가 1인 정사각형 밖에 존재 할 수 없으므로, 배열의 크키가 2 이하인 배열에 1이 들어있는지 확인 배열을 [1,1] 부터 반복 현재 위치의 값이 0인 경우엔 절대 정사각형 일 수 없으므로 더 이상 돌지 않고 continue 현재 위치(1,1)의 좌상(0,0)과 상(0,1) 좌(1,0)의 값들중 최소값을 구함 구한 최소값에 1을 더해서 현재 위치에 할당 구한 최소값이 현재 가장 큰 정사각형의 크기 보다 크면 정사각형의 크기를 구한 최소값으로 변경 반복 끝 흐름 이미지 설명 결과정확성 테스트 번호 속도 테스트 1 통과 (0.86ms, 52.4MB) 테스트 2 통과 (0.77ms, 52.2MB) 테스트 3 통과 (0.83ms, 52.6MB) 테스트 4 통과 (0.75ms, 50.4MB) 테스트 5 통과 (0.72ms, 52.8MB) 테스트 6 통과 (0.83ms, 52.7MB) 테스트 7 통과 (0.79ms, 50.4MB) 테스트 8 통과 (0.83ms, 54.1MB) 테스트 9 통과 (0.79ms, 52.4MB) 테스트 10 통과 (0.83ms, 52.3MB) 테스트 11 통과 (0.75ms, 52.2MB) 테스트 12 통과 (0.79ms, 52.3MB) 테스트 13 통과 (0.76ms, 52.1MB) 테스트 14 통과 (0.83ms, 49.9MB) 테스트 15 통과 (0.75ms, 50.5MB) 테스트 16 통과 (0.91ms, 50MB) 테스트 17 통과 (0.83ms, 52.4MB) 테스트 18 통과 (0.92ms, 52.3MB) 테스트 19 통과 (1.06ms, 52MB) 효율성 테스트 번호 속도 테스트 1 통과 (24.74ms, 97.5MB) 테스트 2 통과 (25.24ms, 99.6MB) 테스트 3 통과 (26.48ms, 99.8MB) 테스트 케이스123assertEquals(9, test.solution(new int[][]{{0,1,1,1} ,{1,1,1,1},{1,1,1,1},{0,0,1,0}}));assertEquals(4, test.solution(new int[][]{{0,0,1,1} ,{1,1,1,1}}));assertEquals(1, test.solution(new int[][]{{0,0,1,1}})); 참고 사이트 https://blog.sonim1.com/212","link":"/2020/06/23/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95-%EC%B0%BE%EA%B8%B0/"},{"title":"프로그래머스: H-Index","text":"문제https://programmers.co.kr/learn/courses/30/lessons/42747?language=java 코드12345678910111213141516171819202122public int solution(int[] citations) { int answer = 0; int n = citations.length; Arrays.sort(citations); for (int i = 0; i &lt;= citations[n - 1]; i++) { int high = 0; for (int j = 0; j &lt; n; j++) { if (i &lt;= citations[j]) { high++; } if (i &lt;= high) { answer = i; } } } return answer;} 흐름 논문을 인용한 횟수가 담긴 배열 citations를 정렬 가장 많이 인용한 횟수 만큼 반복 0부터 배열 길이만큼 반복하면서 i 값이 인용 횟수보다 작은 경우 i 보다 인용된 횟수가 많은 것이므로 high 변수 증가 h번 이상 인용된 논문이 h편 이상이여야 하므로 i가 high 보다 작을 경우에만 answer에 저장 i가 high보다 커질 경우 answer에 저장되지 않으므로 answer에 마지막으로 저장된 값이 h 끝 다른 해결방법코드1234567891011public int solution(int[] citations) { Arrays.sort(citations); int max = 0; for(int i = citations.length-1; i &gt; -1; i--){ int min = (int)Math.min(citations[i], citations.length - i); if(max &lt; min) max = min; } return max;} 위 코드의 로직 배열을 정렬 후 배열의 마지막 값과 1 부터 증가 시키면서 citations의 길이 만큼 반복함 예를 들어 {0, 1, 3, 5, 6} 인 경우, citations.length는 5, i = 5 - 1 이므로 4, citations.length - i는 5 - 4가 되므로 1임 그런고로, 1과 citations[4]인 6과 비교해서 작은 놈을 min에 저장 위 과정을 반복하면min = Min(6,1)min = Min(5,2)min = Min(3,3)min = Min(1,4)min = Min(0,5)가 되고 max는 max가 min 보다 작을 때 max에 min 값이 저장되므로 max엔 최종적으로 3이 저장 어떻게 유추해서 푼 건지 이해가 안간다 천재인 듯 결과1번 번호 속도 테스트 1 통과 (11.43ms, 50.3MB) 테스트 2 통과 (14.71ms, 52.4MB) 테스트 3 통과 (15.13ms, 50.7MB) 테스트 4 통과 (13.74ms, 50.1MB) 테스트 5 통과 (16.49ms, 50.6MB) 테스트 6 통과 (13.86ms, 50MB) 테스트 7 통과 (10.08ms, 52.4MB) 테스트 8 통과 (7.45ms, 52.6MB) 테스트 9 통과 (8.26ms, 52.9MB) 테스트 10 통과 (10.29ms, 50MB) 테스트 11 통과 (17.04ms, 50.9MB) 테스트 12 통과 (8.21ms, 52.8MB) 테스트 13 통과 (15.30ms, 52.5MB) 테스트 14 통과 (13.62ms, 52.7MB) 테스트 15 통과 (15.64ms, 50.5MB) 테스트 16 통과 (0.97ms, 54.7MB) 2번 번호 속도 테스트 1 통과 (1.10ms, 52.4MB) 테스트 2 통과 (1.36ms, 50.5MB) 테스트 3 통과 (1.36ms, 50.8MB) 테스트 4 통과 (0.85ms, 51.9MB) 테스트 5 통과 (0.95ms, 52.5MB) 테스트 6 통과 (1.35ms, 52.7MB) 테스트 7 통과 (1.00ms, 50.6MB) 테스트 8 통과 (0.87ms, 50.9MB) 테스트 9 통과 (1.06ms, 50.5MB) 테스트 10 통과 (1.11ms, 52.6MB) 테스트 11 통과 (1.39ms, 52.5MB) 테스트 12 통과 (0.91ms, 52.6MB) 테스트 13 통과 (1.22ms, 50.3MB) 테스트 14 통과 (1.50ms, 52.5MB) 테스트 15 통과 (1.36ms, 52.3MB) 테스트 16 통과 (0.94ms, 52.5MB) 속도도 압도적… 테스트 케이스1234567891011assertEquals(3, test.solution(new int[] {3,0,6,1,5}));assertEquals(3, test.solution(new int[] {6,5,4,3,1,1,1,1,1}));assertEquals(3, test.solution(new int[] {0, 1, 1, 1, 1, 3, 3, 4}));assertEquals(3, test.solution(new int[] {5, 5, 5, 0}));assertEquals(2, test.solution(new int[] {2,2,2,2,2}));assertEquals(4, test.solution(new int[] {5, 5, 5, 5}));assertEquals(5, test.solution(new int[] {5, 5, 5, 5, 5}));assertEquals(1, test.solution(new int[] {7}));assertEquals(3, test.solution(new int[] {4, 3, 3, 3, 3}));assertEquals(0, test.solution(new int[] {0,0,0,0,0,0}));assertEquals(3, test.solution(new int[] {6, 5, 3, 1, 0}));","link":"/2020/05/08/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-H-Index/"},{"title":"프로그래머스: 기능개발","text":"https://programmers.co.kr/learn/courses/30/lessons/42586 소스12345678910111213141516171819202122232425262728public int[] solution(int[] progresses, int[] speeds) { int start = 0; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); while (start != progresses.length) { int deploy = 0; for (int i = start; i &lt; progresses.length; i++) { progresses[i] += speeds[i]; } for (int i = start; i &lt; progresses.length; i++) { if (progresses[start] &lt; 100) { break; } if (progresses[i] &gt;= 100) { ++start; ++deploy; } } if (deploy != 0) { list.add(deploy); } } int[] answer = list.stream().mapToInt(i -&gt; i).toArray(); return answer;} 흐름 기능개발이 완료된 인덱스부터 반복하기 위해 start 변수 생성 기능개발이 끝날 때 까지 반복 개발이 안 끝난 기능 index 부터 돌면서 작업 속도를 더 함 개발이 안 끝난 기능 index 부터 돌면서 첫 번째 기능이 개발 됐는지 확인하고 안 끝났으면 3 번으로 돌아감 첫 번째 기능이 완료 되었으면 그 다음 기능개발을 위해 ++start 하고, deploy된 기능을 카운팅하는 deploy 변수를 증가 deploy한 기능이 있는 경우에만 list에 저장 ArrayList를 int[]로 변경 끝 다른 분의 소스1234567891011public int[] solution(int[] progresses, int[] speeds) { int[] dayOfend = new int[100]; int day = -1; for(int i=0; i&lt;progresses.length; i++) { while(progresses[i] + (day*speeds[i]) &lt; 100) { day++; } dayOfend[day]++; } return Arrays.stream(dayOfend).filter(i -&gt; i!=0).toArray();} 로직 기능 갯수 만큼 돌면서 진도율과 날짜 * 개발 속도를 비교해서 100 보다 작으면 다음날로 증가시키고 크면 그 날짜에 저장되는 갯수를 증가시킴 대박 결과1 번 번호 속도 테스트 1 통과 (4.53ms, 50.8MB) 테스트 2 통과 (5.07ms, 50.6MB) 테스트 3 통과 (5.09ms, 52.8MB) 테스트 4 통과 (5.29ms, 52.4MB) 테스트 5 통과 (8.36ms, 55MB) 테스트 6 통과 (4.95ms, 51.2MB) 테스트 7 통과 (5.58ms, 52.6MB) 테스트 8 통과 (5.18ms, 50.7MB) 테스트 9 통과 (5.44ms, 52.5MB) 테스트 10 통과 (5.22ms, 50.5MB) 2 번 번호 속도 테스트 1 통과 (6.60ms, 51.4MB) 테스트 2 통과 (6.83ms, 53.1MB) 테스트 3 통과 (6.92ms, 52.5MB) 테스트 4 통과 (6.70ms, 52.8MB) 테스트 5 통과 (19.88ms, 52.4MB) 테스트 6 통과 (5.05ms, 50.7MB) 테스트 7 통과 (7.01ms, 52.5MB) 테스트 8 통과 (4.68ms, 50.5MB) 테스트 9 통과 (6.95ms, 52.2MB) 테스트 10 통과 (5.31ms, 50.8MB) 두 소스 모두 Arrays.stream을 사용하지 않고 반복해서 저장하면 1초 대로 줄어듬. 확실히 스트림이 느린 듯함. 테스트 케이스123assertArrayEquals(new int[] {2,1}, test.solution(new int[] {93, 30, 55}, new int[] {1, 30, 5}));assertArrayEquals(new int[] {3}, test.solution(new int[] {0, 30, 55}, new int[] {1, 99, 99}));assertArrayEquals(new int[] {1,1,1}, test.solution(new int[] {3, 2, 1}, new int[] {1, 1, 1})); 전체 소스https://github.com/jungguji/algorithm_training/blob/master/src/main/java/algorithm/programmers/level2/stackqueue/%EB%8B%A4%EB%A6%AC%EB%A5%BC_%EC%A7%80%EB%82%98%EB%8A%94_%ED%8A%B8%EB%9F%AD.java","link":"/2020/04/22/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B8%B0%EB%8A%A5%EA%B0%9C%EB%B0%9C/"},{"title":"프로그래머스: 괄호 변환","text":"문제https://programmers.co.kr/learn/courses/30/lessons/60058 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283private static final Character LEFT = '(';private static final Character RIGHT = ')';public String solution(String p) { String answer = getDivide(p); return answer;}private String getDivide(String w) { if (w.isEmpty()) { return w; } String[] uAndv = getUAndV(w); String u = uAndv[0]; String v = uAndv[1]; if (!isPerfectBracket(u)) { return createPerfectBracket(u, v); } return u + getDivide(v);}private String[] getUAndV(String w) { StringBuilder sb = new StringBuilder(); char[] tochar = w.toCharArray(); Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); char popChar = (tochar[0] == LEFT) ? RIGHT : LEFT; for (char ch : tochar) { if (ch == popChar) { stack.pop(); sb.append(popChar); } else { sb.append(stack.push(ch)); } if (stack.isEmpty()) { break; } } String[] uAndv = new String[2]; uAndv[0] = sb.toString(); uAndv[1] = new String(tochar, uAndv[0].length(), tochar.length - uAndv[0].length()); return uAndv;}private boolean isPerfectBracket(String u) { int sum = 0; for (int i = 0; i &lt; u.length(); i++) { sum += (u.charAt(i) == LEFT) ? +1 : -1; if (sum &lt; 0) { break; } } return sum == 0;}private String createPerfectBracket(String u, String v) { StringBuilder str = new StringBuilder(); str.append(LEFT); str.append(getDivide(v)); str.append(RIGHT); char[] newU = u.substring(1, u.length() -1).toCharArray(); str.append(getChange(newU)); return str.toString();}private char[] getChange(char[] newU) { for (int i = 0; i &lt; newU.length; i++) { newU[i] = (newU[i] == LEFT) ? RIGHT : LEFT; } return newU;} 흐름 문제에 있는 그대로 작성하면 됨 입력이 빈 문자열인 경우, 빈 문자열을 반환합니다. 문자열 w를 두 “균형잡힌 괄호 문자열” u, v로 분리합니다.단, u는 “균형잡힌 괄호 문자열”로 더 이상 분리할 수 없어야 하며, v는 빈 문자열이 될 수 있습니다. 문자열 u가 “올바른 괄호 문자열” 이라면 문자열 v에 대해 1단계부터 다시 수행합니다. 수행한 결과 문자열을 u에 이어 붙인 후 반환합니다. 문자열 u가 “올바른 괄호 문자열”이 아니라면 아래 과정을 수행합니다. 빈 문자열에 첫 번째 문자로 ‘(‘를 붙입니다. 문자열 v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙입니다. ‘)’를 다시 붙입니다. u의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어서 뒤에 붙입니다. 생성된 문자열을 반환합니다. 결과 번호 속도 테스트 1 통과 (32.01ms, 55.5MB) 테스트 2 통과 (1.42ms, 52.3MB) 테스트 3 통과 (30.81ms, 55.3MB) 테스트 4 통과 (30.93ms, 52.9MB) 테스트 5 통과 (30.16ms, 55.5MB) 테스트 6 통과 (29.55ms, 55.3MB) 테스트 7 통과 (35.55ms, 53MB) 테스트 8 통과 (29.41ms, 55.2MB) 테스트 9 통과 (28.63ms, 53.6MB) 테스트 10 통과 (30.95ms, 54.9MB) 테스트 11 통과 (30.81ms, 55.9MB) 테스트 12 통과 (28.73ms, 55.3MB) 테스트 13 통과 (30.50ms, 55.7MB) 테스트 14 통과 (38.62ms, 53.5MB) 테스트 15 통과 (31.72ms, 53.5MB) 테스트 16 통과 (31.20ms, 55MB) 테스트 17 통과 (30.63ms, 55.2MB) 테스트 18 통과 (33.95ms, 55.4MB) 테스트 19 통과 (31.25ms, 53.6MB) 테스트 20 통과 (33.02ms, 55.5MB) 테스트 21 통과 (33.70ms, 53.5MB) 테스트 22 통과 (33.13ms, 53.5MB) 테스트 23 통과 (32.43ms, 53MB) 테스트 24 통과 (31.24ms, 55.9MB) 테스트 25 통과 (33.63ms, 56MB) 테스트 케이스123456789assertEquals(&quot;(()())()&quot;, test.solution(&quot;(()())()&quot;));assertEquals(&quot;()&quot;, test.solution(&quot;)(&quot;));assertEquals(&quot;()(())()&quot;, test.solution(&quot;()))((()&quot;));assertEquals(&quot;(((())))&quot;, test.solution(&quot;)()()()(&quot;));assertEquals(&quot;()()((()))&quot;, test.solution(&quot;))()))((((&quot;));assertEquals(&quot;()&quot;, test.solution(&quot;()&quot;));assertEquals(&quot;()()()()()()((()))&quot;, test.solution(&quot;()()()()()()((()))&quot;));assertEquals(&quot;((((())())))()(())&quot;, test.solution(&quot;((((())()))))))(((&quot;));assertEquals(&quot;(((()())())())((()))&quot;, test.solution(&quot;))))((((((()())()))(&quot;));","link":"/2020/06/16/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B4%84%ED%98%B8-%EB%B3%80%ED%99%98/"},{"title":"프로그래머스: 구명보트","text":"문제https://programmers.co.kr/learn/courses/30/lessons/42885 코드1234567891011121314151617181920public int solution(int[] people, int limit) { Arrays.sort(people); int left = 0; int right = people.length - 1; int answer = 0; while (left &lt;= right) { int sum = people[left] + people[right]; if (sum &lt;= limit) { ++left; } ++answer; --right; } return answer;} 흐름 배열을 정렬 배열 내에서 제일 작은 값이랑 제일 큰 값을 더해서 limit이 넘어가는 지 확인 넘어가면 제일 작은 값을 증가 안 넘어가면 제일 큰 값 혼자 빠져야하므로 answer을 증가시키고 right를 감소 시켜서 인덱스를 한칸 땡김 right가 left 보다 작아질 때 까지 반복 ex) [50,50,70,80] 인 경우 left = 0, right = 4 인데 위 코드르 반복하면 right가 점점 줄어들어 left와 만날 때 끝 끝 결과정확성 테스트 번호 속도 테스트 1 통과 (1.92ms, 52.7MB) 테스트 2 통과 (1.56ms, 51.4MB) 테스트 3 통과 (1.66ms, 51MB) 테스트 4 통과 (2.02ms, 50.7MB) 테스트 5 통과 (1.42ms, 53MB) 테스트 6 통과 (1.37ms, 50.9MB) 테스트 7 통과 (1.46ms, 53.1MB) 테스트 8 통과 (0.95ms, 52.6MB) 테스트 9 통과 (1.15ms, 52.5MB) 테스트 10 통과 (2.01ms, 52.4MB) 테스트 11 통과 (1.68ms, 52.7MB) 테스트 12 통과 (1.78ms, 52.7MB) 테스트 13 통과 (2.07ms, 52.5MB) 테스트 14 통과 (1.46ms, 50.5MB) 테스트 15 통과 (1.22ms, 50.1MB) 효율성 테스트 번호 속도 테스트 1 통과 (11.43ms, 56.1MB) 테스트 2 통과 (11.63ms, 55.7MB) 테스트 3 통과 (11.88ms, 53.7MB) 테스트 4 통과 (8.84ms, 56.3MB) 테스트 5 통과 (11.08ms, 55.7MB) 테스트 케이스123456assertEquals(3, test.solution(new int[] {70, 50, 80, 50}, 100));assertEquals(3, test.solution(new int[] {70, 80, 50}, 100));assertEquals(2, test.solution(new int[] {40, 40, 80}, 160));assertEquals(2, test.solution(new int[] {20, 50, 50, 80}, 100));assertEquals(5, test.solution(new int[] {40,50,60,70,80,90}, 100));assertEquals(2, test.solution(new int[] {40,40,40}, 100));","link":"/2020/05/19/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B5%AC%EB%AA%85%EB%B3%B4%ED%8A%B8/"},{"title":"프로그래머스: 다리를 지나는 트럭","text":"문제https://programmers.co.kr/learn/courses/30/lessons/42583?language=java 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public int solution(int bridge_length, int weight, int[] truck_weights) { LinkedList&lt;Truck&gt; queue = new LinkedList&lt;Truck&gt;(); for (int i = 0; i &lt; truck_weights.length; i++) { queue.offer(new Truck(bridge_length, truck_weights[i])); } int answer = 1; int bridgeOnTruck = 0; while (!queue.isEmpty()) { int totalWeight = 0; for (int i = 0; i &lt; bridgeOnTruck; i++) { totalWeight += queue.get(i).weight; } int nextWeight = 0; if (queue.size() &gt; bridgeOnTruck) { nextWeight = queue.get(bridgeOnTruck).weight; } if (totalWeight + nextWeight &lt;= weight) { if (queue.size() &gt; bridgeOnTruck) { ++bridgeOnTruck; } } for (int i = 0; i &lt; bridgeOnTruck; i++) { Truck truck = queue.get(i); truck.position = truck.position - 1; } if (queue.peek().position == 0) { queue.poll(); --bridgeOnTruck; } ++answer; } return answer;}class Truck { public int position; public int weight; public Truck(int position, int weight) { this.position = position; this.weight = weight; }} 흐름 트럭 array를 queue에 모두 저장 트럭 모두 건널 때 까지 반복 한 번에 몇 개의 트럭까지 건널 수 있을 지 계산하기 위해 현재 다리 위에 있는 트럭의 개수 만큼 돌면서 트럭 무게를 더함 다음 번 트럭까지 다리에 올라 올 수 있는 지 확인하기 위해 큐의 마지막 index가 아니라면 queue에서 다음 번 트럭의 무게를 가져옴 현재 다리에 있는 트럭들의 무게 + 다음 트럭의 무게를 더한 값이 다리가 버틸 수 있는 무게 보다 가벼우면 큐의 마지막인지 체크해서 큐의 마지막이 아니라면 그 다음 트럭도 다리 위에 올라와야 하기 때문에 다리 위 트럭의 개수(truckAmount)를 증가 시킴 다리 위 트럭의 수 만큼 반복하면서 트럭을 앞으로 한칸 씩 움직임 첫 번째 트럭이 다리를 건넜다면 queue에서 제거하고 다리 위 트럭 수를 하나 감소 시킴 초를 증가 시킴 끝 결과 번호 속도 테스트 1 통과 (3.63ms, 52.1MB) 테스트 2 통과 (14.16ms, 52.1MB) 테스트 3 통과 (1.65ms, 53.3MB) 테스트 4 통과 (41.49ms, 53.8MB) 테스트 5 통과 (70.64ms, 53.9MB) 테스트 6 통과 (53.31ms, 56.1MB) 테스트 7 통과 (3.09ms, 50MB) 테스트 8 통과 (1.97ms, 50.3MB) 테스트 9 통과 (10.68ms, 54.6MB) 테스트 10 통과 (2.20ms, 53MB) 테스트 11 통과 (1.10ms, 52.5MB) 테스트 12 통과 (2.35ms, 52.2MB) 테스트 13 통과 (4.50ms, 52.2MB) 테스트 14 통과 (1.26ms, 53MB) 테스트 케이스123assertEquals(8, test.solution(2, 10, new int[] {7,4,5,6}));assertEquals(101, test.solution(100, 100, new int[] {10}));assertEquals(110, test.solution(100, 100, new int[] {10,10,10,10,10,10,10,10,10,10}));","link":"/2020/04/29/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%8B%A4%EB%A6%AC%ED%8A%B8%EB%9F%AD/"},{"title":"프로그래머스: 다트게임","text":"https://programmers.co.kr/learn/courses/30/lessons/17682?language=java 소스12345678910111213141516171819202122232425262728293031323334353637383940414243public int solution(String dartResult) { char[] charArray = dartResult.toCharArray(); int[] scores = new int[3]; int i = 0; StringBuilder sb = new StringBuilder(); for (char ch : charArray) { switch (ch) { case 'S': scores[i++] = Integer.parseInt(sb.toString()); sb.setLength(0); break; case 'D': int a = Integer.parseInt(sb.toString()); scores[i++] = a * a; sb.setLength(0); break; case 'T': int b = Integer.parseInt(sb.toString()); scores[i++] = b * b * b; sb.setLength(0); break; case '*': if (i &gt; 1) { scores[i-2] = scores[i-2] * 2; } scores[i-1] = scores[i-1] * 2; break; case '#': scores[i-1] = scores[i-1] * -1; break; default: sb.append(ch); break; } } int answer = scores[0] + scores[1] + scores[2]; return answer;} 흐름 문자열을 charArray로 치환하고 loop 돈다. char를 비교하여 각 문자별로 맞게 계산을 실행하고, index를 증가 시킨 후 다음 점수 저장을 위해 StringBuilder를 초기화 한다. ‘*‘ 일 경우 이전 점수와 현재 점수 모두 2 배씩 해야 하므로 2 번 던진 경우엔 이전 점수도 2를 곱 해준다. 계산된 세 점수 모두 더해서 return 한다. 끝 결과 번호 속도 테스트 1 통과 (0.79ms, 52.4MB) 테스트 2 통과 (0.86ms, 52.2MB) 테스트 3 통과 (0.86ms, 52.4MB) 테스트 4 통과 (0.84ms, 52.3MB) 테스트 5 통과 (0.92ms, 54.5MB) 테스트 6 통과 (0.82ms, 52.5MB) 테스트 7 통과 (0.83ms, 52.1MB) 테스트 8 통과 (0.83ms, 52.2MB) 테스트 9 통과 (0.90ms, 50.8MB) 테스트 10 통과 (0.83ms, 52.7MB) 테스트 11 통과 (0.84ms, 52.9MB) 테스트 12 통과 (0.84ms, 52.5MB) 테스트 13 통과 (0.82ms, 50.4MB) 테스트 14 통과 (0.74ms, 52.6MB) 테스트 15 통과 (0.90ms, 52.1MB) 테스트 16 통과 (0.86ms, 52.9MB) 테스트 17 통과 (0.81ms, 52.7MB) 테스트 18 통과 (0.86ms, 52.4MB) 테스트 19 통과 (0.85ms, 50.1MB) 테스트 20 통과 (0.95ms, 52.4MB) 테스트 21 통과 (0.81ms, 50.4MB) 테스트 22 통과 (0.80ms, 51.9MB) 테스트 23 통과 (0.88ms, 52.3MB) 테스트 24 통과 (0.87ms, 51.9MB) 테스트 25 통과 (0.87ms, 50.4MB) 테스트 26 통과 (0.88ms, 52.1MB) 테스트 27 통과 (0.89ms, 52.4MB) 테스트 28 통과 (0.88ms, 52.2MB) 테스트 29 통과 (0.85ms, 52.7MB) 테스트 30 통과 (0.89ms, 51.8MB) 테스트 31 통과 (0.85ms, 50.2MB) 테스트 32 통과 (0.83ms, 52MB) 테스트 케이스1234567assertEquals(37, test.solution(&quot;1S2D*3T&quot;));assertEquals(9, test.solution(&quot;1D2S#10S&quot;));assertEquals(3, test.solution(&quot;1D2S0T&quot;));assertEquals(23, test.solution(&quot;1S*2T*3S&quot;));assertEquals(5, test.solution(&quot;1D#2S*3S&quot;));assertEquals(-4, test.solution(&quot;1T2D3D#&quot;));assertEquals(59, test.solution(&quot;1D2S3T*&quot;)); 프로그래머스에서 제공한 예제 테스트 케이스이므로위 테스트케이스를 모두 통과하여도 실제 테스트에선 통과하지 못할 수 있음.","link":"/2020/04/10/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%8B%A4%ED%8A%B8%EA%B2%8C%EC%9E%84/"},{"title":"프로그래머스: 문자열 압축","text":"문제https://programmers.co.kr/learn/courses/30/lessons/60057 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public int solution(String s) { int stringLength = s.length(); StringBuilder result = new StringBuilder(); String origin = new String(); char[] tochar = s.toCharArray(); int min = Integer.MAX_VALUE; for (int i = 1; i &lt;= stringLength / 2; i++) { int compression = 1; result.setLength(0); origin = new String(tochar, 0, i); String nextWord = new String(); for (int j = i; j &lt; stringLength; j+=i) { if (j + i &gt; stringLength) { nextWord = s.substring(j, stringLength); } else { nextWord = new String(tochar, j , i); } if (origin.equals(nextWord)) { ++compression; } else { if (compression != 1) { result.append(compression); } result.append(origin); origin = nextWord.toString(); compression = 1; } } if (compression != 1) { result.append(compression); } result.append(origin); if (min &gt; result.length()) { min = result.length(); } } int answer = min &gt; stringLength ? stringLength : min; return answer; 흐름 문자열을 반으로 나눠서 2개로 나눈 것 보다 짧을 수 없으므로 문자열 길이 / 2 한 값 만큼 반복 비교 할 문자열을 구함(origin) 처음엔 1개 짜리 이후엔 2개, 3개, … 증가 할 수 있도록 i를 증가 시키면서 i 번째 까지 자름 i 번째 문자 이후로 비교 할 문자를 구함 같으면 압축율을 증가시키고 다르면 압축율과 문자를 더해서 압축문자열(result)을 만듬 비교 할 문자를 구하면서 마지막 문자는 안 붙여지고 팅기므로 for 문 밖에서 마지막 문자를 붙임 이전에 구했던 압축문자열 길이와 비교해서 더 작은 길이를 저장함 끝 결과 번호 속도 테스트 1 통과 (0.99ms, 52.4MB) 테스트 2 통과 (2.92ms, 49.9MB) 테스트 3 통과 (1.72ms, 52.7MB) 테스트 4 통과 (0.99ms, 52.1MB) 테스트 5 통과 (0.84ms, 50MB) 테스트 6 통과 (1.03ms, 52.4MB) 테스트 7 통과 (3.49ms, 50.4MB) 테스트 8 통과 (2.49ms, 50.3MB) 테스트 9 통과 (4.46ms, 52.6MB) 테스트 10 통과 (9.25ms, 52.4MB) 테스트 11 통과 (1.25ms, 50.2MB) 테스트 12 통과 (1.28ms, 52.3MB) 테스트 13 통과 (9.63ms, 51.8MB) 테스트 14 통과 (4.35ms, 52.2MB) 테스트 15 통과 (1.31ms, 52.1MB) 테스트 16 통과 (0.85ms, 50.2MB) 테스트 17 통과 (8.91ms, 52.6MB) 테스트 18 통과 (7.70ms, 52.6MB) 테스트 19 통과 (8.63ms, 54.9MB) 테스트 20 통과 (7.89ms, 52.6MB) 테스트 21 통과 (9.99ms, 52.7MB) 테스트 22 통과 (10.63ms, 52.7MB) 테스트 23 통과 (9.68ms, 52.5MB) 테스트 24 통과 (7.89ms, 54.4MB) 테스트 25 통과 (10.43ms, 52.9MB) 테스트 26 통과 (8.17ms, 52.5MB) 테스트 27 통과 (15.60ms, 52.6MB) 테스트 28 통과 (0.88ms, 50.4MB) result에 문자열을 더하지 말고 그냥 문자열 길이를 더하는 방식으로 하면 더 시간을 줄일 수 있음 테스트 케이스12345678assertEquals(7, test.solution(&quot;aabbaccc&quot;));assertEquals(9, test.solution(&quot;ababcdcdababcdcd&quot;));assertEquals(8, test.solution(&quot;abcabcdede&quot;));assertEquals(14, test.solution(&quot;abcabcabcabcdededededede&quot;));assertEquals(17, test.solution(&quot;xababcdcdababcdcd&quot;));assertEquals(1, test.solution(&quot;a&quot;));assertEquals(2, test.solution(&quot;aaaaa&quot;));assertEquals(3, test.solution(&quot;aaaaaaaaaa&quot;)); 참고 사이트 https://velog.io/@pa324/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-Level-1-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%95%95%EC%B6%95%EC%B9%B4%EC%B9%B4%EC%98%A4-2020%EA%B3%B5%EC%B1%84-%EB%AC%B8%EC%A0%9C https://velog.io/@hyeon930/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%95%95%EC%B6%95-Java","link":"/2020/05/04/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%95%95%EC%B6%95/"},{"title":"프로그래머스: 단체사진 찍기","text":"문제https://programmers.co.kr/learn/courses/30/lessons/1835 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private static final int PEOPLE_COUNT = 8;private static final String[] PEOPLE_NAMES = {&quot;A&quot;, &quot;C&quot;, &quot;F&quot;, &quot;J&quot;, &quot;M&quot;, &quot;N&quot;, &quot;R&quot;, &quot;T&quot;};private static int answer;public int solution(int n, String[] data) { answer = 0; perm(&quot;&quot;, 0, new boolean[8], data); return this.answer;}private void perm(String perm, int depth, boolean[] isVisit, String[] data) { if (depth == PEOPLE_COUNT) { if (isCondition(perm, data)) { answer++; } } for (int i = 0; i &lt; PEOPLE_COUNT; i++) { if (!isVisit[i]) { isVisit[i] = true; perm(perm + PEOPLE_NAMES[i], depth + 1, isVisit, data); isVisit[i] = false; } }}private boolean isCondition(String perm, String[] data) { boolean isCondition = true; for (int i = 0; i &lt; data.length; i++) { char[] tochar = data[i].toCharArray(); int people1 = perm.indexOf(tochar[0]); int people2 = perm.indexOf(tochar[2]); int interval = people1 &gt; people2 ? people1 - people2 - 1 : people2 - people1 - 1; int requestInterval = tochar[4] - '0'; if (tochar[3] == '=' &amp;&amp; interval != requestInterval) { isCondition = false; break; } if (tochar[3] == '&lt;' &amp;&amp; interval &gt;= requestInterval) { isCondition = false; break; } if (tochar[3] == '&gt;' &amp;&amp; interval &lt;= requestInterval) { isCondition = false; break; } } return isCondition;} 흐름 {“A”, “C”, “F”, “J”, “M”, “N”, “R”, “T”}로 나올 수 있는 문자열을 모두 만들어서 비교 위 array size 만큼 돌면서 문자열을 만드는데 이미 문자열에 포함된 문자는 추가하지 않기 위해 똑같은 size에 boolean array를 만듬 만들어서 그 boolean array의 index가 true면 이미 문자열에 추가된 문자 이므로 넘어감 문자열에 추가되지 않은 문자라면 다시 추가하지 않기 위해 boolean을 true로 변경 문자열을 이어 붙이기 위해 현재 메서드(perm)를 재귀호출 하는데 현재 문자열(perm)에 추가할 문자 (PEOPLE_NAMES[i])를 더하고, 배열 인덱스가 한 단계 깊어 졌으므로 depth를 +1 해서 호출 반복 하다가 사람 수 만큼(PEOPLE_NAMES) 들어왔으면 이 문자열이 비교와 할 문자열의 조건과 같은지 확인함 {“NF=0”, “RT&gt;2”} 이런 식으로 되어 있으므로 조건 문자열에서 먼저 0번째와 2번째를 가져와서 지금 만든 문자열에서 해당 문자들이 몇 번째에 위치해 있는지 구함 (indexOf()) 구한 값의 차를 구함 조건에서 해당 문자들의 간격이 몇인지 알기 위해 4번째 문자를 가져옴 조건 문자열에서 3번째 문자에 따라 참인지 아닌지 비교함 ‘=’ 이면서 구한 간격과 조건의 간격이 같지 않으면 false ‘&lt;’ 이면서 구한 간격이 조건의 간격보다 크거나 같으면 false ‘&gt;’ 이면서 구한 간격이 조건의 간격보다 작거나 같으면 false 모든 조건을 통과하면 경우의 수를 증가시킴 모든 문자열에 대해 비교가 끝나면 끝 부연 설명 boolean[] isVisit의 변화와 문자열이 만들어지는 과정1234567for (int i = 0; i &lt; PEOPLE_COUNT; i++) { if (!isVisit[i]) { isVisit[i] = true; perm(perm + PEOPLE_NAMES[i], depth + 1, isVisit, data); isVisit[i] = false; }} {false, false, false, false, false, false, false, false} 인 상태에서 위 반복을 돌면서 재귀로 들어감 {true, false, false, false, false, false, false, false}가 된 상태에서 perm 재귀를 타고 반복… {true, true, true, true, true, true, true, true}이 된 상태로 재귀를 빠져나옴 빠져나오면 isVisit[i] = false 때문에 마지막 7번째 index는 false로 변경되고 반복문이 끝났으므로 재귀를 빠져나옴 재귀를 나왔으니 {true, true, true, true, true, true, true, false}인 상태에서 i는 6이고 6번째 index도 false로 만듬 {true, true, true, true, true, true, false, false} 그럼 이 상태가 되고 여기서 반복문이 돌아서 i는 7이 되고 7번째 index는 true로 변경 {true, true, true, true, true, true, false, true}인 상태로 재귀에 들어가지만 depth가 8이 아니므로 다시 for문을 도는데 {true, true, true, true, true, true, false, true}인 상태이므로 여태 재귀돌면서 만들었던 문자열 마지막에 6번째 문자가 추가되게 됨 “ACFJMNT” + 6번째 index인 “R” 위 상황이 반복되면서 8자리 문자열이 계속 반복적으로 생성되고 비교됨 결과 번호 속도 테스트 1 통과 (1723.16ms, 333MB) 테스트 케이스12assertEquals(3648, test.solution(2, new String[] {&quot;N~F=0&quot;, &quot;R~T&gt;2&quot;}));assertEquals(0, test.solution(2, new String[] {&quot;M~C&lt;2&quot;, &quot;C~M&gt;1&quot;})); 참고 사이트 https://tech.kakao.com/2017/09/13/code-festival-round-2/","link":"/2020/06/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%8B%A8%EC%B2%B4%EC%82%AC%EC%A7%84-%EC%B0%8D%EA%B8%B0/"},{"title":"프로그래머스: 땅따먹기","text":"문제https://programmers.co.kr/learn/courses/30/lessons/12913 코드123456789101112int solution(int[][] land) { for (int i = land.length - 2; i &gt;= 0; i--) { int rowIndex = i + 1; land[i][0] += max(land[rowIndex][1], max(land[rowIndex][2], land[rowIndex][3])); land[i][1] += max(land[rowIndex][0], max(land[rowIndex][2], land[rowIndex][3])); land[i][2] += max(land[rowIndex][0], max(land[rowIndex][1], land[rowIndex][3])); land[i][3] += max(land[rowIndex][0], max(land[rowIndex][1], land[rowIndex][2])); } int answer = max(land[0][0], max(land[0][1], max(land[0][2], land[0][3]))); return answer;} 흐름 마지막 행 전행 부터 반복문을 시작해서 i가 0이 될 때까지 반복한다. i행의 각 인덱스에는 자기 자신의 열을 제외한 이전 행의 값 중 가장 큰 값과 자기 자신의 값을 더한 값을 저장한다. 위 과정을 반복하면 0번째 행들의 index에 계산된 값들이 할당되어 있을 테니 0 번째 행 중에서 가장 큰 값을 return한다. 끝 결과정확성 번호 속도 테스트 1 통과 (1.05ms, 51.1MB) 테스트 2 통과 (1.16ms, 52.7MB) 테스트 3 통과 (1.16ms, 50.8MB) 테스트 4 통과 (1.18ms, 53MB) 테스트 5 통과 (1.18ms, 52.7MB) 테스트 6 통과 (1.14ms, 52.9MB) 테스트 7 통과 (1.18ms, 51.4MB) 테스트 8 통과 (1.13ms, 52.7MB) 테스트 9 통과 (1.25ms, 53.3MB) 테스트 10 통과 (1.21ms, 50.7MB) 테스트 11 통과 (1.18ms, 52.4MB) 테스트 12 통과 (4.25ms, 52.5MB) 테스트 13 통과 (1.19ms, 53.2MB) 테스트 14 통과 (1.16ms, 53.1MB) 테스트 15 통과 (1.19ms, 51MB) 테스트 16 통과 (1.16ms, 52.5MB) 테스트 17 통과 (1.14ms, 55.3MB) 테스트 18 통과 (1.16ms, 52.2MB) 효율성 번호 속도 테스트 1 통과 (28.10ms, 94.3MB) 테스트 2 통과 (28.01ms, 95.7MB) 테스트 3 통과 (25.28ms, 97.6MB) 테스트 4 통과 (25.93ms, 101MB) 테스트 케이스12345678assertEquals(16, test.solution(new int[][] {{1,2,3,5},{5,6,7,8},{4,3,2,1}}));assertEquals(20, test.solution(new int[][] {{4, 3, 2, 1}, {2, 2, 2, 1}, {6, 6, 6, 4}, {8, 7, 6, 5}}));assertEquals(115, test.solution(new int[][] {{1, 2, 3, 5}, {5, 6, 7, 8}, {4, 3, 2, 1}, {100, 0, 9, 8}}));assertEquals(33, test.solution(new int[][] {{1, 2, 3, 5}, {10, 11, 12, 11}, {16, 15, 13, 13}}));assertEquals(409, test.solution(new int[][] {{1, 100, 15, 3}, {1, 2, 3, 4}, {100, 99, 98, 97}, {97, 98, 99, 100}, {4, 3, 2, 1}, {100, 100, 100, 100}, {1, 1, 1, 1}}));assertEquals(16, test.solution(new int[][] {{1, 2, 3, 4}, {5, 6, 7, 9}, {4, 3, 2, 1}}));assertEquals(125, test.solution(new int[][] {{9, 5, 2, 3}, {9, 8, 6, 7}, {8, 9, 7, 1}, {100, 9, 8, 1}}));assertEquals(20, test.solution(new int[][] {{4, 3, 2, 1}, {2, 2, 2, 1}, {6, 6, 6, 4}, {8, 7, 6, 5}}));","link":"/2020/07/07/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%95%85%EB%94%B0%EB%A8%B9%EA%B8%B0/"},{"title":"프로그래머스: 멀쩡한 사각형","text":"https://programmers.co.kr/learn/courses/30/lessons/62048?language=java 코드123456789101112public long solution(long w,long h) { long big = w &gt; h ? w : h; long small = w &gt; h ? h : w; while (small != 0) { long r = big % small; big = small; small = r; } return (w * h) - (w + h - big);} 흐름 최대 공약수를 구함 전체 사각형 수 (w * h) 에서 안 멀쩡한 사각형 수(w + h - 최대 공약수)를 뺌 끝 최대 공약수를 사용하는 이유아래 블로그에서 잘 설명 해주셨음 https://leedakyeong.tistory.com/entry/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%A9%80%EC%A9%A1%ED%95%9C-%EC%82%AC%EA%B0%81%ED%98%95-in-python https://taesan94.tistory.com/55 결과 번호 속도 테스트 1 통과 (0.76ms, 50.7MB) 테스트 2 통과 (0.81ms, 52.4MB) 테스트 3 통과 (0.75ms, 52.6MB) 테스트 4 통과 (0.70ms, 52.6MB) 테스트 5 통과 (0.82ms, 51.9MB) 테스트 6 통과 (0.80ms, 52.1MB) 테스트 7 통과 (0.85ms, 52.4MB) 테스트 8 통과 (0.86ms, 54.6MB) 테스트 9 통과 (0.72ms, 52.3MB) 테스트 10 통과 (0.73ms, 52.6MB) 테스트 11 통과 (0.74ms, 52.2MB) 테스트 12 통과 (0.58ms, 52.5MB) 테스트 13 통과 (0.51ms, 52.5MB) 테스트 14 통과 (0.60ms, 52.6MB) 테스트 15 통과 (0.53ms, 50.3MB) 테스트 16 통과 (0.61ms, 52.5MB) 테스트 17 통과 (0.61ms, 52.3MB) 테스트 18 통과 (0.80ms, 52.3MB) 테스트 케이스12345assertEquals(80, test.solution(8, 12));assertEquals(12, test.solution(5, 4));assertEquals(40, test.solution(10, 5));assertEquals(352, test.solution(17, 23));assertEquals(30467460, test.solution(3, 15233730)); 참고 사이트본문 참조","link":"/2020/04/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%A9%80%EC%A9%A1%ED%95%9C-%EC%82%AC%EA%B0%81%ED%98%95/"},{"title":"프로그래머스: 방금 그 곡","text":"문제https://programmers.co.kr/learn/courses/30/lessons/17683 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public String solution(String m, String[] musicinfos) { String answer = &quot;(None)&quot;; m = getSharpReplace(m); int maxPlayTime = 0; for (String music : musicinfos) { String[] info = music.split(&quot;,&quot;); int playTimeToMinute = getPlayTime(info[0], info[1]); String melody = getMelody(playTimeToMinute, info[3]); if (melody.contains(m)) { if (maxPlayTime &lt; playTimeToMinute) { answer = info[2]; maxPlayTime = playTimeToMinute; } } } return answer;}private String getSharpReplace(String arg) { return arg.replace(&quot;C#&quot;, &quot;1&quot;) .replace(&quot;D#&quot;, &quot;2&quot;) .replace(&quot;E#&quot;, &quot;3&quot;) .replace(&quot;F#&quot;, &quot;4&quot;) .replace(&quot;G#&quot;, &quot;5&quot;) .replace(&quot;A#&quot;, &quot;6&quot;);}private int getPlayTime(String start, String end) { LocalTime startTime = convertLocalTime(start); LocalTime endTime = convertLocalTime(end); LocalTime playTime = endTime.minusHours(startTime.getHour()).minusMinutes(startTime.getMinute()); return playTime.getHour() * 60 + playTime.getMinute();}private LocalTime convertLocalTime(String time) { String[] hourAndMinute = time.split(&quot;:&quot;); return LocalTime.of(Integer.parseInt(hourAndMinute[0]), Integer.parseInt(hourAndMinute[1]), 0);}private String getMelody(int playtime, String melody) { String sharpReplaceMelody = getSharpReplace(melody); StringBuilder sb = new StringBuilder(); char[] array = sharpReplaceMelody.toCharArray(); for (int i = 0; i &lt; playtime; i++) { sb.append(array[i % sharpReplaceMelody.length()]); } return sb.toString();} 흐름 “#”이 붙은 음계들을 유일한 값으로 치환한다. 곡 정보를 담은 musicinfos의 개수만큼 반복한다. 돌면서 “,”로 잘라 시작시간, 끝난시간, 곡 이름, 멜로디 순으로 구분하여 String array에 저장한다. 시작 시간과 끝난 시간을 LocalTime type으로 만들어서 끝난 시간에서 시작 시간을 빼서 얼마나 오래 방송 됐는지 playTime을 구한다. 곡 정보에 있는 멜로디에서도 “#”이 붙은 음계들을 1번에서 한 것과 같은 값으로 치환한다. playtime에 따라 멜로디에 음계를 추가하기 위해 멜로디를 char array로 변경한다. playtime 만큼 반복하면서 멜로디를 만든다. playtime보다 멜로디가 짧은 경우엔 지금 멜로디에 음계를 이어 붙여 playtime 길이 만큼 만든다. 멜로디가 더 긴 경우엔 playtime 만큼 자른다. 이렇게 구한 멜로디에 기억 중인 멜로디 m이 포함된다면 playtime이 가장 긴지 확인하고 곡 정보를 저장한다. 끝. 결과 번호 속도 테스트 1 통과 (1.31ms, 54.1MB) 테스트 2 통과 (1.38ms, 52.7MB) 테스트 3 통과 (3.19ms, 52.6MB) 테스트 4 통과 (1.33ms, 51.7MB) 테스트 5 통과 (1.44ms, 52.7MB) 테스트 6 통과 (1.42ms, 52.2MB) 테스트 7 통과 (2.26ms, 52.7MB) 테스트 8 통과 (2.27ms, 53.3MB) 테스트 9 통과 (2.38ms, 52.5MB) 테스트 10 통과 (2.31ms, 52MB) 테스트 11 통과 (2.24ms, 53.4MB) 테스트 12 통과 (2.03ms, 53.2MB) 테스트 13 통과 (2.27ms, 53.2MB) 테스트 14 통과 (2.23ms, 52.2MB) 테스트 15 통과 (2.19ms, 53.2MB) 테스트 16 통과 (2.22ms, 52.1MB) 테스트 17 통과 (1.78ms, 52.4MB) 테스트 18 통과 (2.22ms, 53MB) 테스트 19 통과 (2.66ms, 52.5MB) 테스트 20 통과 (2.42ms, 52.1MB) 테스트 21 통과 (2.41ms, 52.3MB) 테스트 22 통과 (3.55ms, 52.9MB) 테스트 23 통과 (3.94ms, 53.2MB) 테스트 24 통과 (2.15ms, 51.9MB) 테스트 25 통과 (1.24ms, 52.3MB) 테스트 26 통과 (1.30ms, 53.2MB) 테스트 27 통과 (1.41ms, 52.6MB) 테스트 28 통과 (1.12ms, 53.1MB) 테스트 29 통과 (12.67ms, 53.4MB) 테스트 30 통과 (13.24ms, 53.1MB) 테스트 케이스12345assertEquals(&quot;HELLO&quot;, test.solution(&quot;ABCDEFG&quot;, new String[] {&quot;12:00,12:14,HELLO,CDEFGAB&quot;, &quot;13:00,13:05,WORLD,ABCDEF&quot;}));assertEquals(&quot;FOO&quot;, test.solution(&quot;CC#BCC#BCC#BCC#B&quot;, new String[] {&quot;03:00,03:30,FOO,CC#B&quot;, &quot;04:00,04:08,BAR,CC#BCC#BCC#B&quot;}));assertEquals(&quot;WORLD&quot;, test.solution(&quot;ABC&quot;, new String[] {&quot;12:00,12:14,HELLO,C#DEFGAB&quot;, &quot;13:00,13:05,WORLD,ABCDEF&quot;}));assertEquals(&quot;(None)&quot;, test.solution(&quot;CDEFGAC&quot;, new String[] {&quot;12:00,12:06,HELLO,CDEFGA&quot;}));assertEquals(&quot;FOO&quot;, test.solution(&quot;CCB&quot;, new String[] {&quot;03:00,03:10,FOO,CCB#CCB&quot;, &quot;04:00,04:08,BAR,ABC&quot;}));","link":"/2020/11/12/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%B0%A9%EA%B8%88-%EA%B7%B8-%EA%B3%A1/"},{"title":"프로그래머스: 소수 찾기","text":"문제https://programmers.co.kr/learn/courses/30/lessons/12921 코드1234567891011121314151617181920212223public int solution(int n) { boolean[] prime = new boolean[n+1]; prime[0] = true; prime[1] = true; for (int i = 2; (i * i) &lt;= n; i++) { if (!prime[i]) { for (int j = i * 2; j &lt;= n; j += i) { prime[j] = true; } } } int answer = 0; for (boolean is : prime) { if (!is) { answer++; } } return answer;} 흐름 에라토스테네스의 체로 해결 n까지의 숫자중 0과 1은 소수가 아니므로 true 할당 2부터 루트n 까지 반복하면서 배수들에 true 할당 소수 판별한 배열 prime을 loop 돌면서 false 인 경우에만 갯수 추가 끝 부연 설명1for (int i = 2; (i * i) &lt;= n; i++) 입력받은 수 n이 합성수 인 경우 $$n = a * b​$$ 로 나타낼 수 있다.이 때 a와 b 중 큰거나 같은 수를 a, 작거나 같은 수를 b라고 가정하면 b가 a보다 작으므로 $$ a * a &gt;= a * b $$ 이고$$ n = a * b $$ 이므로, 큰 수 a의 제곱일 경우 $$ a^2&gt;=n $$ 처럼 된다.이를 치환하면 $$ a&gt;=\\sqrt{n} $$ 이 되므로 a의 최솟값은 $$ \\sqrt{n} $$ 이 된다.그리고 b는 $$ a &gt;= b $$이므로 b의 최댓값은 $$ \\sqrt{n} $$ 이 된다.고로 n이 소수가 아닌 합성수라면 a의 와 b의 합성수로 이루어 짐을 알 수 있으므로, $$ \\sqrt{n} $$ 까지만 반복하면 소수임을 판별할 수 있다. ex) 입력받은 수 n이 50일 경우 $$ \\sqrt{50} $$ = 7.071067811865475‬‬….이므로, 7.071067811865475‬‬… 을 기준으로 50의 약수 {1,2,5,10,25,50}을 나누면 b = {1, 2, 5}, a = {10, 25, 50} 이므로 b만 검사하면 50이 소수 인지 아닌지 알 수 있다. 1for (int j = i * 2; j &lt;= n; j += i) 원래는 i보다 작은 수인 경우 이미 이전에 작은 수 * i에서 삭제된 상태이므로 i * i인 게 맞으나,i의 값이 너무 클 경우 문제가 될 수 있으므로 $$ i * 2 $$ 로 설정한다.물론 이 문제에선 100만 까지로 한정되어 있으므로 $$ i * i $$ 를 해도 문제는 없다. 참고 사이트 https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4 https://blog.naver.com/loveshurt/221774410486 https://makedotworld.tistory.com/13","link":"/2020/03/28/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%86%8C%EC%88%98-%EC%B0%BE%EA%B8%B0/"},{"title":"프로그래머스: 소수 찾기(완전 탐색)","text":"문제https://programmers.co.kr/learn/courses/30/lessons/42839 코드 순열을 이용한 완전탐색으로 해결 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public int solution(String numbers) { char[] tochar = numbers.toCharArray(); int numbersLength = tochar.length; Set&lt;Integer&gt; numberSet = new HashSet&lt;Integer&gt;(); for (int i = 1; i &lt;= numbersLength; i++) { perm(tochar, 0, i, numberSet); } int answer = getPrimeCount(numberSet); return answer;}private void perm(char[] array, int depth, int length, Set&lt;Integer&gt; numberSet) { if (depth == length) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; length; i++) { sb.append(array[i]); } int number = Integer.parseInt(sb.toString()); if (number &gt; 1) { numberSet.add(number); } return; } for (int i = depth; i &lt; array.length; i++) { swap(array, i, depth); perm(array, depth + 1, length, numberSet); swap(array, i, depth); }}private void swap(char[] arrary, int i, int j) { char temp = arrary[i]; arrary[i] = arrary[j]; arrary[j] = temp;}private int getPrimeCount(Set&lt;Integer&gt; numberSet) { int result = 0; for (int i : numberSet) { boolean isPrime = true; for (int j = 2; j * j &lt;= i; j++) { if (i % j == 0) { isPrime = false; break; } } if (isPrime) { ++result; } } return result;} 흐름 [1,2,3] 배열일 경우 3 자리 수 까지 나타날 수 있으므로, numbers의 길이 만큼 반복하면서 순열을 만듬 perm() 메서드를 재귀로 돌면서 깊이 만큼 index를 스위칭하면서 순열을 만듬 ex) [1,2,3] 인 경우, 0번째와 0번째를 스왑하여 123이 되고 그 이후엔 0번째와 1번째를 스왑해서 213, 그 이후엔 0과 2를 스왑해서 321 … 이런 식으로 진행된다 돌다가 깊이랑 이번에 만들 숫자의 길이가 같으면 중복되지 않게 Set에 저장하는데 1 이하인 경우엔 소수가 아니므로 저장하지 않음 다시 swap() 해서 배열 index를 원상복귀 시킴 반복해서 모든 순열을 만든 후 해당 Set에 저장된 수들이 소수 인지 판별해서 소수면 카운트 증가시킴 끝 결과 번호 속도 테스트 1 통과 (1.06ms, 50.3MB) 테스트 2 통과 (9.99ms, 53MB) 테스트 3 통과 (0.83ms, 52.1MB) 테스트 4 통과 (7.08ms, 52.6MB) 테스트 5 통과 (23.43ms, 56MB) 테스트 6 통과 (0.91ms, 52.6MB) 테스트 7 통과 (1.13ms, 51.9MB) 테스트 8 통과 (18.16ms, 55.9MB) 테스트 9 통과 (0.96ms, 49.9MB) 테스트 10 통과 (10.37ms, 52.9MB) 테스트 11 통과 (2.51ms, 51.5MB) 테스트 12 통과 (2.16ms, 52MB) 테스트 케이스123456assertEquals(3, test.solution(&quot;17&quot;));assertEquals(2, test.solution(&quot;011&quot;));assertEquals(1, test.solution(&quot;2&quot;));assertEquals(12, test.solution(&quot;7843&quot;));assertEquals(0, test.solution(&quot;9999999&quot;));assertEquals(1336, test.solution(&quot;1276543&quot;)); 참고 사이트 순열 알고리즘에 대한 해설 https://hwan-shell.tistory.com/150","link":"/2020/05/25/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%86%8C%EC%88%98%EC%B0%BE%EA%B8%B0/"},{"title":"프로그래머스: 소수 만들기","text":"문제https://programmers.co.kr/learn/courses/30/lessons/12977 코드12345678910111213141516171819202122232425262728293031323334353637383940public int solution(int[] nums) { int answer = 0; List&lt;Long&gt; list = getSumList(nums); for (long i : list) { boolean isNotPrime = false; for (int j = 2; j * j &lt;= i; j++) { if (i % j == 0) { isNotPrime = true; break; } } if (!isNotPrime) { ++answer; } } return answer;}private List&lt;Long&gt; getSumList(int[] nums) { List&lt;Long&gt; list = new ArrayList&lt;Long&gt;(); int arrayLength = nums.length; for (int i = 0; i &lt; arrayLength; i++) { for (int j = i + 1; j &lt; arrayLength; j++) { if (j == arrayLength - 1) { break; } for (int k = j + 1; k &lt; arrayLength; k++) { list.add((long) (nums[i] + nums[j] + nums[k])); } } } return list;} 흐름 3개이므로 3중 for문으로 돌면서 경우의 수 모두 돌면서 더한 값을 list에 저장 arrayoutofrange가 발생하지 않도록 length -1 인 경우 끝냄 모든 합이 저장된 list를 돌면서 소수인지 확인함 구한 값이 소수이면 값을 증가시킴 반복이 끝나면 return 끝 결과 번호 속도 테스트 1 통과 (2.48ms, 52.7MB) 테스트 2 통과 (3.29ms, 52.2MB) 테스트 3 통과 (1.36ms, 52.4MB) 테스트 4 통과 (1.32ms, 52.8MB) 테스트 5 통과 (4.94ms, 50.4MB) 테스트 6 통과 (5.02ms, 52.3MB) 테스트 7 통과 (1.10ms, 53MB) 테스트 8 통과 (8.70ms, 52.2MB) 테스트 9 통과 (1.78ms, 52.1MB) 테스트 10 통과 (8.33ms, 52.5MB) 테스트 11 통과 (1.06ms, 52.1MB) 테스트 12 통과 (0.95ms, 52.3MB) 테스트 13 통과 (1.03ms, 50.5MB) 테스트 14 통과 (0.94ms, 52.4MB) 테스트 15 통과 (0.82ms, 50MB) 테스트 16 통과 (8.65ms, 52.8MB) 테스트 17 통과 (7.43ms, 52.4MB) 테스트 18 통과 (0.95ms, 52.9MB) 테스트 19 통과 (0.83ms, 50.3MB) 테스트 20 통과 (9.97ms, 52.5MB) 테스트 21 통과 (10.12ms, 52.6MB) 테스트 22 통과 (2.31ms, 52.3MB) 테스트 23 통과 (0.83ms, 52.1MB) 테스트 24 통과 (9.64ms, 50.8MB) 테스트 25 통과 (9.52ms, 50.5MB) 테스트 26 통과 (0.89ms, 52.1MB) 테스트 케이스12assertEquals(1, test.solution(new int[] {1,2,3,4}));assertEquals(4, test.solution(new int[] {1,2,7,6,4})); 여담당연히 속도 제한에 걸릴 줄 알고 제출했는데 통과되었다 썩 만족스럽지 못한 코드 만약 서로 다른 3개가 아니라 임의 수 n 이었다면? 고민을 좀 더 해봐야 할 듯 싶다.","link":"/2020/06/17/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%86%8C%EC%88%98-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"title":"프로그래머스: 쇠막대기","text":"문제https://programmers.co.kr/learn/courses/30/lessons/42585 코드1234567891011121314151617181920212223public int solution(String arrangement) { char[] ch = arrangement.toCharArray(); int answer = 0; char pre = 0; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (char c : ch) { if (c == '(') { stack.push(c); } else { stack.pop(); if (pre == c) { answer += 1; } else { answer += stack.size(); } } pre = c; } return answer;} 흐름 문자열을 char array로 변경 char array를 반복하면서 문자가 ‘(‘ 인지 비교 맞으면 새 막대기가 시작되야 하므로 stack에 push 함 아니라면 레이저를 발사해서 stack을 잘라야 하므로 pop 하는데 이전 pop한 문자가 똑같이 ‘)’ 이라면 하나만 더 짤린 것이므로 +1 만하고 이전 문자가 ‘)’이 아니라면 stack의 크기가 막대의 개수 이므로 stack size만큼 더함 막대를 하나만 추가할 지 판단하기 위해 현재 문자를 저장함 문자열을 모두 반복 하면 끝 결과 번호 속도 테스트 1 통과 (19.66ms, 51.2MB) 테스트 2 통과 (1.24ms, 53MB) 테스트 3 통과 (19.95ms, 51MB) 테스트 4 통과 (2.78ms, 53.1MB) 테스트 5 통과 (4.04ms, 53MB) 테스트 6 통과 (3.95ms, 52.8MB) 테스트 7 통과 (14.81ms, 52.5MB) 테스트 8 통과 (16.84ms, 52.6MB) 테스트 9 통과 (17.09ms, 52.8MB) 테스트 10 통과 (16.32ms, 52.6MB) 테스트 11 통과 (13.59ms, 52.2MB) 테스트 12 통과 (14.53ms, 50.6MB) 테스트 13 통과 (15.35ms, 52MB) 테스트 14 통과 (17.90ms, 50.4MB) 테스트 15 통과 (18.95ms, 52.3MB) 테스트 16 통과 (20.62ms, 50.7MB) 테스트 17 통과 (20.66ms, 53.1MB) 테스트 18 통과 (18.49ms, 52.8MB) 테스트 19 통과 (19.85ms, 53MB) 테스트 20 통과 (18.93ms, 52.5MB) 테스트 케이스12assertEquals(17, test.solution(&quot;()(((()())(())()))(())&quot;));assertEquals(18, test.solution(&quot;(((((((((())))))))))&quot;));","link":"/2020/06/15/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%87%A0%EB%A7%89%EB%8C%80%EA%B8%B0/"},{"title":"프로그래머스: 수식 최대화","text":"문제https://programmers.co.kr/learn/courses/30/lessons/67257 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180private static final char PLUS = '+';private static final char MINUS = '-';private static final char MULTIPLICATION = '*';public long solution(String expression) { char[] chars = expression.toCharArray(); Object[] numberAndOperator = getNumbersAndOperatorSet(chars); List&lt;Long&gt; numberList = (List&lt;Long&gt;) numberAndOperator[0]; List&lt;Character&gt; operatorList = (List&lt;Character&gt;) numberAndOperator[1]; char[] operators = getExpressionIncludeOperators(operatorList); List&lt;String&gt; operatorSetList = getOperatorSetList(operators); return getMax(numberList, operatorList, operatorSetList);}private Object[] getNumbersAndOperatorSet(char[] expression) { List&lt;Long&gt; numberList = new ArrayList&lt;&gt;(); List&lt;Character&gt; operatorList = new ArrayList&lt;&gt;(); StringBuilder sb = new StringBuilder(); for (char c : expression) { switch (c) { case PLUS: case MINUS: case MULTIPLICATION: numberList.add(Long.valueOf(sb.toString())); operatorList.add(c); sb.setLength(0); break; default: sb.append(c); break; } } numberList.add(Long.valueOf(sb.toString())); return new Object[] {numberList, operatorList};}private char[] getExpressionIncludeOperators(List&lt;Character&gt; operatorList) { Set&lt;Character&gt; set = new HashSet&lt;&gt;(); List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for (char c : operatorList) { if (set.add(c)) { list.add(c); } } char[] operators = new char[list.size()]; int i = 0; for (char c : list) { operators[i++] = c; } return operators;}private List&lt;String&gt; getOperatorSetList(char[] chars) { List&lt;String&gt; operatorSetList = new ArrayList&lt;&gt;(); Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (int i = 1; i &lt;= chars.length; i++) { perm(chars, 0, i, operatorSetList, set); } return operatorSetList;}private void perm(char[] array, int depth, int length, List&lt;String&gt; operatorList, Set&lt;String&gt; set) { if (depth == length) { StringBuilder sb = new StringBuilder(); for (char c : array) { sb.append(c); } if (set.add(sb.toString())) { operatorList.add(sb.toString()); } return; } for (int i = depth; i &lt; array.length; i++) { swap(array, i, depth); perm(array, depth + 1, length, operatorList, set); swap(array, i, depth); }}private void swap(char[] arrary, int i, int j) { char temp = arrary[i]; arrary[i] = arrary[j]; arrary[j] = temp;}private Long getMax(List&lt;Long&gt; numberList, List&lt;Character&gt; operatorList, List&lt;String&gt; operatorSetList) { long max = 0; for (String operatorSet : operatorSetList) { char[] operators = operatorSet.toCharArray(); LinkedList&lt;Long&gt; numberQueue = new LinkedList&lt;&gt;(numberList); LinkedList&lt;Character&gt; operatorQueue = new LinkedList&lt;&gt;(operatorList); for (char operatorToCalculate : operators) { Stack&lt;Long&gt; numberStack = new Stack&lt;&gt;(); Stack&lt;Character&gt; operatorStack = new Stack&lt;&gt;(); long first = numberQueue.poll(); numberStack.push(first); numberQueue.offer(first); Stack[] stacks = new Stack[] {numberStack, operatorStack}; LinkedList[] queues = new LinkedList[] {numberQueue, operatorQueue}; calculatePriority(stacks, queues, operatorToCalculate); } max = (max &gt; Math.abs(numberQueue.peek())) ? max : Math.abs(numberQueue.poll()); } return max;}private void calculatePriority(Stack[] staks, LinkedList[] queues, char operatorToCalculate) { Stack&lt;Long&gt; numberStack = staks[0]; Stack&lt;Character&gt; operatorStack = staks[1]; LinkedList&lt;Long&gt; numberQueue = queues[0]; LinkedList&lt;Character&gt; operatorQueue = queues[1]; int limit = operatorQueue.size(); for (int i = 0; i &lt; limit; i++) { long currentNumber = numberQueue.poll(); numberStack.push(currentNumber); Character currentOperator = operatorQueue.poll(); operatorStack.push(currentOperator); if (operatorStack.peek() == operatorToCalculate) { long n1 = numberStack.pop(); long n2 = numberStack.pop(); char op = operatorStack.pop(); long sum = sum(n2, n1, op); numberStack.push(sum); numberQueue.pollLast(); numberQueue.offer(sum); } else { numberQueue.offer(currentNumber); operatorQueue.offer(currentOperator); } }}private Long sum(long n2, long n1, char op) { long sum = 0; switch (op) { case '*' : sum = n2 * n1; break; case '+' : sum = n2 + n1; break; case '-' : sum = n2 - n1; break; } return sum;} 흐름 수식으로 넘어온 문자열을 숫자와 연산자로 나눈다. 연산자들을 중복되지 않게 저장한다. 문자열에 포함되어 있는 연산자들을 재귀로 반복하면서 모든 순열을 구한다. 0번째와 1번째를 교환하고 0번째와 2번째를 교환하고 하는 식으로 모든 순열을 구한다. 연산자의 개수만큼 순열로 만들어서 경우의 수를 구하기 위해 연산자가 2개인 경우엔 2! = 2개, 3개인 경우엔 3! = 6개가 된다. 모든 경우의 수를 구했으면 우선 순열의 수 만큼 반복해서 모든 경우의 수의 값을 구해야 하므로 순열의 수 만큼 반복한다. 돌면서 숫자를 담은 리스트와 연산자를 담은 리스트의 사이즈와 같은 큐를 만들고 각각 값들을 저장해서 초기화한다. 이번에 계산 할 순열(ex) * + -)을 char[]로 나눠서 그 갯수만큼 loop 돈다. 돌면서 숫자와 연산자를 저장 할 Stack를 각각 만든다. 숫자를 저장한 큐에서 하나를 꺼내서 stack에 저장하고 꺼낸 놈을 다시 큐의 맨 마지막에 저장한다. 그 후 큐의 개수만큼 loop 돌면서 큐들에서 하나씩 꺼내고 마찬가지로 스택에 저장한다. 그리고 꺼낸 연산자가 지금 계산 해야할 연산자라면 stack들에서 숫자 2개와 연산자를 pop하고 연산자에 맞게 계산해준다. 계산 한 값은 뒤에 또 그 값을 다른 값과 계산해야하므로 stack와 queue에 저장한다. 그리고 8번에서 큐에 초기값을 먼저 저장해서 큐의 맨 앞값과 큐의 맨 마지막 값이 계산된 것이므로 큐의 맨 마지막 값을 꺼낸다. 이번에 계산 할 연산자가 아니라면 지금 꺼낸 값과 연산자는 다시 큐에 저장한다. 4번부터 13번 까지를 모두 반복하면 끝 * + - 일 경우 Queue와 Stack의 변화 초기화 12LinkedList&lt;Long&gt; numberQueue = new LinkedList&lt;&gt;(numberList);LinkedList&lt;Character&gt; operatorQueue = new LinkedList&lt;&gt;(operatorList); 1 2 3 4 5 숫자 100 200 300 500 20 연산자 - * - + 숫자 초기값 저장 123long first = numberQueue.poll();numberStack.push(first);numberQueue.offer(first); 1 2 3 4 5 숫자 200 300 500 20 100 연산자 - * - + 숫자 연산자 5 4 3 2 1 100 이후 반복 12345678910111213141516171819202122for (int i = 0; i &lt; limit; i++) { long currentNumber = numberQueue.poll(); numberStack.push(currentNumber); Character currentOperator = operatorQueue.poll(); operatorStack.push(currentOperator); if (operatorStack.peek() == operatorToCalculate) { long n1 = numberStack.pop(); long n2 = numberStack.pop(); char op = operatorStack.pop(); long sum = sum(n2, n1, op); numberStack.push(sum); numberQueue.pollLast(); numberQueue.offer(sum); } else { numberQueue.offer(currentNumber); operatorQueue.offer(currentOperator); }} 1회 반복 1 2 3 4 5 숫자 300 500 20 100 200 연산자 * - + - 숫자 연산자 5 4 3 2 200 1 100 - 2회 반복 1 2 3 4 5 숫자 500 20 100 60000 연산자 - + - 숫자 연산자 5 4 3 2 60000 1 100 3회 반복 1 2 3 4 5 숫자 20 100 60000 500 연산자 + - - 숫자 연산자 5 4 3 500 2 60000 1 100 - 4회 반복 1 2 3 4 5 숫자 100 60000 500 20 연산자 - - + 숫자 연산자 5 4 20 3 500 - 2 60000 + 1 100 - 이런 식으로 반복되고 queue 크기 만큼 돌았다는건 우선 계산해야 될 연산자를 다 계산 했다는 것이므로 다시 스택을 비우고 처음부터 위 계산을 반복한다. 다시 계산해도 큐에 계산 된 값이 저장되어 있으므로 정상적으로 계산된다. 결과 번호 속도 테스트 1 통과 (1.22ms, 52.9MB) 테스트 2 통과 (1.25ms, 51.9MB) 테스트 3 통과 (1.54ms, 51.7MB) 테스트 4 통과 (1.62ms, 52.6MB) 테스트 5 통과 (1.70ms, 52.8MB) 테스트 6 통과 (1.73ms, 52.9MB) 테스트 7 통과 (1.69ms, 52.1MB) 테스트 8 통과 (1.76ms, 52.9MB) 테스트 9 통과 (1.81ms, 52.3MB) 테스트 10 통과 (1.86ms, 52.1MB) 테스트 11 통과 (1.70ms, 50.6MB) 테스트 12 통과 (1.90ms, 52.3MB) 테스트 13 통과 (2.62ms, 52.2MB) 테스트 14 통과 (2.17ms, 53.2MB) 테스트 15 통과 (2.15ms, 53.1MB) 테스트 16 통과 (1.36ms, 52.7MB) 테스트 17 통과 (1.57ms, 52.8MB) 테스트 18 통과 (1.28ms, 52.9MB) 테스트 19 통과 (1.30ms, 51.3MB) 테스트 20 통과 (1.33ms, 52.6MB) 테스트 21 통과 (1.53ms, 52.5MB) 테스트 22 통과 (1.47ms, 54.3MB) 테스트 23 통과 (1.21ms, 52.3MB) 테스트 24 통과 (2.11ms, 50.7MB) 테스트 25 통과 (2.17ms, 52.2MB) 테스트 26 통과 (1.39ms, 52.3MB) 테스트 27 통과 (2.70ms, 53MB) 테스트 28 통과 (1.74ms, 52.6MB) 테스트 29 통과 (1.59ms, 50.4MB) 테스트 30 통과 (1.58ms, 50.2MB) 테스트 케이스12assertEquals(60420, test.solution(&quot;100-200*300-500+20&quot;));assertEquals(300, test.solution(&quot;50*6-3*2&quot;));","link":"/2020/07/06/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%88%98%EC%8B%9D-%EC%B5%9C%EB%8C%80%ED%99%94/"},{"title":"프로그래머스: 숫자 야구","text":"문제https://programmers.co.kr/learn/courses/30/lessons/42841 직접 플레이 해보기 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283private static final int BEGIN_INDEX = 123;private static final int END_INDEX = 987;public int solution(int[][] baseball) { List&lt;String&gt; allNumber = getAllNumber(); int answer = 0; for (int i = 0; i &lt; allNumber.size(); i++) { if (isAnswer(baseball, allNumber.get(i).toCharArray())) { ++answer; } } return answer;}private List&lt;String&gt; getAllNumber() { List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int i = BEGIN_INDEX; i &lt;= END_INDEX; i++) { char[] tochar = String.valueOf(i).toCharArray(); if (tochar[0] == tochar[1] || tochar[0] == tochar[2] || tochar[1] == tochar[2]) { continue; } if (tochar[0] == '0' || tochar[1] == '0' || tochar[2] == '0') { continue; } list.add(new String(tochar)); } return list;}private boolean isAnswer(int[][] baseball, char[] number) { boolean isAnswer = true; for (int i = 0; i &lt; baseball.length; i++) { char[] requestBall = String.valueOf(baseball[i][0]).toCharArray(); int[] strikeAndBall = getStrikeAndBall(requestBall, number); if (baseball[i][1] != strikeAndBall[0] || baseball[i][2] != strikeAndBall[1]) { isAnswer = false; break; } } return isAnswer;}private int[] getStrikeAndBall(char[] requestBall, char[] number) { int strike = 0; int ball = 0; for (int i = 0; i &lt; 3; i++) { if (number[i] == requestBall[i]) { ++strike; } if (isBall(requestBall, number[i])) { ++ball; } } ball -= strike; return new int[] {strike, ball};}private boolean isBall(char[] requestBall, char number) { boolean isBall = false; for (int i = 0; i &lt; 3; i++) { if (number == requestBall[i]) { isBall = true; break; } } return isBall;} 흐름 숫자 야구에서 나올 수 있는 모든 숫자를 구함(123~987) 구할 때 같은 숫자가 중복 될 수 없고 0이 들어갈 수 없으므로 확인해서 continue 구한 숫자들의 갯수만큼 돌면서 가능한 숫자인지 확인하는데 우선 나올 수 있는 모든 수 중 하나씩 돌면서 그 수와 배열로 받은 상대 수를 비교 받은 수와 뽑은 수를 한 자리씩 비교하면서 자리도 같고 숫자도 같으면 스트라이크 자리는 틀리지만 뽑은 수가 받은 수 안에 포함되어 있으면 볼로 처리 스트라이크이면서 볼인 경우는 있을 수 없기 때문에 볼에서 스트라이크의 갯수를 뻄 구한 스트라이크와 볼의 개수를 받은 수의 스트라이크와 볼 수와 비교해서 둘 중 하나도 같지 않으면 false를 저장하고 반복문을 빠져 나오고 조건에 맞다면 정답의 갯수를 증가 시킴 반복문이 끝나면 정답 갯수 return 끝 결과 번호 속도 테스트 1 통과 (3.49ms, 52.4MB) 테스트 2 통과 (4.55ms, 50.7MB) 테스트 3 통과 (3.33ms, 52.6MB) 테스트 4 통과 (3.48ms, 52MB) 테스트 5 통과 (4.26ms, 50.4MB) 테스트 6 통과 (4.69ms, 52.5MB) 테스트 7 통과 (3.68ms, 50.8MB) 테스트 8 통과 (4.35ms, 52.3MB) 테스트 9 통과 (3.60ms, 52.7MB) 테스트 10 통과 (3.33ms, 50.3MB) 테스트 케이스12assertEquals(2, test.solution(new int[][] {{123, 1, 1}, {356, 1, 0}, {327, 2, 0}, {489, 0, 1}}));assertEquals(2, test.solution(new int[][] {{659, 0, 1}, {264, 1, 1}, {126, 1, 2}})); 참고 사이트 https://gurumee92.tistory.com/180","link":"/2020/06/23/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%88%AB%EC%9E%90-%EC%95%BC%EA%B5%AC/"},{"title":"프로그래머스: 압축","text":"문제https://programmers.co.kr/learn/courses/30/lessons/17684 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768private static final int CAPITAL_A = 65;private static final Character LAST_INIT_ALPHABET = 'Z';public int[] solution(String msg) { int[] answer = getDictionaryIndex(msg.toCharArray(), initIndexMap()); return answer;}private Map&lt;String, Integer&gt; initIndexMap() { Map&lt;String, Integer&gt; indexMap = new HashMap&lt;&gt;(); Character start = CAPITAL_A; int i = 1; while (start &lt;= LAST_INIT_ALPHABET) { indexMap.put(String.valueOf(start), i); ++start; ++i; } return indexMap;}private int[] getDictionaryIndex(char[] charArray, Map&lt;String, Integer&gt; indexMap) { int i = 0; int arrayLength = charArray.length; int lastIndex = indexMap.get(String.valueOf(LAST_INIT_ALPHABET)); List&lt;Integer&gt; answer = new ArrayList&lt;&gt;(); while (i &lt; arrayLength) { StringBuilder sb = new StringBuilder(); int value = 0; int jump = 0; for (int j = i; j &lt; arrayLength; j++) { sb.append(charArray[j]); String key = sb.toString(); if (indexMap.containsKey(key)) { value = indexMap.get(key); jump++; if (j +1 == arrayLength) { answer.add(value); i += jump; } continue; } answer.add(value); i += jump; break; } if (!indexMap.containsKey(sb.toString())) { indexMap.put(sb.toString(), ++lastIndex); } sb.setLength(0); } return answer.stream().mapToInt(index -&gt; index).toArray();} 흐름 A부터 Z를 Key로 하는 Map을 만든다. 압축 할 문자열의 길이만큼 반복한다. 돌면서 현재 문자가 Map에 key에 포함되는지 확인한다. 이미 포함되어 있으면(처음엔 A~Z) 해당 문자의 index를 뽑아내기 위해 value를 꺼내서 저장한다. 이번 문자는 포함되어 있으므로 그 다음 문자열의 index까지 점프하기 위해 jump 변수를 증가시킨다. 현재 문자가 문자열의 마지막 문자라면 더 이상 사전에서 검색 할 수 없으므로, 문자열의 index 즉, value를 List에 저장하고 i를 jump 만큼 더해서 문자열의 index를 증가시킨다. 이미 사전에 있는 문자이므로 continue해서 끝내지 않고 반복문을 올라가서 문자를 더한다. A가 포함되어 있으면 A 뒤문자인 B를 더해서 AB가 존재하는지 찾기 위해 사전에 포함되어 있지 않는다면(Map에 key로 존재하지 않는다면) 이전에 검색했던 문자의 index를 저장하고 i를 jump 시킨 후 반복문을 벗어난다. 그 후 사전에 존재 하지 않았던 문자를 사전에 등록, Map에 key, lastIndex에서 + 1해서 Map에 추가하고, 문자를 저장했던 StringBuilder를 초기화 시킨다. 문자열 모두 검색 할 때까지 반복한다. 사전에서 검색한 index를 저장한 List를 array로 변경한 후 return 한다. 끝. 결과 번호 속도 테스트 1 통과 (6.64ms, 53MB) 테스트 2 통과 (6.30ms, 52.9MB) 테스트 3 통과 (5.29ms, 50.3MB) 테스트 4 통과 (9.62ms, 53MB) 테스트 5 통과 (5.94ms, 51.1MB) 테스트 6 통과 (10.26ms, 52.8MB) 테스트 7 통과 (7.65ms, 51MB) 테스트 8 통과 (8.38ms, 52.8MB) 테스트 9 통과 (6.01ms, 52.5MB) 테스트 10 통과 (11.33ms, 53MB) 테스트 11 통과 (8.25ms, 51.6MB) 테스트 12 통과 (8.79ms, 51.3MB) 테스트 13 통과 (9.26ms, 53.6MB) 테스트 14 통과 (9.22ms, 51.5MB) 테스트 15 통과 (10.26ms, 53MB) 테스트 16 통과 (8.91ms, 53.5MB) 테스트 17 통과 (10.89ms, 53.2MB) 테스트 18 통과 (7.93ms, 53.2MB) 테스트 19 통과 (8.32ms, 53.1MB) 테스트 20 통과 (8.10ms, 50.8MB) 테스트 케이스1234assertArrayEquals(new int[] {11, 1, 27, 15}, test.solution(&quot;KAKAO&quot;));assertArrayEquals(new int[] {20, 15, 2, 5, 15, 18, 14, 15, 20, 27, 29, 31, 36, 30, 32, 34}, test.solution(&quot;TOBEORNOTTOBEORTOBEORNOT&quot;));assertArrayEquals(new int[] {1, 2, 27, 29, 28, 31, 30}, test.solution(&quot;ABABABABABABABAB&quot;));assertArrayEquals(new int[] {20, 8, 1, 20, 27, 29, 9, 19, 33, 31, 30, 28, 20, 33, 14, 15, 39, 19, 41, 43, 36, 9, 39, 46, 38, 47, 34, 19, 36, 52, 45, 40, 42, 35, 38, 48, 62, 54, 51, 61, 53, 55, 66, 57, 44, 59, 64, 32, 49, 60, 29, 52, 76, 37, 32, 71, 43, 70, 47, 75, 73, 80, 43, 79, 56, 72, 84, 61, 86, 68, 81, 90, 69, 92, 72, 85, 63, 96, 89, 87, 91, 83, 101, 94, 103, 65, 97, 106, 99, 108, 50, 74, 111, 77, 66, 98, 81, 70, 93, 118, 117, 88, 33, 122, 116, 58, 127, 62, 127, 78, 114, 123, 100, 133, 95, 112, 105, 104, 132, 145, 87, 134, 130, 129, 137, 131, 82, 79, 148, 151, 150, 144, 153, 159, 102, 135, 121, 156, 159, 125, 75, 162, 113, 158, 124, 109, 126, 149, 67, 142, 146, 166, 155, 158, 174, 171, 140, 119, 128, 175, 120, 138, 152, 161, 174, 181, 139, 154, 141, 187, 143, 176, 165, 172, 167, 191, 164, 182, 194, 184, 136, 170, 193, 147, 86}, test.solution(&quot;THATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITISTHATTHATISISTHATTHATISNOTISNOTISTHATITITIS&quot;)); 여담 코드의 퀄리티가 썩 마음에 들지 않는다. 시간 날 때 리팩토링을 꼭 해야 할 듯 싶다.","link":"/2020/08/06/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%95%95%EC%B6%95/"},{"title":"프로그래머스: 실패율","text":"문제https://programmers.co.kr/learn/courses/30/lessons/42889 소스1234567891011121314151617181920212223242526272829public int[] solution(int N, int[] stages) { int[] failUsers = new int[N+2]; for (int stage : stages) { failUsers[stage] += 1; } Map&lt;Integer, Double&gt; map = new HashMap&lt;Integer, Double&gt;(); double userCount = stages.length; for (int i = 1; i &lt;= N; i++) { double value = 0.0; if (failUsers[i] != 0 &amp;&amp; userCount != 0) { value = (failUsers[i] / userCount) * 100; userCount -= failUsers[i]; } map.put(i, value); } List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(map.keySet()); Collections.sort(list, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return map.get(o2).compareTo(map.get(o1)); } }); int[] answer = list.stream().mapToInt(i -&gt; i).toArray(); return answer;} 흐름 유저 수(stages.length) 만큼 loop 돌면서 각 stage 별로 실패한 유저 수를 array에 저장한다. 스테이지별로 틀린 인원 수를 저장히기 위한 Map 변수를 하나 생성하고, 스테이지 수(N) 만큼 loop 돌면서 해당 스테이지에 실패한 사람이 있으면서, 전체 시도한 사람이 0명이 아닌 경우, $$ 해당 스테이지에서 실패한 유저 수 / 해당 스테이지에 도전한 유저 수 * 100 $$ 해서 해당 스테이지의 실패율을 구한다. 이 때 스테이지에 도전한 유저 수는 이전 스테이지를 성공한 사람들 만이다. 이번 스테이지에서 실패한 유저들은 다음 스테이지에 도전 할 수 없으므로, 총 유저 수에서 실패한 유저 수를 제한다. 위에서 선언한 Map 변수에 key를 스테이지 번호로, value를 실패율로 하여 put 한다. 실패율을 저장한 Map을 Value 기준으로 내림차순 정렬을 한다. ArrayList를 int[]로 변환한다. stream에 경우 속도가 느리므로, loop를 돌면서 직접 int[]로 만드는 방법이 퍼포먼스에 더 이로울 듯 하다. 끝 결과 번호 속도 테스트 1 통과 (7.39ms, 52.6MB) 테스트 2 통과 (6.26ms, 54.7MB) 테스트 3 통과 (11.14ms, 54.2MB) 테스트 4 통과 (12.53ms, 58.2MB) 테스트 5 통과 (13.17ms, 63.3MB) 테스트 6 통과 (12.28ms, 52.3MB) 테스트 7 통과 (9.12ms, 53.5MB) 테스트 8 통과 (11.79ms, 58.6MB) 테스트 9 통과 (13.39ms, 61.4MB) 테스트 10 통과 (11.68ms, 55.8MB) 테스트 11 통과 (12.76ms, 59.8MB) 테스트 12 통과 (11.43ms, 60MB) 테스트 13 통과 (12.27ms, 62.7MB) 테스트 14 통과 (5.77ms, 54.3MB) 테스트 15 통과 (10.07ms, 54MB) 테스트 16 통과 (9.50ms, 55.6MB) 테스트 17 통과 (7.79ms, 53.4MB) 테스트 18 통과 (9.16ms, 54.8MB) 테스트 19 통과 (6.27ms, 52.8MB) 테스트 20 통과 (7.16ms, 53.2MB) 테스트 21 통과 (8.94ms, 55.3MB) 테스트 22 통과 (12.98ms, 62.7MB) 테스트 23 통과 (11.22ms, 58MB) 테스트 24 통과 (17.40ms, 59.7MB) 테스트 25 통과 (6.25ms, 52.9MB) 테스트 26 통과 (6.00ms, 52.3MB) 테스트 27 통과 (5.83ms, 50.4MB) 테스트 케이스123456assertArrayEquals(new int[] {3,4,2,1,5}, test.solution(5, new int[] {2, 1, 2, 6, 2, 4, 3, 3}));assertArrayEquals(new int[] {4,1,2,3}, test.solution(4, new int[] {4,4,4,4,4}));assertArrayEquals(new int[] {2,1,3,4}, test.solution(4, new int[] {1,1,1,1,2}));assertArrayEquals(new int[] {4,2,3,1}, test.solution(4, new int[] {3,2,5,4,2}));assertArrayEquals(new int[] {7,6,2,3,5,4,1}, test.solution(7, new int[] {2, 1, 2, 6, 2, 4, 3, 3,7,5}));assertArrayEquals(new int[] {1,2,3,4,5}, test.solution(5, new int[] {})); Junit5로 테스트 했음. 프로그래머스에서 제공하는 모든 케이스에 대한 것이 아니라,필자가 마음대로 넣은 것 이므로 이 소스를 통과하여도 프로그래머스에선 통과되지 못할 수 있음. 다른 멋진 분들의 해결방법 https://velog.io/@dion/programmers-42889-algorithm-solution https://jayrightthere.tistory.com/entry/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%8B%A4%ED%8C%A8%EC%9C%A8","link":"/2020/04/09/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%8B%A4%ED%8C%A8%EC%9C%A8/"},{"title":"프로그래머스: 오픈채팅방","text":"문제https://programmers.co.kr/learn/courses/30/lessons/42888 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private static final String ENTER = &quot;Enter&quot;;private static final String LEAVE = &quot;Leave&quot;;private static final String CHANGE = &quot;Change&quot;;private static final String MESSAGE_ENTER = &quot;님이 들어왔습니다.&quot;;private static final String MESSAGE_LEAVE = &quot;님이 나갔습니다.&quot;;public String[] solution(String[] record) { List&lt;String[]&gt; list = new ArrayList&lt;&gt;(); Map&lt;String, String&gt; nickName = new HashMap&lt;&gt;(); int returnArraySize = 0; for (String s : record) { String[] split = s.split(&quot; &quot;); String[] actionAndUid = new String[3]; actionAndUid[0] = split[0]; actionAndUid[1] = split[1]; if (!CHANGE.equals(split[0])) { list.add(actionAndUid); returnArraySize++; } if (!LEAVE.equals(split[0])) { nickName.put(split[1], split[2]); } } String[] answer = new String[returnArraySize]; int i = 0; for (String[] array : list) { switch (array[0]) { case ENTER : answer[i] = nickName.get(array[1]) + MESSAGE_ENTER; break; case LEAVE : answer[i] = nickName.get(array[1]) + MESSAGE_LEAVE; break; } i++; } return answer;} 흐름 문자열을 공백으로 나눠서 행동과 유저의 아이디를 저장하는 배열에 담는다. 행동이 Change가 아닌 경우엔 채팅방에 입장했거나 나갓다는 문구룰 출력해야 하기 때문에 List에 담는다. 행동이 Leave가 아닌 경우엔 닉네임이 변경되었거나, 새로 방에 들어온 것이므로 유저 아이디를 key로하는 map에 value로 닉네임을 저장한다. 모두 저장했으면 List만큼 돌면서 해당 행동에 맞는 문자열을 만들어 저장한다. 끝 결과 번호 속도 테스트 1 통과 (18.70ms, 54.1MB) 테스트 2 통과 (17.35ms, 52.4MB) 테스트 3 통과 (17.84ms, 54.4MB) 테스트 4 통과 (19.81ms, 54MB) 테스트 5 통과 (27.75ms, 56.1MB) 테스트 6 통과 (30.38ms, 56.1MB) 테스트 7 통과 (35.26ms, 54.4MB) 테스트 8 통과 (27.59ms, 55.2MB) 테스트 9 통과 (30.72ms, 56.5MB) 테스트 10 통과 (28.67ms, 56.1MB) 테스트 11 통과 (25.16ms, 56.2MB) 테스트 12 통과 (26.04ms, 56.6MB) 테스트 13 통과 (26.07ms, 55MB) 테스트 14 통과 (43.84ms, 57.2MB) 테스트 15 통과 (20.35ms, 52.4MB) 테스트 16 통과 (18.03ms, 52.8MB) 테스트 17 통과 (19.77ms, 54.2MB) 테스트 18 통과 (18.86ms, 52.5MB) 테스트 19 통과 (35.94ms, 56.7MB) 테스트 20 통과 (26.22ms, 55.5MB) 테스트 21 통과 (30.18ms, 56.5MB) 테스트 22 통과 (28.53ms, 52.5MB) 테스트 23 통과 (29.40ms, 57.5MB) 테스트 24 통과 (37.73ms, 57.3MB) 테스트 25 통과 (262.95ms, 158MB) 테스트 26 통과 (292.57ms, 158MB) 테스트 27 통과 (333.29ms, 169MB) 테스트 28 통과 (324.94ms, 163MB) 테스트 29 통과 (282.87ms, 157MB) 테스트 30 통과 (286.21ms, 153MB) 테스트 31 통과 (225.37ms, 147MB) 테스트 32 통과 (255.96ms, 137MB) 테스트 케이스123String[] actual = {&quot;Enter uid1234 Muzi&quot;, &quot;Enter uid4567 Prodo&quot;,&quot;Leave uid1234&quot;,&quot;Enter uid1234 Prodo&quot;,&quot;Change uid4567 Ryan&quot;};String[] expected ={&quot;Prodo님이 들어왔습니다.&quot;, &quot;Ryan님이 들어왔습니다.&quot;, &quot;Prodo님이 나갔습니다.&quot;, &quot;Prodo님이 들어왔습니다.&quot;};assertArrayEquals(expected, test.solution(actual));","link":"/2020/07/19/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%98%A4%ED%94%88%EC%B1%84%ED%8C%85%EB%B0%A9/"},{"title":"프로그래머스: 숫자의 표현","text":"문제https://programmers.co.kr/learn/courses/30/lessons/12924 코드삽질 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546public int solution(int n) { int answer = 0; int[] sumArray = new int[n + 1]; Queue&lt;Integer&gt; queue = initQueue(n); int sum = 0; for (int i = 1; i &lt; n + 1; i++) { sum += i; sumArray[i] = sum; if (sum == n) { ++answer; int nextValue = i+1; while (!queue.isEmpty()) { int sumValue = sumArray[queue.peek()]; if (nextValue &lt;= sumValue) { i = queue.peek(); sum = 0; break; } queue.poll(); } } else if (sum &gt; n) { int value = sum - n; while (!queue.isEmpty()) { int sumValue = sumArray[queue.peek()]; if (value &lt;= sumValue) { i = queue.poll(); sum = 0; break; } queue.poll(); } } } return answer;} 합계를 저장 할 array와 배열의 index를 저장 할 queue를 생성하고 queue에 index를 순서대로 할당해놓는다. i를 증가 시키면서 sum을 저장하고 sum == n 이 되면 answer을 증가시키고, 그 다음 index의 값을 구해서 그 다음 값 만큼 이전에 더한 값들을 빼고 뺀 값 다음 index부터 실행하기 위해 index를 queue에서 가져온다. 1 + 2 + 3 + 4 + 5 = 15 였으면 다음 값은 6 이므로 6을 만큼을 빼기 위해 1, 2 3을 뺀다. sum이 n보다 크다면 sum에서 n을 뺀 값 만큼 더했던 값에서 빼고 뺀 값 다음 index부터 실행하기 위해 index를 queue에서 가져온다. 5 + 6 + 7 = 18 이므로 15를 뺀 3보다 크거나 같은 값을 앞에서부터 빼야되는데 5는 이미 3보다 크므로 5를 queue에서 poll해서 뺀다. 위를 반복해서 연속된 자연수의 개수를 구한다. 끝 숫자가 커지면 반복 할 때 효율성에서 걸릴까 싶어서 큐도쓰고 해봤는데 보기도 안좋고 속도도 안좋고 모든 면에서 안좋았다 정석 코드12345678910111213141516171819public int solution(int n) { int answer = 0; for(int i = 1; i &lt;= (n / 2) ; i++) { int sum = 0; int index = i; while (sum &lt; n) { sum += index; ++index; } if (sum == n) { ++answer; } } return answer + 1;} n의 절반을 넘어가면 그 이상 더 해봤자 n을 넘어가므로 n / 2까지만 반복한다. sum이 n 보다 작으면 반복해서 sum에 index를 증가시켜 가며 더한다. sum이 n보다 작지 않아지면 빠져나와서 sum == n이 판단하고 같으면 answer을 증가시킨다. 마지막에 자기자신이 들어가므로 + 1을 하고 return한다. 결과뻘짓 코드정확성 번호 속도 테스트 1 통과 (1.02ms, 52.4MB) 테스트 2 통과 (2.01ms, 50.3MB) 테스트 3 통과 (1.64ms, 52.5MB) 테스트 4 통과 (1.83ms, 50.7MB) 테스트 5 통과 (1.13ms, 52.5MB) 테스트 6 통과 (0.95ms, 52.5MB) 테스트 7 통과 (1.68ms, 52.3MB) 테스트 8 통과 (1.41ms, 50.1MB) 테스트 9 통과 (0.93ms, 50MB) 테스트 10 통과 (2.25ms, 52.8MB) 테스트 11 통과 (2.15ms, 50.5MB) 테스트 12 통과 (1.78ms, 52.6MB) 테스트 13 통과 (1.86ms, 52MB) 테스트 14 통과 (1.68ms, 52.7MB) 효율성 번호 속도 테스트 1 통과 (9.68ms, 52.5MB) 테스트 2 통과 (6.16ms, 52.2MB) 테스트 3 통과 (7.96ms, 52MB) 테스트 4 통과 (7.72ms, 51MB) 테스트 5 통과 (8.29ms, 50.6MB) 테스트 6 통과 (10.67ms, 52.4MB) 정석 코드정확성 번호 속도 테스트 1 통과 (0.77ms, 50.2MB) 테스트 2 통과 (0.94ms, 50.6MB) 테스트 3 통과 (0.81ms, 50.4MB) 테스트 4 통과 (0.86ms, 51MB) 테스트 5 통과 (0.80ms, 52.1MB) 테스트 6 통과 (0.77ms, 52.2MB) 테스트 7 통과 (0.90ms, 52.5MB) 테스트 8 통과 (0.84ms, 52.4MB) 테스트 9 통과 (0.69ms, 50.2MB) 테스트 10 통과 (0.87ms, 52.2MB) 테스트 11 통과 (0.91ms, 52.1MB) 테스트 12 통과 (0.89ms, 52.3MB) 테스트 13 통과 (0.79ms, 50.4MB) 테스트 14 통과 (0.84ms, 50.2MB) 효율성 번호 속도 테스트 1 통과 (1.48ms, 52.9MB) 테스트 2 통과 (1.12ms, 52.2MB) 테스트 3 통과 (1.21ms, 50.8MB) 테스트 4 통과 (1.28ms, 50MB) 테스트 5 통과 (1.52ms, 50.1MB) 테스트 6 통과 (1.50ms, 52.3MB) 테스트 케이스123456789101112131415assertEquals(4, test.solution(15));assertEquals(2, test.solution(20));assertEquals(4, test.solution(30));assertEquals(2, test.solution(106));assertEquals(2, test.solution(1567));assertEquals(1, test.solution(16));assertEquals(4, test.solution(782));assertEquals(5, test.solution(10000));assertEquals(12, test.solution(9999));assertEquals(4, test.solution(7787));assertEquals(8, test.solution(4578));assertEquals(2, test.solution(1234));assertEquals(1, test.solution(1));assertEquals(2, test.solution(5));assertEquals(3, test.solution(49)); P.S주어진 자연수를 연속된 자연수의 합으로 표현하는 방법의 수는 주어진 수의 홀수 약수의 개수와 같다. 이 문제의 최다 좋아요를 받은 코드는 위의 정수론 정리를 이용한 풀이가 있는데 정의의 출처를 찾지 못했다. 해당 정의를 가지고 푼 코드가 가장 짧고 가장 빠르게 실행된다. 한참 멀었구나 싶다.","link":"/2020/06/28/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%88%AB%EC%9E%90%EC%9D%98-%ED%91%9C%ED%98%84/"},{"title":"프로그래머스: 예상 대진표","text":"","link":"/2020/07/30/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%98%88%EC%83%81-%EB%8C%80%EC%A7%84%ED%91%9C/"},{"title":"프로그래머스: 전화번호 목록","text":"문제https://programmers.co.kr/learn/courses/30/lessons/42577 코드1234567891011121314151617public boolean solution(String[] phone_book) { int length = phone_book.length; for (int i = 0; i &lt; length; i++) { for (int j = 0; j &lt; length; j++) { if (i == j) { continue; } if (phone_book[j].startsWith(phone_book[i])) { return false; } } } boolean answer = true; return answer;} 흐름 배열을 전부 돌면서 해당 인덱스로 시장하는 단어가 있는 지 확인함 끝 결과 번호 속도 테스트 1 통과 (0.78ms, 52.1MB) 테스트 2 통과 (0.52ms, 50.1MB) 테스트 3 통과 (0.65ms, 52.6MB) 테스트 4 통과 (0.51ms, 54.6MB) 테스트 5 통과 (0.55ms, 52.2MB) 테스트 6 통과 (0.66ms, 52.5MB) 테스트 7 통과 (0.87ms, 50.3MB) 테스트 8 통과 (0.77ms, 52.8MB) 테스트 9 통과 (0.64ms, 52.3MB) 테스트 10 통과 (0.57ms, 50.3MB) 테스트 11 통과 (0.65ms, 52.8MB) 효율성 테스트 번호 속도 테스트 1 통과 (1.96ms, 60.3MB) 테스트 2 통과 (2.14ms, 59.8MB) 테스트 케이스123assertFalse(test.solution(new String[] {&quot;119&quot;, &quot;97674223&quot;, &quot;1195524421&quot;} ));assertTrue(test.solution(new String[] {&quot;123&quot;,&quot;456&quot;,&quot;789&quot;} ));assertFalse(test.solution(new String[] {&quot;12&quot;,&quot;123&quot;,&quot;1235&quot;,&quot;567&quot;,&quot;88&quot;} )); 여담 사실 당연히 시간 초과로 안될 줄 알았는데 넘어가서 놀랐다. 찾아보니 Trie 자료구조로 해결하길 바래서 카테고리가 해쉬 인 듯 싶다. 하지만 쉽게 풀 수 있는 문제를 어렵게 풀 이유가 없으니 이 문제는 이렇게 마무리 하려한다.","link":"/2020/05/12/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A0%84%ED%99%94%EB%B2%88%ED%98%B8-%EB%AA%A9%EB%A1%9D/"},{"title":"프로그래머스: 위장","text":"문제https://programmers.co.kr/learn/courses/30/lessons/42578 코드1234567891011121314151617181920public int solution(String[][] clothes) { Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); for (String[] s : clothes) { int value = 1; String key = s[1]; if (map.containsKey(key)) { value = map.get(key); } map.put(key, ++value); } int answer = 1; for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) { answer *= entry.getValue(); } return answer - 1;} 흐름 [[“yellow_hat”, “headgear”], [“blue_sunglasses”, “eyewear”], [“green_turban”, “headgear”]], clothes안에 이런 식으로 옷이름, 종류 로 저장되어 있으므로 chothes 크기 만큼 반복하면서 옷 종류를 꺼냄 옷 종류를 key로 하는 Map이 있는 지 확인 있으면 값을 증겨 시켜야 하므로 value를 꺼내옴 ++해서 값을 증가 시켜서 저장하고, 없으면 해당 key로 새로 저장 순열과 조합 공식을 바탕으로 value를 모두 곱함 문제에서 최소 1 개의 옷은 입는다고 하였으므로, 옷을 모두 안입는 경우를 제외하기 위해 -1을 함 끝 조합 공식Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing 서로 다른 n개의 원소에서 순서에 상관없이 r개를 뽑을 때, 이를 n개에서 r개를 택하는 조합이라고 한다. 이 조합은 순열과 다른 개념으로 순서 차이가 중요하다. 조합나무위키 $$ nCr = nPr / r! = n! / (n-r)!r! $$ 이 공식으로 위 문제를 풀어보면 헤어 2개, 안경 1개 이므로 헤어 2개에서는 입을경우, 안 입을 경우 2 가지이고 이를 수식으로 표현하면 0개를 뽑는 경우 = $$ 2C0 = 2P0 / 0! = 2! / (2-0)!0! = 2 / 2 = 1 $$ 이 되고, 나머지의 경우도 계산하면 $$ 1 + 2 = 3 $$ 이 된다. 안경도 마찬가지로 입을 경우, 안 입을 경우 2 가지로 $$ 1C0 + 1C1 = 1 + 1 = 2 $$ 가 되고 마지막으로 둘 다 안 입는 경우는 없으므로 -1을 하면 $$ 3 * 2 - 1 = 5 $$가 된다 다른 분의 코드1234567public int solution(String[][] clothes) { return Arrays.stream(clothes) .collect(groupingBy(p -&gt; p[1], mapping(p -&gt; p[0], counting()))) .values() .stream() .collect(reducing(1L, (x, y) -&gt; x * (y + 1))).intValue() - 1;} 람다식 대박 결과1번 번호 속도 테스트 1 통과 (0.93ms, 50.5MB) 테스트 2 통과 (0.85ms, 51.9MB) 테스트 3 통과 (0.86ms, 51.9MB) 테스트 4 통과 (0.93ms, 52.8MB) 테스트 5 통과 (0.80ms, 52MB) 테스트 6 통과 (0.88ms, 50.5MB) 테스트 7 통과 (0.84ms, 52.2MB) 테스트 8 통과 (0.85ms, 52.8MB) 테스트 9 통과 (0.86ms, 51.9MB) 테스트 10 통과 (0.87ms, 52.2MB) 테스트 11 통과 (0.89ms, 52.4MB) 테스트 12 통과 (0.82ms, 51.9MB) 테스트 13 통과 (0.81ms, 52.3MB) 테스트 14 통과 (0.75ms, 51.9MB) 테스트 15 통과 (0.82ms, 50.5MB) 테스트 16 통과 (0.91ms, 50.5MB) 테스트 17 통과 (0.90ms, 52.5MB) 테스트 18 통과 (0.88ms, 52.1MB) 테스트 19 통과 (0.88ms, 51.8MB) 테스트 20 통과 (0.90ms, 52.4MB) 테스트 21 통과 (0.80ms, 52.9MB) 테스트 22 통과 (0.86ms, 51.6MB) 테스트 23 통과 (0.80ms, 50.7MB) 테스트 24 통과 (0.90ms, 50.3MB) 테스트 25 통과 (0.90ms, 52.3MB) 테스트 26 통과 (0.93ms, 52.1MB) 테스트 27 통과 (0.86ms, 52.3MB) 테스트 28 통과 (0.90ms, 50.1MB) 2번 번호 속도 테스트 1 통과 (14.41ms, 53.2MB) 테스트 2 통과 (12.19ms, 52.8MB) 테스트 3 통과 (12.05ms, 52.9MB) 테스트 4 통과 (13.03ms, 50.9MB) 테스트 5 통과 (14.21ms, 50.9MB) 테스트 6 통과 (12.85ms, 51MB) 테스트 7 통과 (13.19ms, 50.9MB) 테스트 8 통과 (13.32ms, 53.6MB) 테스트 9 통과 (13.37ms, 53.1MB) 테스트 10 통과 (12.58ms, 53.2MB) 테스트 11 통과 (12.34ms, 52.7MB) 테스트 12 통과 (13.69ms, 52.4MB) 테스트 13 통과 (13.19ms, 52.7MB) 테스트 14 통과 (12.48ms, 51.1MB) 테스트 15 통과 (11.82ms, 52.5MB) 테스트 16 통과 (12.63ms, 52.7MB) 테스트 17 통과 (13.37ms, 53.1MB) 테스트 18 통과 (13.54ms, 53.1MB) 테스트 19 통과 (13.20ms, 50.7MB) 테스트 20 통과 (13.11ms, 52.7MB) 테스트 21 통과 (12.80ms, 52.6MB) 테스트 22 통과 (13.48ms, 53.2MB) 테스트 23 통과 (12.59ms, 52.5MB) 테스트 24 통과 (13.71ms, 50.9MB) 테스트 25 통과 (12.94ms, 52.4MB) 테스트 26 통과 (13.67ms, 50.9MB) 테스트 27 통과 (13.75ms, 53MB) 테스트 28 통과 (13.04ms, 51.7MB) 테스트 케이스12assertEquals(5, test.solution(new String[][] {{&quot;yellow_hat&quot;, &quot;headgear&quot;}, {&quot;blue_sunglasses&quot;, &quot;eyewear&quot;}, {&quot;green_turban&quot;, &quot;headgear&quot;}}));assertEquals(3, test.solution(new String[][] {{&quot;crow_mask&quot;, &quot;face&quot;}, {&quot;blue_sunglasses&quot;, &quot;face&quot;}, {&quot;green_turban&quot;, &quot;face&quot;}})); 참고 사이트 https://namu.wiki/w/%EC%A1%B0%ED%95%A9 https://namu.wiki/w/%EC%88%9C%EC%97%B4 https://blog.naver.com/PostView.nhn?blogId=freewheel3&amp;logNo=220778927108&amp;proxyReferer=https:%2F%2Fwww.google.com%2F","link":"/2020/05/15/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9C%84%EC%9E%A5/"},{"title":"프로그래머스: 조이스틱","text":"문제문제에 오류가 있는 것으로 판단됌 https://programmers.co.kr/learn/courses/30/lessons/42860 코드아래 코드는 통과되지 못했음 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106private static final int A_ASCII = 65;public int solution(String name) { char[] toChar = name.toCharArray(); int answer = getUpDownCount(toChar); int[] serialIndex = getLongestSerialIndex(toChar); int leftRightCursur = getLeftRightCount(serialIndex[0], serialIndex[1], toChar.length); answer += leftRightCursur; return answer;}private int getUpDownCount(char[] names) { int count = 0; for (char c : names) { int upDownCurour = c - A_ASCII; if (upDownCurour &gt; 12) { upDownCurour = 26 - upDownCurour; } count += upDownCurour; } return count;}private int[] getLongestSerialIndex(char[] array) { List&lt;Serial&gt; list = getSerialList(array); Serial serial = getMaxCountSerial(list); int[] result = new int[2]; result[0] = serial.index; result[1] = serial.index + serial.count; return result;}private List&lt;Serial&gt; getSerialList(char[] array) { int count = 0; List&lt;Serial&gt; list = new ArrayList&lt;Serial&gt;(); for (int i = 0; i &lt; array.length; i++) { if (array[i] != 'A') { count = 0; continue; } if (count == 0) { list.add(new Serial(i, 1)); } else { list.get(list.size()-1).count = (count+1); } count++; } return list;}private Serial getMaxCountSerial(List&lt;Serial&gt; list) { int max = 0; Serial serial = new Serial(); for (Serial s : list) { if (max &lt;= s.count) { max = s.count; serial = s; } } return serial;}private int getLeftRightCount(int serialIndex, int serialCount, int nameLength) { int leftRightCursur = 0; if (serialIndex == 0 &amp;&amp; serialCount == 0) { leftRightCursur = nameLength - 1; } else { int left = serialIndex == 0 ? 0 : serialIndex - 1; int right = nameLength - serialCount; leftRightCursur = left &gt; right ? (right * 2) + left : (left * 2) + right; leftRightCursur = leftRightCursur &gt; nameLength - 1 ? nameLength - 1 : leftRightCursur; } return leftRightCursur;}class Serial { private int index; private int count; public Serial() {} public Serial(int index, int count) { this.index = index; this.count = count; }} 흐름위 코드는 통과되지 못했음 문자들을 A로 뺀 후 거꾸로 도는게 빠른지 정방향으로 도는게 빠른지 확인해서 upDownCurour 변수에 저장 문자열에서 A가 제일 길게 연속되는 부분을 찾기 위해 inner class를 하나 만들어서 A가 연속될 때 마다 A가 시작된 index와 연속된 길이를 저장 A가 제일 길게 저장된 시작 index와 끝 index를 return 문자열 내에 A가 없으면 정방향으로 돌리고 A가 있으면 return된 index들을 가지고 왼쪽과 오른쪽에서 몇 칸씩 이동해야 하는 지 구함 left와 right를 더하고 가장 짧게 가야하므로 둘 중에 짧은 방향을 한번 더 더함 더 한 값이 문자열의 길이보다 길면 정방향으로 가는게 더 짧으므로 비교해서 확인 그렇게 구한 값을 더해서 return 끝 위 코드는 통과되지 못했음 테스트 케이스1234567891011121314151617181920212223242526assertEquals(4, test.solution(&quot;AAABAA&quot;));assertEquals(56, test.solution(&quot;JEROEN&quot;));assertEquals(23, test.solution(&quot;JAN&quot;));assertEquals(48, test.solution(&quot;CANAAAAANAN&quot;));assertEquals(8, test.solution(&quot;BBBAAB&quot;));assertEquals(56, test.solution(&quot;AAAAACANAAAAANANAAAAAA&quot;));assertEquals(3, test.solution(&quot;BBAAAAA&quot;));assertEquals(41, test.solution(&quot;JJAJAAAAAAAAAJ&quot;));assertEquals(21, test.solution(&quot;AJAJAA&quot;));assertEquals(7, test.solution(&quot;BBAABAA&quot;));assertEquals(6, test.solution(&quot;BBABA&quot;));assertEquals(10, test.solution(&quot;BBAABBB&quot;));assertEquals(7, test.solution(&quot;BBAABAAAA&quot;));assertEquals(10, test.solution(&quot;BBAABAAAAB&quot;));assertEquals(6, test.solution(&quot;ABAAAAAAABA&quot;));assertEquals(2, test.solution(&quot;AAB&quot;));assertEquals(11, test.solution(&quot;AABAAAAAAABBB&quot;));assertEquals(5, test.solution(&quot;ZZZ&quot;));assertEquals(10, test.solution(&quot;BBBBAAAAAB&quot;));assertEquals(12, test.solution(&quot;BBBBAAAABA&quot;));assertEquals(10, test.solution(&quot;ABABAAAAAAABA&quot;));assertEquals(18, test.solution(&quot;BBBBBBBABB&quot;));assertEquals(5, test.solution(&quot;AZAAAZ&quot;));assertEquals(3, test.solution(&quot;AC&quot;));assertEquals(3, test.solution(&quot;BBAAAAA&quot;));assertEquals(17, test.solution(&quot;ABAAABBBBBBB&quot;)); 통과된 코드 https://by-dev.tistory.com/9 위 주소의 코드는 “AAABAA”인 경우 2를 return 단순히 B까지 이동하는 것만해도 3이 걸리는데 통과 되었다는게 이해가 가지 않음","link":"/2020/05/21/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A1%B0%EC%9D%B4%EC%8A%A4%ED%8B%B1/"},{"title":"프로그래머스: 카펫","text":"문제https://programmers.co.kr/learn/courses/30/lessons/42842 코드1234567891011121314151617public int[] solution(int brown, int yellow) { int sum = brown + yellow; int[] answer = new int[2]; for (int i = 2; i &lt; sum; i++) { if (sum % i == 0) { int x = ((sum / i) * 2) + ((i * 2) - 4); int y = sum - x; if (brown == x &amp;&amp; yellow == y) { answer = new int[] {sum / i, i}; break; } } } return answer;} 흐름 갈색과 노란색을 더해 전체 크기를 구한다. 전체 크기를 2부터 반복한다. (1인 경우는 없으므로) i로 sum을 나눠서 떨어진다면, 즉 약수라면 sum에서 i를 나눈 값에 2를 곱해서 위 아래 가로의 길이를 구하고 i에 마찬가지로 2를 곱해서 좌 우 세로의 길이를 구하고 꼭지점들은 가로 세로가 겹치므로 -4를 한다. 이렇게 구한 갈색을 sum에서 빼서 노란색의 값을 구한다. 구한 갈색과 노란색 값이 넘겨받은 brown과 yellow와 같으면 끝 아니라면 반복한다. 끝 결과 번호 속도 테스트 1 통과 (1.57ms, 52.3MB) 테스트 2 통과 (1.76ms, 51.1MB) 테스트 3 통과 (1.88ms, 50.1MB) 테스트 4 통과 (1.44ms, 52.7MB) 테스트 5 통과 (1.52ms, 50.5MB) 테스트 6 통과 (1.48ms, 49.8MB) 테스트 7 통과 (1.62ms, 50.8MB) 테스트 8 통과 (1.52ms, 52.6MB) 테스트 9 통과 (1.58ms, 52.4MB) 테스트 10 통과 (1.58ms, 50.4MB) 테스트 11 통과 (1.53ms, 53MB) 테스트 12 통과 (1.56ms, 52.3MB) 테스트 13 통과 (1.48ms, 53.3MB) 테스트 케이스123assertArrayEquals(new int[]{4, 3}, test.solution(10, 2));assertArrayEquals(new int[]{3, 3}, test.solution(8, 1));assertArrayEquals(new int[]{8, 6}, test.solution(24, 24));","link":"/2020/07/20/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%B9%B4%ED%8E%AB/"},{"title":"프로그래머스: 카카오 프렌즈 컬러링북","text":"문제https://programmers.co.kr/learn/courses/30/lessons/1829 BFS(너비 우선 탐색) 알고리즘으로 해결 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public int[] solution(int m, int n, int[][] picture) { int numberOfArea = 0; int maxSizeOfOneArea = 0; boolean[][] isPassedArea = new boolean[m][n]; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (picture[i][j] == 0 || isPassedArea[i][j]) { continue; } int areaRange = breadthFirstSearch(i, j, picture, isPassedArea); maxSizeOfOneArea = (maxSizeOfOneArea &lt; areaRange) ? areaRange : maxSizeOfOneArea; ++numberOfArea; } } int[] answer = new int[2]; answer[0] = numberOfArea; answer[1] = maxSizeOfOneArea; return answer;}private int breadthFirstSearch(int x, int y, int[][] picture, boolean[][] isPassedArea) { final int[] xAround = new int[]{1, -1, 0, 0}; final int[] yAround = new int[]{0, 0, 1, -1}; int areaRange = 1; Queue&lt;Position&gt; queue = new LinkedList&lt;Position&gt;(); setPassedArea(isPassedArea, queue, x, y); while (!queue.isEmpty()) { Position currentPosition = queue.poll(); for (int i = 0; i &lt; xAround.length; i++) { int moveX = xAround[i] + currentPosition.x; int moveY = yAround[i] + currentPosition.y; if (!isSameAreaValidation(moveX, moveY, picture, isPassedArea, currentPosition)) { continue; } setPassedArea(isPassedArea, queue, moveX, moveY); ++areaRange; } } return areaRange;}private boolean isSameAreaValidation(int moveX, int moveY, int[][] picture, boolean[][] isPassedArea, Position currentPosition) { if (isOutOfPicture(moveX, moveY, picture)) { return false; } if (picture[moveX][moveY] == 0) { return false; } if (isPassedArea[moveX][moveY]) { return false; } if (picture[currentPosition.x][currentPosition.y] != picture[moveX][moveY]) { return false; } return true;}private boolean isOutOfPicture(int moveX, int moveY, int[][] picture) { if (moveX &lt; 0 || moveY &lt; 0) { return true; } if (picture.length &lt;= moveX || picture[0].length &lt;= moveY) { return true; } return false;}private void setPassedArea(boolean[][] isPassedArea, Queue&lt;Position&gt; queue, int x, int y) { isPassedArea[x][y] = true; queue.offer(new Position(x, y));}class Position { private int x = 0; private int y = 0; public Position(int x, int y) { this.x = x; this.y = y; }} 흐름 이미 지나온 배열인지 확인하기 위해 picture array와 똑같은 크기의 boolean array를 만듦 2차원 배열 크기만큼 돌면서 picture[i][j] value가 0이거나 이미 지나온 길이면 찾아갈 필요가 없으므로 continute 해서 길을 찾지 않음 아니면 좌표 x,y를 저장할 class를 담는 Queue를 생성함 queue에 현재 좌표를 저장하고 boolean array[x][y]를 true로 할당 queue에 있는 값을 하나씩 꺼내면서 queue가 전부 비워질 때까지 반복 queue에서 꺼낸 현재 좌표에서 상하 좌우를 비교해서 같은지 판단해야 하므로 현재 좌표에서 x -1 , +1, y +1, -1 씩 돌아가면서 판단할 좌표를 구함 구한 좌표가 validation을 통과하면 4번과 마찬가지로 좌표를 queue에 저장하고 true로 변경 구한 좌표 x, y가 array 범위를 넘어가진 않는 지 구한 좌표의 value가 0이 아닌 값 인지 구한 좌표가 이미 지나간 길이 아닌지 구한 좌표의 value가 현재 좌표의 value와 같은 지 위 4가지를 모두 통과해야 validation 통과 현재 영역의 크기를 증가시킴 queue가 전부 비워지면 영역의 크기를 return해서 이전에 구한 영역의 크기와 비교해서 큰 값을 저장 영역 개수를 증가시킴 끝 결과 테스트 케이스1234567891011121314151617181920int[][] picture = new int[][] {{1, 1, 1, 0}, {1, 2, 2, 0}, {1, 0, 0, 1}, {0, 0, 0, 1}, {0, 0, 0, 3}, {0, 0, 0, 3}};assertArrayEquals(new int[] {4 , 5}, test.solution(6, 4, picture));int[][] picture1 = new int[][] {{0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}};assertArrayEquals(new int[] {0 , 0}, test.solution(5, 5, picture1));int[][] picture2 = new int[][] {{1, 0, 0, 0, 0}, {0, 0, 1, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 0, 1}};assertArrayEquals(new int[] {3 , 1}, test.solution(5, 5, picture2));int[][] picture3 = new int[][] {{1, 1, 1, 1, 1}, {1, 1, 1, 1, 1}, {1, 1, 1, 1, 1}, {1, 1, 1, 1, 1}, {1, 1, 1, 1, 1}};assertArrayEquals(new int[] {1 , 25}, test.solution(5, 5, picture3));int[][] picture4 = new int[][] {{1, 1, 1, 1, 1}, {1, 1, 1, 1, 1}, {1, 1, 100, 1, 1}, {1, 1, 1, 1, 1}, {1, 1, 1, 1, 1}};assertArrayEquals(new int[] {2 , 24}, test.solution(5, 5, picture4));int[][] picture5 = new int[][] {{1, 1, 1, 0}, {1, 1, 1, 0}, {0, 0, 0, 1}, {0, 0, 0, 1}, {0, 0, 0, 1}, {0, 0, 0, 1}};assertArrayEquals(new int[] {2 , 6}, test.solution(6, 4, picture5));int[][] picture6 = new int[][] {{0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0}, {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0}, {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0}, {0, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 0}, {0, 1, 1, 1, 2, 1, 2, 1, 1, 2, 1, 2, 1, 1, 1, 0}, {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0}, {0, 1, 3, 3, 3, 1, 1, 1, 1, 1, 1, 3, 3, 3, 1, 0}, {0, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 0}, {0, 0, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 0, 0}, {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0}, {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0}};assertArrayEquals(new int[] {12 , 120}, test.solution(13, 16, picture6)); 참고 사이트 https://soobarkbar.tistory.com/92 https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html https://namu.wiki/w/BFS#s-1","link":"/2020/06/11/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%B9%B4%EC%B9%B4%EC%98%A4-%ED%94%84%EB%A0%8C%EC%A6%88-%EC%BB%AC%EB%9F%AC%EB%A7%81%EB%B6%81/"},{"title":"프로그래머스: 큰 수 만들기","text":"문제https://programmers.co.kr/learn/courses/30/lessons/42883?language=java 코드12345678910111213141516171819202122public String solution(String number, int k) { char[] toCharArray = number.toCharArray(); StringBuilder answer = new StringBuilder(); int idx = 0; for(int i = 0; i &lt; number.length() - k; i++) { int max = 0; for(int j = idx; j &lt;= k + i; j++) { int ch = toCharArray[j] - '0'; if(max &lt; ch) { max = ch; idx = j + 1; } } answer.append(max); } return answer.toString();} 흐름 문자열에서 k 만큼 빼야하니 당연히 문자열 length - k 만큼 반복 가장 큰 수의 인덱스를 구해서 그 인덱스부터 한 칸씩 밀려야 하니 k + i 한 값 까지 반복 가장 큰 수의 인덱스부터 반복해야하니 범위 내에서 가장 큰 수를 구해서 그 수의 인덱스를 저장하고 여기서 구한 인덱스를 2번에서 사용 가장 큰 수를 저장하고 반복이 끝나면 리턴 끝 테스트 케이스1234567assertEquals(&quot;23&quot;, test.solution(&quot;123&quot;, 2));assertEquals(&quot;34&quot;, test.solution(&quot;1234&quot;, 2));assertEquals(&quot;94&quot;, test.solution(&quot;1924&quot;, 2));assertEquals(&quot;3234&quot;, test.solution(&quot;1231234&quot;, 3));assertEquals(&quot;775841&quot;, test.solution(&quot;4177252841&quot;, 4));assertEquals(&quot;9&quot;, test.solution(&quot;9999999999&quot;, 9));assertEquals(&quot;93231357719&quot;, test.solution(&quot;9312131357719&quot;, 5)); 참고 사이트 https://medium.com/hyeon-hwang/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%81%B0-%EC%88%98-%EB%A7%8C%EB%93%A4%EA%B8%B0-lv-1-42883-%EC%88%AB%EC%9E%90-%EB%AC%B8%EC%A0%9C-%EA%B7%B8%EB%A6%AC%EB%94%94-585ce3b8c604 https://velog.io/@hyeon930/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%81%B0-%EC%88%98-%EB%A7%8C%EB%93%A4%EA%B8%B0-Java","link":"/2020/05/18/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%81%B0-%EC%88%98-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"title":"프로그래머스: 캐시","text":"문제https://programmers.co.kr/learn/courses/30/lessons/17680 코드12345678910111213141516171819202122232425262728private static final int MISS_RUN_TIME = 5;public int solution(int cacheSize, String[] cities) { if (cacheSize == 0) { return cities.length * MISS_RUN_TIME; } Map&lt;String, Integer&gt; lru = new LinkedHashMap&lt;String, Integer&gt;(cacheSize, 1, true){ @Override public boolean removeEldestEntry(Map.Entry&lt;String, Integer&gt; eldest) { return size() &gt; cacheSize; } }; int answer = 0; for(String key : cities) { key = key.toLowerCase(); if(lru.containsKey(key)) { lru.get(key); answer += 1; } else { lru.put(key, 0); answer += MISS_RUN_TIME; } } return answer;} 흐름 캐시가 0인 경우엔 캐시에 저장 할 수 없으니 항상 miss 이므로 배열의 크기 만큼 5를 곱해서 return 한다. LinkedHashMap의 경우 accessOrder parameter를 통해 Map의 순서를 access 기준으로 변경 할 수 있는데 우리는 LRU, 즉 가장 오래 사용되지 않은 데이터를 삭제 해야하므로 accessOrder를 true로 갖는 생성자로 LinkedHashMap 인스턴스를 생성한다. 그 후 removeEldestEntry()를 override해서 캐시의 크기보다 Map의 사이즈가 커질 경우 가장 오래 사용되지 않은 데이터를 삭제하도록 수정한다. 배열에서 문자열을 가져오면서 Map에 저장되어 있는지 비교한다. Map에 저장되어 있다면, get()을 통해 access하고 1초를 더한다. 저장되어 있지 않다면, put 하는데 이 때 Map의 크기가 캐시보다 크다면 아까 Override 한 removeEldestEntry()에 의해 가장 오래 사용되지 않은 값이 삭제되면서 지금 put한 데이터가 추가한다. 캐시에 없는 데이터를 추가했으니 5초를 더한다. 모든 초를 더한 값을 return 한다. 결과 번호 속도 테스트 1 통과 (1.11ms, 52.1MB) 테스트 2 통과 (1.20ms, 52.2MB) 테스트 3 통과 (1.08ms, 50.9MB) 테스트 4 통과 (1.23ms, 51.7MB) 테스트 5 통과 (0.94ms, 52.4MB) 테스트 6 통과 (0.78ms, 50.2MB) 테스트 7 통과 (0.78ms, 52.2MB) 테스트 8 통과 (1.12ms, 52.7MB) 테스트 9 통과 (1.15ms, 50.8MB) 테스트 10 통과 (1.34ms, 52.4MB) 테스트 11 통과 (45.53ms, 89.6MB) 테스트 12 통과 (1.45ms, 52.5MB) 테스트 13 통과 (1.43ms, 52.5MB) 테스트 14 통과 (1.69ms, 52.7MB) 테스트 15 통과 (2.42ms, 50.5MB) 테스트 16 통과 (2.85ms, 52.9MB) 테스트 17 통과 (0.78ms, 52MB) 테스트 18 통과 (4.34ms, 53.5MB) 테스트 19 통과 (4.28ms, 53.3MB) 테스트 20 통과 (4.15ms, 50.9MB) 테스트 케이스12345678assertEquals(42, test.solution(3, new String[]{&quot;Jeju&quot;, &quot;Pangyo&quot;, &quot;Jeju&quot;, &quot;NewYork&quot;, &quot;LA&quot;, &quot;Jeju&quot;, &quot;Pangyo&quot;, &quot;Seoul&quot;, &quot;NewYork&quot;, &quot;LA&quot;}));assertEquals(50, test.solution(3, new String[]{&quot;Jeju&quot;, &quot;Pangyo&quot;, &quot;Seoul&quot;, &quot;NewYork&quot;, &quot;LA&quot;, &quot;Jeju&quot;, &quot;Pangyo&quot;, &quot;Seoul&quot;, &quot;NewYork&quot;, &quot;LA&quot;}));assertEquals(21, test.solution(3, new String[]{&quot;Jeju&quot;, &quot;Pangyo&quot;, &quot;Seoul&quot;, &quot;Jeju&quot;, &quot;Pangyo&quot;, &quot;Seoul&quot;, &quot;Jeju&quot;, &quot;Pangyo&quot;, &quot;Seoul&quot;}));assertEquals(60, test.solution(2, new String[]{&quot;Jeju&quot;, &quot;Pangyo&quot;, &quot;Seoul&quot;, &quot;NewYork&quot;, &quot;LA&quot;, &quot;SanFrancisco&quot;, &quot;Seoul&quot;, &quot;Rome&quot;, &quot;Paris&quot;, &quot;Jeju&quot;, &quot;NewYork&quot;, &quot;Rome&quot;}));assertEquals(52, test.solution(5, new String[]{&quot;Jeju&quot;, &quot;Pangyo&quot;, &quot;Seoul&quot;, &quot;NewYork&quot;, &quot;LA&quot;, &quot;SanFrancisco&quot;, &quot;Seoul&quot;, &quot;Rome&quot;, &quot;Paris&quot;, &quot;Jeju&quot;, &quot;NewYork&quot;, &quot;Rome&quot;}));assertEquals(16, test.solution(2, new String[]{&quot;Jeju&quot;, &quot;Pangyo&quot;, &quot;NewYork&quot;, &quot;newyork&quot;}));assertEquals(25, test.solution(0, new String[]{&quot;Jeju&quot;, &quot;Pangyo&quot;, &quot;Seoul&quot;, &quot;NewYork&quot;, &quot;LA&quot;}));assertEquals(18, test.solution(1, new String[]{&quot;LA&quot;, &quot;LA&quot;, &quot;LA&quot;, &quot;LA&quot;, &quot;LA&quot;, &quot;LA&quot;, &quot;LA&quot;, &quot;LA&quot;, &quot;LA&quot;, &quot;LA&quot;, &quot;LA&quot;, &quot;LA&quot;, &quot;LA&quot;, &quot;LA&quot;})); 참고 사이트 https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html","link":"/2020/07/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%BA%90%EC%8B%9C/"},{"title":"프로그래머스: 크레인 인형뽑기 게임","text":"https://programmers.co.kr/learn/courses/30/lessons/64061 소스123456789101112131415161718192021222324252627282930313233343536373839404142public int solution(int[][] board, int[] moves) { int[] tops = setTop(board); Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int answer = 0; for (int i = 0; i &lt; moves.length; i++) { int move = moves[i] - 1; int top = tops[move]; if (top == 0) { continue; } int height = board.length - top; int value = board[height][move]; tops[move] = tops[move] - 1; if (!stack.isEmpty() &amp;&amp; (stack.peek() == value)) { stack.pop(); answer += 2; } else { stack.push(value); } } return answer;}private int[] setTop(int[][] board) { int height = board.length; int width = board[0].length; int[] tops = new int[width]; for (int i = 0; i &lt; height; i++) { for (int j = 0; j &lt; width; j++) { if (tops[j] == 0 &amp;&amp; board[i][j] != 0) { tops[j] = height - i; } } } return tops;} 흐름 인형이 쌓여있는 상자에서 각 열마다 맨 위에 있는 인형의 위치를 배열에 저장함. 크레인이 뽑을 위치가 담긴 배열 크기(moves) 만큼 loop 돔. 배열이 0부터 시작하므로, 뽑을 위치(move) 에서 -1 함. 뽑을 위치에서 맨 위의 위치를 가져오는데 0이면 그 열에 있는 건 모두 뽑아 먹은 것이므로 아무 행동도 하지 않음. 총 높이에서 그 열에서 제일 위에 있는 인형의 위치를 뻄. 상자에서 인형을 꺼냄.(value = board[height][move]) 그 열에 한 개 꺼냈으므로, top의 위치를 한 칸 내림. stack이 비어 있지 않으면서, stack의 top이 현재 뽑은 인형과 같으면 stack에 저장된 인형을 삭제하고, 삭제된 인형의 갯수를 더 함. 그렇지 않으면 stack에 인형을 추가. 끝 결과 번호 속도 테스트 1 통과 (0.94ms, 50.1MB) 테스트 2 통과 (0.94ms, 52.4MB) 테스트 3 통과 (1.04ms, 52.6MB) 테스트 4 통과 (2.28ms, 50.6MB) 테스트 5 통과 (0.98ms, 50.9MB) 테스트 6 통과 (0.97ms, 50.6MB) 테스트 7 통과 (1.11ms, 52.4MB) 테스트 8 통과 (1.25ms, 52.1MB) 테스트 9 통과 (1.37ms, 54.4MB) 테스트 10 통과 (1.38ms, 52.5MB) 테스트 11 통과 (1.81ms, 52.7MB)","link":"/2020/04/08/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%81%AC%EB%A0%88%EC%9D%B8-%EC%9D%B8%ED%98%95%EB%BD%91%EA%B8%B0-%EA%B2%8C%EC%9E%84/"},{"title":"프로그래머스: 탑","text":"문제https://programmers.co.kr/learn/courses/30/lessons/42588 코드본인의 코드가 아닌 해당 문제 최다 좋아요를 받은 코드 1234567891011121314151617181920212223242526272829303132333435public int[] solution(int[] heights) { Stack&lt;Tower&gt; st = new Stack&lt;&gt;(); int[] answer = new int[heights.length]; for (int i = 0; i &lt; heights.length; i++) { Tower tower = new Tower(i + 1, heights[i]); int receiveIdx = 0; while (!st.isEmpty()) { Tower top = st.peek(); if (top.height &gt; tower.height) { receiveIdx = top.idx; break; } st.pop(); } st.push(tower); answer[i] = receiveIdx; } return answer;}class Tower { int idx; int height; public Tower(int idx, int height) { this.idx = idx; this.height = height; }} 본인의 코드가 아닌 해당 문제 최다 좋아요를 받은 코드 흐름 탑의 index와 높이를 저장 할 Tower class 생성 탑의 개수만큼 반복 1 번쨰부터 시작되야하므로 현재 index에서 +1 한 index와 현재 높이를 갖는 tower를 생성 tower가 저장된 stack이 비었는지 체크 비어 있지 않다면 stack의 맨 위를 가져와서 현재 tower의 높이와 비교함 stack에 저장된 stack이 더 크다면 현재 타워에 전파를 받을 타워이므로 index를 receiveIdx 변수에 할당 크지 않다면 stack에 저장된 tower를 pop함 stack에 현재 tower를 push answer에 아까 저장한 receiveIdx를 저장 answer return 끝 결과 번호 속도 테스트 1 통과 (1.89ms, 50.7MB) 테스트 2 통과 (1.84ms, 52.6MB) 테스트 3 통과 (1.96ms, 52.3MB) 테스트 4 통과 (2.04ms, 52.5MB) 테스트 5 통과 (2.02ms, 50.8MB) 테스트 6 통과 (2.28ms, 52.7MB) 테스트 7 통과 (1.78ms, 52.6MB) 테스트 8 통과 (2.06ms, 52.1MB) 테스트 케이스123assertArrayEquals(new int[] {0,0,2,2,4}, test.solution(new int[] {6,9,5,7,4}));assertArrayEquals(new int[] {0,0,0,3,3,3,6}, test.solution(new int[] {3,9,9,3,5,7,2}));assertArrayEquals(new int[] {0,0,2,0,0,5,6}, test.solution(new int[] {1,5,3,6,7,6,5}));","link":"/2020/06/15/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%83%91/"},{"title":"프로그래머스: 타겟넘버","text":"문제https://programmers.co.kr/learn/courses/30/lessons/43165 코드123456789101112131415public int solution(int[] numbers, int target) { int answer = dfs(numbers, target, 0, 0); return answer;}private int dfs(int[] numbers, int target, int depth, int sum) { if (depth == numbers.length) { return sum == target ? 1 : 0; } int left = dfs(numbers, target, depth + 1, sum + numbers[depth]); int right = dfs(numbers, target, depth + 1, sum - numbers[depth]); return left + right;} 흐름 DFS 알고리즘 (재귀) 으로 해결 array index를 depth로 치고 모든 경우의 수를 탐색 0 번째 인덱스부터 시작 depth가 array length와 같으면 제일 깊은 곳 까지 모두 탐색한 것이므로 합이 target과 같은 지 판단해서 같으면 1, 다르면 0을 return depth가 length와 다르면, 더 깊이 들어가야 하므로 dfs() 메서드를 depth + 1 하고 해당 깊이 까진 더 한 값을 파라미터로 넘김 2번부터 다시 반복 끝 마지막 return 부연 설명123if (depth == numbers.length) { return sum == target ? 1 : 0;} 이미지 출처 https://lkhlkh23.tistory.com/74 맨 아래에서 맨 왼쪽 1+1+1+1+1은 3이 아니므로 0 그 옆 1+1+1+1-1은 3이므로 1 return 그럼 그 윗 노드인 1+1+1+1은 1 다음 탐색 순서인 1+1+1-1+1은 3이므로 1 return 1+1+1-1-1 = 1 이므로 0 return 이들의 부모 노드인 1+1+1-1은 1 그 위 부모 노드는 1 + 1 이므로 2가 됨 이런 식으로 마지막 까지 올라가면 결국 +1에선 4, -1 에선 1 되서 정답인 5를 return하게 되고 실제로 양수로 시작하는 부분에선 4개의 경우가 3이 return 되고, 음수로 시작하는 경우에는 1이 return 되므로 정답임을 알 수 있다. 결과 번호 속도 테스트 1 통과 (6.69ms, 54.4MB) 테스트 2 통과 (6.56ms, 52.9MB) 테스트 3 통과 (0.97ms, 52.8MB) 테스트 4 통과 (1.26ms, 50.9MB) 테스트 5 통과 (1.75ms, 50.1MB) 테스트 6 통과 (1.00ms, 52.3MB) 테스트 7 통과 (0.93ms, 52.5MB) 테스트 8 통과 (1.44ms, 52.6MB) 테스트 케이스1234assertEquals(5, test.solution(new int[] {1,1,1,1,1}, 3));assertEquals(3, test.solution(new int[] {2,3,5,7,9}, 2));assertEquals(1, test.solution(new int[] {1}, 1));assertEquals(5, test.solution(new int[] {6,2,3,6,7,1}, 7)); 참고 사이트 https://lkhlkh23.tistory.com/74 DFS와 BFS를 사용해야 되는 문제의 차이","link":"/2020/06/15/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%83%80%EA%B2%9F%EB%84%98%EB%B2%84/"},{"title":"프로그래머스: 튜플","text":"문제https://programmers.co.kr/learn/courses/30/lessons/64065 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public int[] solution(String s) { String[] strArray = getStringArray(s); List&lt;Integer[]&gt; list = convertStringArrayToIntegerArrayList(strArray); sortByArraylength(list); List&lt;Integer&gt; tuple = getTuple(list); int[] answer = convertIntegerArrayToIntArray(tuple); return answer;}private String[] getStringArray(String s) { String[] array = s.substring(2, s.length()-2).replace(&quot;},{&quot;, &quot;@&quot;).split(&quot;@&quot;); return array;}private List&lt;Integer[]&gt; convertStringArrayToIntegerArrayList(String[] strArray) { List&lt;Integer[]&gt; list = new ArrayList&lt;&gt;(); for (String str : strArray) { String[] stringNumbers = str.split(&quot;,&quot;); Integer[] array = convertStringArrayToIntegerArray(stringNumbers); list.add(array); } return list;}private Integer[] convertStringArrayToIntegerArray(String[] stringNumbers) { Integer[] array = new Integer[stringNumbers.length]; int i = 0; for (String str2 : stringNumbers) { array[i++] = Integer.parseInt(str2); } return array;}private void sortByArraylength(List&lt;Integer[]&gt; list) { Collections.sort(list, new Comparator&lt;Integer[]&gt;() { @Override public int compare(Integer[] o1, Integer[] o2) { return o1.length - o2.length; } });}private List&lt;Integer&gt; getTuple(List&lt;Integer[]&gt; list) { List&lt;Integer&gt; tuple = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; list.size(); i++) { Integer[] elements = list.get(i); for (Integer element : elements) { if (!tuple.contains(element)) { tuple.add(element); } } } return tuple;}private int[] convertIntegerArrayToIntArray(List&lt;Integer&gt; list) { int[] answer = new int[list.size()]; int j = 0; for (int i : list) { answer[j++] = i; } return answer;} 흐름 문자열을 각각 숫자를 저장한 문자열 배열로 만든다. (getStringArray) 만든 문자열 배열에 저장된 문자열을 “,”로 나눠서 각각 Integer 배열에 저장하고 그 Integer 배열을 담는 List에 저장한다. (convertStringArrayToIntegerArrayList) List에 저장된 Integer 배열을 배열의 길이가 짧은 순으로 sorting 한다. (sortByArraylength) 정렬한 list를 돌면서 Integer 배열을 꺼내고 다시 배열을 돌면서 튜플을 저장할 List에 담는데, 이 때 저장하기 전에 이미 List에 저장된 숫자인 경우엔 담을 필요가 없으므로 contain() 를 사용해서 List에 저장되지 않은 숫자만 add 한다. List형 이었으므로 문제에 맞게 int 배열 형으로 변환해서 return한다. 끝 최다 좋아요 코드12345678910111213public int[] solution(String s) { Set&lt;String&gt; set = new HashSet&lt;&gt;(); String[] arr = s.replaceAll(&quot;[{]&quot;, &quot; &quot;).replaceAll(&quot;[}]&quot;, &quot; &quot;).trim().split(&quot; , &quot;); Arrays.sort(arr, (a, b)-&gt;{return a.length() - b.length();}); int[] answer = new int[arr.length]; int idx = 0; for(String s1 : arr) { for(String s2 : s1.split(&quot;,&quot;)) { if(set.add(s2)) answer[idx++] = Integer.parseInt(s2); } } return answer;} 마찬가지로 우선 String을 String[]로 만들고 배열 길이 순으로 정렬한 다음에 2중 for문을 돌면서 숫자를 배열에 저장하는데, Set을 통해 이미 저장된 숫자는 저장하지 않는다. 결과 번호 속도 테스트 1 통과 (2.12ms, 52.3MB) 테스트 2 통과 (2.16ms, 52.2MB) 테스트 3 통과 (2.03ms, 50.3MB) 테스트 4 통과 (2.58ms, 52.4MB) 테스트 5 통과 (6.02ms, 52.4MB) 테스트 6 통과 (7.96ms, 50.9MB) 테스트 7 통과 (38.39ms, 53.8MB) 테스트 8 통과 (68.47ms, 61.7MB) 테스트 9 통과 (51.85ms, 57.6MB) 테스트 10 통과 (142.71ms, 62.2MB) 테스트 11 통과 (91.56ms, 65.7MB) 테스트 12 통과 (111.69ms, 74.1MB) 테스트 13 통과 (104.26ms, 72.1MB) 테스트 14 통과 (113.99ms, 74.5MB) 테스트 15 통과 (1.84ms, 50MB) 테스트 케이스1234567assertArrayEquals(new int[]{2,1,3,4}, test.solution(&quot;{{2},{2,1},{2,1,3},{2,1,3,4}}&quot;));assertArrayEquals(new int[]{2,1,3,4}, test.solution(&quot;{{1,2,3},{2,1},{1,2,4,3},{2}}&quot;));assertArrayEquals(new int[]{111,20}, test.solution(&quot;{{20,111},{111}}&quot;));assertArrayEquals(new int[]{123}, test.solution(&quot;{{123}}&quot;));assertArrayEquals(new int[]{3,2,4,1}, test.solution(&quot;{{4,2,3},{3},{2,3,4,1},{2,3}}&quot;));assertArrayEquals(new int[]{3,2,4,1,100}, test.solution(&quot;{{4,2,3},{3},{2,3,4,1},{2,3},{2,3,4,1,100}}&quot;));assertArrayEquals(new int[]{3,2,4,1,100}, test.solution(&quot;{{4,2,3},{3},{2,3,4,1},{2,3},{2,3,4,1,100}}&quot;));","link":"/2020/06/29/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%8A%9C%ED%94%8C/"},{"title":"프로그래머스: 프렌즈4블록","text":"문제https://programmers.co.kr/learn/courses/30/lessons/17679 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112private static final int ASCII = 32;private static final char EMPTY = ' ';public int solution(int m, int n, String[] board) { int answer = 0; char[][] charBoard = convertStringArrayToCharArray(m, n, board); while (true) { boolean isEnd = box(charBoard); if (isEnd) { break; } answer += delete(charBoard); } return answer;}public char[][] convertStringArrayToCharArray(int m, int n, String[] board) { char[][] charBoard = new char[m][n]; int i = 0; for (String str : board) { char[] toChar = str.toCharArray(); charBoard[i] = toChar; ++i; } return charBoard;}public char toLowerCase(char value) { return (char) ((value &gt;= 65 &amp;&amp; value &lt;= 90) ? (value + ASCII) : value);}public boolean box(char[][] charBoard) { boolean isEnd = true; for (int i = 0; i &lt; charBoard.length; i++) { for (int j = 0; j &lt; charBoard[i].length; j++) { if (validation(i, j, charBoard)) { char value = toLowerCase(charBoard[i][j]); charBoard[i][j] = value; charBoard[i][j+1] = value; charBoard[i+1][j] = value; charBoard[i+1][j+1] = value; isEnd = false; } } } return isEnd;}private boolean validation(int i, int j, char[][] charBoard) { if ((i + 1) == charBoard.length || (j + 1) == charBoard[0].length) { return false; } char position = toLowerCase(charBoard[i][j]); if (position == EMPTY) { return false; } char moveX = toLowerCase(charBoard[i][j+1]); char moveY = toLowerCase(charBoard[i+1][j]); char moveXY = toLowerCase(charBoard[i+1][j+1]); if (position != moveX) { return false; } if (position != moveY) { return false; } if (position != moveXY) { return false; } return true;}private int delete(char[][] charBoard) { int answer = 0; for (int i = 0; i &lt; charBoard.length; i++) { for (int j = 0; j &lt; charBoard[i].length; j++) { if (charBoard[i][j] == EMPTY) { continue; } if (charBoard[i][j] &gt;= 97 &amp;&amp; charBoard[i][j] &lt;= 122) { if (i != 0) { for (int k = i; k &gt; 0; k--) { charBoard[k][j] = charBoard[k-1][j]; charBoard[k-1][j] = EMPTY; } } else { charBoard[i][j] = EMPTY; } ++answer; } } } return answer;} 흐름 String array로 넘어온 board를 2차원 array로 만든다. 무한루프를 돌면서 char로 만든 board array의 element들을 모두 꺼내면서 제약조건을 확인하여 모두 통과할 때만 true를 return 한다. 현재 element가 있는 위치가 맨 끝인지 현재 element가 빈 값인지 현재 element의 오른쪽 element와 값이 같지 않은지 현재 element의 아래쪽 element와 값이 같지 않은지 현재 element의 우하(右下)쪽 element와 값이 같지 않은지 제약조건을 통과하면 현재 위치에서 오른쪽, 아래쪽, 우하(右下)쪽 element들을 소문자로 만들고 삭제 할 블록이 남았으므로, false를 return 한다. 다시 board array를 반복하면서 element가 소문자인 경우 현재 높이가 0이라면 위에서 내려올 블록이 없으므로 바로 빈 값을 저장하고 0이 아니라면 현재 위치부터 값을 1씩 빼면서 위에 블록을 현재 위치에 저장 시키고 위 블록은 빈 값으로 저장한다. 블록을 제거 할 때 마다 제거시킨 블록 개수를 저장하는 변수를 증가시킨다. 삭제 할 블록이 없을 때 까지 2번부터 8번까지 반복하고 삭제 할 블록이 없으면 루프를 빠져 나오고 삭제한 블록의 개수를 return 한다. 끝 결과 번호 속도 테스트 1 통과 (0.07ms, 52.3MB) 테스트 2 통과 (0.09ms, 51.7MB) 테스트 3 통과 (0.04ms, 51.9MB) 테스트 4 통과 (1.08ms, 52.5MB) 테스트 5 통과 (14.40ms, 52.6MB) 테스트 6 통과 (3.08ms, 52.3MB) 테스트 7 통과 (0.81ms, 52.3MB) 테스트 8 통과 (1.81ms, 53.7MB) 테스트 9 통과 (0.07ms, 53.4MB) 테스트 10 통과 (0.59ms, 51.7MB) 테스트 11 통과 (1.38ms, 52.7MB) 테스트 케이스123456789101112131415assertEquals(14, test.solution(4,5, new String[] {&quot;CCBDE&quot;, &quot;AAADE&quot;, &quot;AAABF&quot;, &quot;CCBBF&quot;}));assertEquals(15, test.solution(6,6, new String[] {&quot;TTTANT&quot;, &quot;RRFACC&quot;, &quot;RRRFCC&quot;, &quot;TRRRAA&quot;, &quot;TTMMMF&quot;, &quot;TMMTTJ&quot;}));assertEquals(14, test.solution(4,5, new String[] {&quot;AAAAA&quot;,&quot;AUUUA&quot;,&quot;AUUAA&quot;,&quot;AAAAA&quot;}));assertEquals(4, test.solution(2,2, new String[] {&quot;AA&quot;,&quot;AA&quot;}));assertEquals(0, test.solution(2,2, new String[] {&quot;AA&quot;,&quot;AB&quot;}));assertEquals(4, test.solution(3,2, new String[] {&quot;AA&quot;,&quot;AA&quot;, &quot;AB&quot;}));assertEquals(8, test.solution(4,2, new String[] {&quot;CC&quot;,&quot;AA&quot;, &quot;AA&quot;, &quot;CC&quot;}));assertEquals(12, test.solution(6,2, new String[] {&quot;DD&quot;, &quot;CC&quot;, &quot;AA&quot;, &quot;AA&quot;, &quot;CC&quot;, &quot;DD&quot;}));assertEquals(8, test.solution(8,2, new String[] {&quot;FF&quot;, &quot;AA&quot;, &quot;CC&quot;, &quot;AA&quot;, &quot;AA&quot;, &quot;CC&quot;, &quot;DD&quot;, &quot;FF&quot;}));assertEquals(8, test.solution(6,2, new String[] {&quot;AA&quot;, &quot;AA&quot;, &quot;CC&quot;, &quot;AA&quot;, &quot;AA&quot;, &quot;DD&quot;}));assertEquals(8, test.solution(4,4, new String[] {&quot;ABCD&quot;, &quot;BACE&quot;, &quot;BCDD&quot;, &quot;BCDD&quot;}));assertEquals(27, test.solution(8,9, new String[] {&quot;ABCDADFDA&quot;, &quot;ABDFQWERF&quot;, &quot;WKDNFNRIT&quot;, &quot;AKAKWODCJ&quot;, &quot;AKAKWODCJ&quot;, &quot;KKKKKKKKK&quot;, &quot;KKKKKKKKK&quot;, &quot;KKKKKKKKK&quot;}));assertEquals(15, test.solution(4,5, new String[] {&quot;AAAAA&quot;, &quot;AAAAU&quot;, &quot;AAAUU&quot;, &quot;UUUUU&quot;}));assertEquals(24, test.solution(5,6, new String[] {&quot;AAAAAA&quot;, &quot;BBAATB&quot;, &quot;BBAATB&quot;, &quot;JJJTAA&quot;, &quot;JJJTAA&quot;}));assertEquals(32, test.solution(6,6, new String[] {&quot;AABBEE&quot;, &quot;AAAEEE&quot;, &quot;VAAEEV&quot;, &quot;AABBEE&quot;, &quot;AACCEE&quot;, &quot;VVCCEE&quot;}));","link":"/2020/11/12/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%94%84%EB%A0%8C%EC%A6%884%EB%B8%94%EB%A1%9D/"},{"title":"프로그래머스: 파일명 정렬","text":"문제https://programmers.co.kr/learn/courses/30/lessons/17686 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public String[] solution(String[] files) { List&lt;File&gt; fileList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; files.length; i++) { char[] array = files[i].toCharArray(); String originName = files[i]; String head = &quot;&quot;; Integer number = 0; boolean isString = true; int numberStartIndex = 0; for (int j = 0; j &lt; array.length; j++) { if (isString &amp;&amp; isNumber(array[j])) { head = new String(array, 0, j).toUpperCase(); numberStartIndex = j; isString = false; continue; } if (!isString &amp;&amp; !isNumber(array[j])) { number = Integer.parseInt(new String(array, numberStartIndex, j - numberStartIndex)); isString = true; break; } } if (!isString) { number = Integer.parseInt(new String(array, numberStartIndex, array.length - numberStartIndex)); } fileList.add(new File(originName, head, number, i)); } sort(fileList); return fileList.stream() .map(File::getOriginName) .toArray(String[]::new);}private void sort(List&lt;File&gt; fileList) { fileList.sort((f1, f2) -&gt; { if (f1.head.compareTo(f2.head) != 0) { return f1.head.compareTo(f2.head); } else if (f1.number.compareTo(f2.number) != 0) { return f1.number.compareTo(f2.number); } else { return f1.index.compareTo(f2.index); } });}private boolean isNumber(char ch) { return (48 &lt;= ch &amp;&amp; ch &lt;= 57);}static class File { private final String originName; private final String head; private final Integer number; private final Integer index; public File(String originName, String head, Integer number, Integer index) { this.originName = originName; this.head = head; this.number = number; this.index = index; } public String getOriginName() { return this.originName; } public String getHead() { return this.head; } public Integer getNumber() { return this.number; } public Integer getIndex() { return this.index; }} 흐름 file 개수만큼 반복하면서 파일명을 char array로 만든다. char array를 숫자가 나올 때 까지 반복한다. 숫자가 나오면 0부터 숫자가 나온 index까지 짤라서 head 변수에 저장시키고 숫자가 시작된 index와 다음에 숫자인지 체크 할 flag 변수를 false로 변경한다. head를 만들고 난 후엔 숫자만 뽑아서 number로 저장해야 하므로 돌면서 현재 문자가 아니고 지금 값도 숫자가 아니면 지금 index까지 잘라서 number에 저장한다. 만약 tail이 없어서 이번 조건문에 걸리지 않았다면, 숫자가 시직된 index부터 array 길이에서 숫자가 시작된 index를 뺀 크기 만큼 잘라서 number에 저장한다. 구한 head, number를 가지고 원래 파일명, head, number, 원래 순서를 갖는 File Object를 생성하고 List에 추가한다. 리스트를 문제의 제약조건 처럼 정렬한다. head로 비교해서 정렬 head가 같으면 number로 비교해서 정렬 둘 다 같으면 원래 순서대로 정렬 정렬한 List를 String[]로 만들어서 return 한다. 끝 결과 번호 속도 테스트 1 통과 (2.80ms, 52.3MB) 테스트 2 통과 (2.92ms, 52.8MB) 테스트 3 통과 (15.41ms, 54.1MB) 테스트 4 통과 (17.89ms, 54.3MB) 테스트 5 통과 (16.74ms, 54.3MB) 테스트 6 통과 (15.07ms, 53.3MB) 테스트 7 통과 (21.21ms, 54.5MB) 테스트 8 통과 (21.20ms, 53.8MB) 테스트 9 통과 (17.57ms, 53.6MB) 테스트 10 통과 (20.00ms, 53.5MB) 테스트 11 통과 (15.30ms, 53.8MB) 테스트 12 통과 (14.44ms, 54.1MB) 테스트 13 통과 (10.24ms, 53.8MB) 테스트 14 통과 (12.50ms, 54.1MB) 테스트 15 통과 (18.61ms, 54.1MB) 테스트 16 통과 (20.40ms, 53.9MB) 테스트 17 통과 (10.36ms, 53.8MB) 테스트 18 통과 (13.84ms, 54.6MB) 테스트 19 통과 (16.07ms, 54.4MB) 테스트 20 통과 (14.91ms, 53.8MB) 정렬을 stream에 추가 할 경우stream sorted123456return fileList.stream() .sorted(Comparator.comparing(File::getHead) .thenComparing(Comparator.comparing(File::getNumber) .thenComparing(File::getIndex))) .map(File::getOriginName) .toArray(String[]::new); 결과 번호 속도 테스트 1 통과 (10.64ms, 53.2MB) 테스트 2 통과 (18.65ms, 53.2MB) 테스트 3 통과 (25.96ms, 54.7MB) 테스트 4 통과 (24.73ms, 54.8MB) 테스트 5 통과 (20.97ms, 54.3MB) 테스트 6 통과 (29.57ms, 54.3MB) 테스트 7 통과 (30.45ms, 54.3MB) 테스트 8 통과 (24.91ms, 54.3MB) 테스트 9 통과 (26.40ms, 54.8MB) 테스트 10 통과 (28.88ms, 54.1MB) 테스트 11 통과 (22.73ms, 54.7MB) 테스트 12 통과 (25.60ms, 54.4MB) 테스트 13 통과 (22.06ms, 54.2MB) 테스트 14 통과 (19.49ms, 54.9MB) 테스트 15 통과 (17.53ms, 54.2MB) 테스트 16 통과 (20.05ms, 54.1MB) 테스트 17 통과 (18.01ms, 54.7MB) 테스트 18 통과 (18.53ms, 53.7MB) 테스트 19 통과 (26.25ms, 54.2MB) 테스트 20 통과 (20.81ms, 55.2MB) 테스트 케이스12345assertArrayEquals(new String[] {&quot;img1.png&quot;, &quot;IMG01.GIF&quot;, &quot;img02.png&quot;, &quot;img2.JPG&quot;, &quot;img10.png&quot;, &quot;img12.png&quot;}, test.solution(new String[] {&quot;img12.png&quot;, &quot;img10.png&quot;, &quot;img02.png&quot;, &quot;img1.png&quot;, &quot;IMG01.GIF&quot;, &quot;img2.JPG&quot;}));assertArrayEquals(new String[] {&quot;A-10 Thunderbolt II&quot;, &quot;B-50 Superfortress&quot;, &quot;F-5 Freedom Fighter&quot;, &quot;F-14 Tomcat&quot;}, test.solution(new String[] {&quot;F-5 Freedom Fighter&quot;, &quot;B-50 Superfortress&quot;, &quot;A-10 Thunderbolt II&quot;, &quot;F-14 Tomcat&quot;}));assertArrayEquals(new String[] {&quot;img100.p2ng&quot;, &quot;img202.png123&quot;}, test.solution(new String[] {&quot;img202.png123&quot;, &quot;img100.p2ng&quot;}));assertArrayEquals(new String[] {&quot;foo010bar020.zip&quot;, &quot;foo010bar030.zip&quot;}, test.solution(new String[] {&quot;foo010bar020.zip&quot;, &quot;foo010bar030.zip&quot;}));assertArrayEquals(new String[] {&quot;F-15&quot;, &quot;F-17&quot;, &quot;F-22&quot;}, test.solution(new String[] {&quot;F-22&quot;, &quot;F-17&quot;, &quot;F-15&quot;}));","link":"/2020/11/12/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%8C%8C%EC%9D%BC%EB%AA%85-%EC%A0%95%EB%A0%AC/"},{"title":"프로그래머스: 행렬의 곱셈","text":"문제https://programmers.co.kr/learn/courses/30/lessons/12949 코드12345678910111213public int[][] solution(int[][] arr1, int[][] arr2) { int[][] answer = new int[arr1.length][arr2[0].length]; for (int i = 0; i &lt; arr1.length; i++) { for(int j = 0; j &lt; arr2[0].length; j++){ for (int k = 0; k &lt; arr2.length; k++) { answer[i][j] += arr1[i][k] * arr2[k][j]; } } } return answer;} 흐름 행렬의 곱은 앞 행렬의 행과 뒤 행렬의 열을 곱한 것과 같다. ex) 앞 행렬이 m x n 크기이고 뒤 행렬이 n x r 크기인 경우 곱은 m x r크기의 행렬이 된다. 곱 행렬(0, 0)은 앞 행렬의 (0, 0) X 뒷 행렬 (0, 0) + 앞 행렬 (0, 1) X 뒷 행렬 (1, 0) (0, 1)은 (0, 0) X (0, 1) + (0, 1) X (1, 1) (1, 0)은 (1, 0) X (0, 0) + (1, 1) X (0, 1) (1, 1)은 (1, 0) X (0, 1) + (1, 1) X (1, 1) (2, 0)은 (2, 0) X (0, 0) + (2, 1) X (0, 1) (2, 1)은 (2, 0) X (0, 1) + (2, 1) X (1, 1) 이런식으로 진행된다. 결과 번호 속도 테스트 1 통과 (2.93ms, 54.1MB) 테스트 2 통과 (10.09ms, 54.3MB) 테스트 3 통과 (17.85ms, 56.7MB) 테스트 4 통과 (2.02ms, 50.9MB) 테스트 5 통과 (8.78ms, 53.7MB) 테스트 6 통과 (9.40ms, 56.2MB) 테스트 7 통과 (1.56ms, 52.3MB) 테스트 8 통과 (1.80ms, 50.7MB) 테스트 9 통과 (1.79ms, 50.1MB) 테스트 10 통과 (8.66ms, 54.9MB) 테스트 11 통과 (3.37ms, 52.3MB) 테스트 12 통과 (2.05ms, 54.6MB) 테스트 13 통과 (9.96ms, 54.1MB) 테스트 14 통과 (10.60ms, 54.3MB) 테스트 15 통과 (7.94ms, 54.1MB) 테스트 16 통과 (4.86ms, 54.6MB) 테스트 케이스12assertArrayEquals(new int[][] {{15, 15}, {15, 15}, {15, 15}}, test.solution(new int[][] {{1, 4}, {3, 2}, {4, 1}}, new int[][] {{3, 3}, {3, 3}}));assertArrayEquals(new int[][] {{22, 22, 11}, {36, 28, 18}, {29, 20, 14}}, test.solution(new int[][] {{2, 3, 2}, {4, 2, 4}, {3, 1, 4}}, new int[][] {{5, 4, 3}, {2, 4, 1}, {3, 1, 1}})); 참고 사이트 https://namu.wiki/w/%ED%96%89%EB%A0%AC(%EC%88%98%ED%95%99) https://mathbang.net/562","link":"/2020/07/08/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%96%89%EB%A0%AC%EC%9D%98-%EA%B3%B1%EC%85%88/"},{"title":"프로그래머스: 프린터","text":"https://programmers.co.kr/learn/courses/30/lessons/42587 코드12345678910111213141516171819202122232425262728293031323334public int solution(int[] priorities, int location) { int answer = 0; LinkedList&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); for (int i = 0; i &lt; priorities.length; i++) { queue.offer(priorities[i]); } while (queue.size() != 0) { for (int i = 1; i &lt; queue.size(); i++) { if (queue.peek() &lt; queue.get(i)) { queue.offer(queue.poll()); if (location == 0) { location = queue.size() - 1; } else { --location; } i = 0; } } answer++; if (location == 0) { break; } --location; queue.poll(); } return answer;} 흐름 우선순위가 담긴 배열(priorities)을 Queue에 저장 큐에 첫 번째 값을 꺼내서 그 뒤 값들과 비교 첫 번째 값이 뒤에 있는 값들 보다 작다면 큐에 맨 뒤로 보냄 출력해야 되는 프린터의 index를 조정 index가 0 이라면 맨 뒤로 이동했을테니 큐 크기 - 1; 아니라면 앞으로 한 칸 이동 했을테니 -1 맨 뒤로 이동 시켰으면 맨 앞에 값이 변경 됐으므로 처음부터 다시 검사 큐의 0 번째 인덱스가 가장 큰 값이라면 count를 증가시키고 출력해야 하는 프린터의 위치를 확인 출력해야하는 프린터가 맨 앞이라면 break로 반복문을 빠져나와 프로그램 종료 아니라면 맨 앞에 값을 삭제하고 index를 -1 해서 한 칸 앞으로 당김 끝날 때 까지 반복 끝 결과 번호 속도 테스트 1 통과 (3.17ms, 52.8MB) 테스트 2 통과 (3.41ms, 52.6MB) 테스트 3 통과 (1.33ms, 52.6MB) 테스트 4 통과 (1.15ms, 50.8MB) 테스트 5 통과 (0.85ms, 52.2MB) 테스트 6 통과 (1.44ms, 52.7MB) 테스트 7 통과 (1.58ms, 50.4MB) 테스트 8 통과 (3.89ms, 52.9MB) 테스트 9 통과 (1.04ms, 52.8MB) 테스트 10 통과 (1.57ms, 52.3MB) 테스트 11 통과 (3.90ms, 52.7MB) 테스트 12 통과 (1.07ms, 52.3MB) 테스트 13 통과 (4.36ms, 52.1MB) 테스트 14 통과 (0.83ms, 52MB) 테스트 15 통과 (0.95ms, 50.4MB) 테스트 16 통과 (1.21ms, 50.3MB) 테스트 17 통과 (2.79ms, 50.7MB) 테스트 18 통과 (0.94ms, 50.7MB) 테스트 19 통과 (2.61ms, 53.1MB) 테스트 20 통과 (1.51ms, 52.3MB) 테스트 케이스1234assertEquals(1, test.solution(new int[] {2, 1, 3, 2}, 2));assertEquals(5, test.solution(new int[] {1, 1, 9, 1, 1, 1}, 0));assertEquals(6, test.solution(new int[] {2, 2, 2, 1, 3, 4}, 3));assertEquals(2, test.solution(new int[] {1, 2, 3, 2}, 3));","link":"/2020/04/23/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%94%84%EB%A6%B0%ED%84%B0/"},{"title":"프로그래머스: 피보나치 수","text":"문제https://programmers.co.kr/learn/courses/30/lessons/12945 코드1234567891011121314private static final int DIVIDE_NUMBER = 1234567;public int solution(int n) { int[] cache = new int[n+1]; cache[1] = 1; for (int i = 2; i &lt; n+1; i++) { cache[i] = ((cache[i-1]) % DIVIDE_NUMBER + (cache[i-2]) % DIVIDE_NUMBER) % DIVIDE_NUMBER; } int answer = cache[n]; return answer;} 흐름 n+1 크기 배열을 생성하는데 이 때 이번 문제에서 n은 1 &lt;= n &lt;= 100,000 이하이다. n이 1 일땐 1을 return 해야하므로 배열 1 번째엔 1을 할당 해놓아야 한다. 2부터 n + 1 까지 반복하면서 피보나치 수열 계산하는 것 처럼 i - 1, i - 2 배열에 저장된 값을 더하는데 문제에서 1234567을 나눈 나머지 값을 return 하라고 하였으므로 % 1234567을 해준다. cache 배열에서 n 번째에 있는 값을 return하면 끝 결과 번호 속도 테스트 1 통과 (0.85ms, 52.8MB) 테스트 2 통과 (0.80ms, 52.2MB) 테스트 3 통과 (0.78ms, 51.3MB) 테스트 4 통과 (0.81ms, 53.1MB) 테스트 5 통과 (0.84ms, 52.6MB) 테스트 6 통과 (0.85ms, 50.3MB) 테스트 7 통과 (0.95ms, 52.4MB) 테스트 8 통과 (0.86ms, 50.5MB) 테스트 9 통과 (0.86ms, 52MB) 테스트 10 통과 (0.89ms, 51.4MB) 테스트 11 통과 (0.84ms, 51MB) 테스트 12 통과 (0.86ms, 52.4MB) 테스트 13 통과 (3.99ms, 52.7MB) 테스트 14 통과 (3.98ms, 50.4MB) 테스트 케이스1234567assertEquals(2, test.solution(3));assertEquals(5, test.solution(5));assertEquals(987, test.solution(16));assertEquals(256379, test.solution(1234156));assertEquals(473509, test.solution(100001));assertEquals(1168141, test.solution(100000));assertEquals(547662, test.solution(124126347)); 참고 사이트 피보나치 알고리즘을 해결하는 다섯가지 방법","link":"/2020/06/27/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98/"},{"title":"프로그래머스: 후보키","text":"문제https://programmers.co.kr/learn/courses/30/lessons/42890 코드코드 출처 https://leveloper.tistory.com/106 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public int solution(String[][] relation) { int columnCount = relation[0].length; int rowCount = relation.length; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for (int i = 1; i &lt; (1 &lt;&lt; columnCount); i++) { if (!isUniqueness(relation, i, columnCount, rowCount)) { continue; } if (!isMinimality(i, list)) { continue; } list.add(i); } return list.size();}private boolean isUniqueness(String[][] relation, int set, int columnCount, int rowCount) { ArrayList&lt;Integer&gt; columnIndexList = getColumnIndex(set, columnCount); HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;(); for (int row = 0; row &lt; rowCount; row++) { StringBuilder sb = new StringBuilder(); for (int column : columnIndexList) { sb.append(relation[row][column]); } hashSet.add(sb.toString()); } return hashSet.size() == rowCount;}private ArrayList&lt;Integer&gt; getColumnIndex(int set, int colSize) { ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; colSize; i++) { if (((set &gt;&gt; i) &amp; 1) == 1) { result.add(i); } } return result;}private boolean isMinimality(int set, List&lt;Integer&gt; list) { boolean isMinimality = true; for (int i : list) { if ((set &amp; i) == i) { isMinimality = false; break; } } return isMinimality;} 코드 출처 https://leveloper.tistory.com/106 흐름예제 예제의 경우의 수 10진수 2진수 부분 집합 1 1 학번 2 10 이름 3 11 학번 이름 4 100 전공 5 101 학번 전공 6 110 전공 이름 7 111 학번 이름 전공 8 1000 학년 9 1001 학번 학년 10 1010 이름 학년 11 1011 학번 이름 학년 12 1100 전공 학년 13 1101 학번 전공 학년 14 1110 이름 전공 학년 15 1111 학번 이름 전공 학년 부분 집합에 매핑되는 2진수 학년 전공 이름 학번 1 1 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1 1 0 0 0 1 0 0 1 1 0 1 0 1 0 1 1 1 1 0 0 1 1 0 1 1 1 1 0 1 1 1 1 123for (int i = 1; i &lt; (1 &lt;&lt; columnCount); i++) { ...} 모든 경우의 수 만큼 반복하기 위해 테이블의 컬럼 수 만큼 1을 왼쪽 시프트 한다. column이 4 이면 1부터해서 1, 10, 100, 1000, 10000이 되고 10진수로 16이 된다. 후보키의 조건인 유일성와 최소성을 만족하는 지 확인한다. 유일성과 최소성을 모두 만족한다면 해당하는 값을 List에 추가한다. 모든 반복이 끝나면 List의 크기를 return 한다. 끝 유일성 확인12345678910private ArrayList&lt;Integer&gt; getColumnIndex(int set, int colSize) { ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; colSize; i++) { if (((set &gt;&gt; i) &amp; 1) == 1) { result.add(i); } } return result;} 10진수를 2진수로 치환하기 위해 오른쪽 시프트 연산자와 And 비트 연산자를 이용한다. 처음은 1부터 이므로 1을 오른쪽으로 0만큼 시프트하면 그대로 1이고 1과 1을 And 하면 값은 1과 같으므로 리스트에 담는다. 1을 0 이상 시프트 한다면 0이 되므로 list에는 더 이상 추가 될 수 없다. set에 2가 들어온 경우엔 2는 위 표에 적힌 것 처럼 2진수로 10이므로 10을 오른쪽으로 0번 시프트하면 10 이므로 1과 and 연산을 하면 0이 된다. 10을 오른쪽으로 1번 시프트하면 1이 되고 and 연산하면 1이 맞으므로 list에 1을 추가하고 그 이상 시프트 연산해봤자 0이 된다. set에 3이 들어온 경우엔 3은 위 표에 적힌 것 처럼 2진수로 11이므로 11을 오른쪽으로 0번 시프트하면 11이므로 1과 and 연산하면 1이 맞으므로 list에 0을 추가한다. 11을 오른쪽으로 1번 시프트하면 1이므로 1과 and 연산하면 1이 맞으므로 list에 1을 추가한다. 이 처럼 쭉 모든 수를 반복해서 colmn의 index를 구한다. 12345678910111213141516private boolean isUniqueness(String[][] relation, int set, int columnCount, int rowCount) { ArrayList&lt;Integer&gt; columnIndexList = getColumnIndex(set, columnCount); HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;(); for (int row = 0; row &lt; rowCount; row++) { StringBuilder sb = new StringBuilder(); for (int column : columnIndexList) { sb.append(relation[row][column]); } hashSet.add(sb.toString()); } return hashSet.size() == rowCount;} 구한 컬럼 index를 가지고 row 만큼 반복하면서 문자열을 연결하고 hashset에 담는다. set은 중복된 값이 담기지 않으므로 중북된 값이 없다면 set size와 row의 수가 같을 것이므로 같으면 유일성안 만족한다고 판단한다. 최소성 확인123456789101112private boolean isMinimality(int set, List&lt;Integer&gt; list) { boolean isMinimality = true; for (int i : list) { if ((set &amp; i) == i) { isMinimality = false; break; } } return isMinimality;} 유일성을 만족하는 슈퍼키들(list) 중에 최소성을 만족하는 값을 찾는다. 예제에선 학번은 유일성과 최소성을 만족해서 list에 1이 추가 되지만 이름이 중복되므로 2는 유일성을 만족하지 list에 저장되지 못한다. set이 3인 경우 list에 저장된 1과 and 연산하면 11 &amp; 1 이므로 1이 되어 1과 같으므로 최소성을 만족하지 못하고 false가 return 된다. 결국 list에 저장된 학번이 포함된 슈퍼키들은 모두 제외되고 2진수와 매핑되는 표에서 보면 {학번, 이름}(11), {학번, 전공}(101), {학번, 이름, 전공}(111), {학번 학년}(1001) … 등은 모두 제외되는 것이다. 그럼 결국 학번이 포함되지 않은 것들 중에 유일성을 만족하면서 최소성을 만족하는지 판단하게 된다. 결과 번호 속도 테스트 1 통과 (0.90ms, 50.4MB) 테스트 2 통과 (1.03ms, 51.8MB) 테스트 3 통과 (0.93ms, 51.9MB) 테스트 4 통과 (1.05ms, 52.8MB) 테스트 5 통과 (0.98ms, 52.1MB) 테스트 6 통과 (0.94ms, 50.4MB) 테스트 7 통과 (0.97ms, 50.6MB) 테스트 8 통과 (0.96ms, 52.4MB) 테스트 9 통과 (1.08ms, 50MB) 테스트 10 통과 (1.21ms, 52.3MB) 테스트 11 통과 (1.33ms, 54.7MB) 테스트 12 통과 (5.01ms, 52.9MB) 테스트 13 통과 (1.39ms, 52MB) 테스트 14 통과 (0.98ms, 54MB) 테스트 15 통과 (0.90ms, 52.5MB) 테스트 16 통과 (1.05ms, 50.8MB) 테스트 17 통과 (1.06ms, 50.5MB) 테스트 18 통과 (8.04ms, 54.5MB) 테스트 19 통과 (4.60ms, 52.9MB) 테스트 20 통과 (7.92ms, 50.5MB) 테스트 21 통과 (6.33ms, 54.7MB) 테스트 22 통과 (4.12ms, 50.7MB) 테스트 23 통과 (1.09ms, 52.7MB) 테스트 24 통과 (5.30ms, 52.5MB) 테스트 25 통과 (8.25ms, 54.4MB) 테스트 26 통과 (5.85ms, 52.3MB) 테스트 27 통과 (1.61ms, 52.8MB) 테스트 28 통과 (2.01ms, 52MB) 테스트 케이스1234567891011121314151617181920212223242526String[][] args = new String[][] {{&quot;100&quot;,&quot;ryan&quot;,&quot;music&quot;,&quot;2&quot;},{&quot;200&quot;,&quot;apeach&quot;,&quot;math&quot;,&quot;2&quot;},{&quot;300&quot;,&quot;tube&quot;,&quot;computer&quot;,&quot;3&quot;},{&quot;400&quot;,&quot;con&quot;,&quot;computer&quot;,&quot;4&quot;},{&quot;500&quot;,&quot;muzi&quot;,&quot;music&quot;,&quot;3&quot;},{&quot;600&quot;,&quot;apeach&quot;,&quot;music&quot;,&quot;2&quot;}};assertEquals(2, test.solution(args));String[][] args1 = new String[][] { {&quot;4&quot;, &quot;4&quot;, &quot;사랑&quot;, &quot;2020-07-03 오전 12:00:00&quot;, &quot;love&quot;} , {&quot;5&quot;, &quot;4&quot;, &quot;같은, 좋은, 와 비슷한&quot;, &quot;2020-07-03 오전 12:00:00&quot;, &quot;like&quot;} , {&quot;6&quot;, &quot;4&quot;, &quot;사과,대도시&quot;, &quot;2020-07-03 오전 12:00:00&quot;, &quot;apple&quot;} , {&quot;7&quot;, &quot;4&quot;, &quot;빌다,기도하다,에게 간청하다&quot;, &quot;2020-07-03 오전 12:00:00&quot;, &quot;pray&quot;} , {&quot;8&quot;, &quot;3&quot;, &quot;빌다,기도하다,에게 간청하다&quot;, &quot;2020-06-27 오전 12:00:00&quot;, &quot;pray&quot;} , {&quot;9&quot;, &quot;4&quot;, &quot;안녕&quot;, &quot;2020-07-03 오전 12:00:00&quot;, &quot;hi&quot;} , {&quot;10&quot;, &quot;3&quot;, &quot;같은, 좋은&quot;, &quot;2020-06-29 오전 12:00:00&quot;, &quot;like&quot;} , {&quot;11&quot;, &quot;2&quot;, &quot;나는 모자를 벗는다&quot;, &quot;2020-06-27 오전 12:00:00&quot;, &quot;I take off my hat&quot;}};assertEquals(5, test.solution(args1));String[][] args2 = new String[][] { {&quot;4&quot;, &quot;4&quot;, &quot;사랑&quot;, &quot;2020-07-03 오전 12:00:00&quot;, &quot;love&quot;} , {&quot;5&quot;, &quot;4&quot;, &quot;같은, 좋은, 와 비슷한&quot;, &quot;2020-07-03 오전 12:00:00&quot;, &quot;like&quot;} , {&quot;6&quot;, &quot;4&quot;, &quot;사과,대도시&quot;, &quot;2020-07-03 오전 12:00:00&quot;, &quot;apple&quot;} , {&quot;7&quot;, &quot;4&quot;, &quot;빌다,기도하다,에게 간청하다&quot;, &quot;2020-07-03 오전 12:00:00&quot;, &quot;pray&quot;} , {&quot;8&quot;, &quot;4&quot;, &quot;빌다,기도하다,에게 간청하다&quot;, &quot;2020-06-27 오전 12:00:00&quot;, &quot;pray&quot;} , {&quot;9&quot;, &quot;4&quot;, &quot;안녕&quot;, &quot;2020-07-03 오전 12:00:00&quot;, &quot;hi&quot;} , {&quot;10&quot;, &quot;3&quot;, &quot;같은, 좋은&quot;, &quot;2020-06-29 오전 12:00:00&quot;, &quot;like&quot;} , {&quot;11&quot;, &quot;2&quot;, &quot;나는 모자를 벗는다&quot;, &quot;2020-06-27 오전 12:00:00&quot;, &quot;I take off my hat&quot;}};assertEquals(3, test.solution(args2)); 참고 사이트 https://tech.kakao.com/2018/09/21/kakao-blind-recruitment-for2019-round-1/ https://leveloper.tistory.com/106","link":"/2020/06/26/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%9B%84%EB%B3%B4%ED%82%A4/"},{"title":"프로세스와 스레드","text":"결론 프로세스(Process)란 메모리 위에 올라와서 실행 중인 프로그램으로 각각의 프로세스는 모두 독립적인 상태이고 Os로부터 자원을 할당 받은 작업의 단위. 스레드(Thread)란 프로세스 내에서 실행되는 작업의 수행 단위로 각각의 스레드는 프로세스가 할당받은 자원을 이용하면서 스레드간 메모리를 공유하며 작동한다. 작동 방식프로세스 프로세스는 OS로부터 Code, Data, Stack, Heap으로 이루어진 독립된 메모리 영역을 할당 받는다. 각각 독립된 영역을 할당 받으므로 기본적으로 프로세스들 간에는 다른 프로세스의 변수나, 자료구조에 접근 할 수 없으며 서로 간 통신을 위해선 커널 영역에 IPC를 이용해 프로세스간 통신을 할 수 있다. 프로세스 내 메모리 구조 Code 영역 : 프로그램에서 수행 할 코드가 로딩 되는 메모리 Data 영역 : 프로그램이 실행 될 때 생성되고, 종료 될 때 시스템에 반환되며 BBS와 Data영역으로 나뉘는데 BBS엔 초기화 되지 않은 변수를 위한 영역이고, Data는 초기화된 데이터를 저장하는 메모리이다. Heap 영역 : 프로그램이 실행되는 동안 필요에 의해 동적으로 사요되는 메모리 영역으로 대표적으로 C언어의 malloc함수를 이용해 메모리를 할당한다면 이 영역에 할당되고 Java의 Object 타입들은 heap 영역에 생성된다. Stack 영역 : 프로그램이 자동으로 사용하는 임시 메모리 영역으로 지연벽수, 파라미터, 리턴 값 등 잠시 사용됐다가 사라지는 데이터를 저장하는 영역으로 함수 호출 시 생성되고 함수가 끝나면 반환된다. 예로 메서드 내에서 선언한 지역 변수는 Stack 영역에 저장되기 때문에 메서드가 끝날 때 함께 사라지므로 다른 메서드에서 호출 할 수 없다. 스레드 스레드는 프로세스 내부에 존재하고 Stack 영역만 각 스레드마다 독립적으로 할당 받고 그 외에 프로세스 영역에 있는 code, data, heap 영역은 프로세스 내에 있는 스레드 끼리 공유한다. 때문에 한 스레드에서 공유된 영역의 자원을 수정한다면 다른 스레드에서 그 자원을 사용 할 때 변경된 자원을 사용하게 되고 결국 개발자가 자원을 동기적으로 사용 할 수 있도록 처리 할 수 있어야 한다. 프로세스 내 자원을 함께 공유하기 때문에 모든 자원을 각각 독립되게 할당 받은 프로세스와 달리 같은 프로세스 내의 스레드가 문제가 생긴다면 다른 스레드들도 강제로 종료되게 된다. 참고 사이트 https://www.yalco.kr/14_process_thread/ https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4 https://recorda.tistory.com/entry/20160503%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0 https://ehpub.co.kr/54-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0/","link":"/2020/11/18/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C/"},{"title":"백준 4796번: 캠핑","text":"문제https://www.acmicpc.net/problem/4796 코드1234567891011121314151617181920212223242526272829public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int i = 0; String input = &quot;&quot;; while (!&quot;0 0 0&quot;.equals(input = br.readLine())) { int[] lpv = convertStringArrayToIntegerArray(input.split(&quot; &quot;)); int l = lpv[0]; int p = lpv[1]; int v = lpv[2]; sb.append(&quot;Case &quot;).append(++i).append(&quot;: &quot;).append((v/p) * l + ((v%p) &gt; l ? l : (v%p))).append(&quot;\\n&quot;); } System.out.println(sb);}private static int[] convertStringArrayToIntegerArray(String[] args) { int[] array = new int[args.length]; int i = 0; for (String str : args) { array[i++] = Integer.parseInt(str); } return array;} 흐름 V일 중에 연속되는 P일 동안 L일 만큼 휴가를 사용 할 수 있으므로 V에서 P를 나눈 값에서 L일을 곱하면 사용 가능한 휴가 일수가 구해지고 L이 V일에서 P일을 나눈 값보다 작을 땐 L일 만큼 휴가를 더 갈 수 있고 큰 경우엔 V % P 일 만큼 갈 수 있으므로 구한 값을 더하면 총 휴가 일수를 구할 수 있다. 결과","link":"/2021/03/25/%EB%B0%B1%EC%A4%80-4796%EB%B2%88-%EC%BA%A0%ED%95%91/"},{"title":"Windows 10 SSH 접속","text":"서론집에서 서버에 접속할 일이 생겨서 평소처럼 ssh로 접속을 하려고 했는데..접속이 되지 않아 당황했는데 미래의 나와, 다른 사람들은 이러지 않길 바라며 글을 남긴다. 접속 방법우선 .pem 파일이 존재하는 경로에 폴더명이 한글인 폴더가 존재하면 안된다. 설정의 앱 및 기능에서 선택적 기능을 선택 기능 추가를 선택하여 ssh를 검색해서 OpenSSH 클라이언트를 설치 SSH 이용 가능 여담나의 경우엔 .pem 파일이 한글 폴더가 있는 경로에 존재해서 인식하지 못했던 문제였지만혹시 모르니 SSH 클라이언트 설치방법도 작성해놓는다.","link":"/2021/03/27/Windows%2010%20SSH%20%EC%A0%91%EC%86%8D/"}],"tags":[{"name":"Spring-Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"Junit","slug":"Junit","link":"/tags/Junit/"},{"name":"Test","slug":"Test","link":"/tags/Test/"},{"name":"H2","slug":"H2","link":"/tags/H2/"},{"name":"AWS","slug":"AWS","link":"/tags/AWS/"},{"name":"CodeDeploy","slug":"CodeDeploy","link":"/tags/CodeDeploy/"},{"name":"JPA","slug":"JPA","link":"/tags/JPA/"},{"name":"JPQL","slug":"JPQL","link":"/tags/JPQL/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Travis CI","slug":"Travis-CI","link":"/tags/Travis-CI/"},{"name":"-Spring-Boot -","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"Spring boot","slug":"Spring-boot","link":"/tags/Spring-boot/"},{"name":"Heroku","slug":"Heroku","link":"/tags/Heroku/"},{"name":"Could","slug":"Could","link":"/tags/Could/"},{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"},{"name":"면접 질문","slug":"면접-질문","link":"/tags/%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8/"},{"name":"개발","slug":"개발","link":"/tags/%EA%B0%9C%EB%B0%9C/"},{"name":"thymeleaf","slug":"thymeleaf","link":"/tags/thymeleaf/"},{"name":"ajax","slug":"ajax","link":"/tags/ajax/"},{"name":"json","slug":"json","link":"/tags/json/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"그리디","slug":"그리디","link":"/tags/%EA%B7%B8%EB%A6%AC%EB%94%94/"},{"name":"백준","slug":"백준","link":"/tags/%EB%B0%B1%EC%A4%80/"},{"name":"탐색","slug":"탐색","link":"/tags/%ED%83%90%EC%83%89/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"자료구조","slug":"자료구조","link":"/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"좌표압축","slug":"좌표압축","link":"/tags/%EC%A2%8C%ED%91%9C%EC%95%95%EC%B6%95/"},{"name":"정렬","slug":"정렬","link":"/tags/%EC%A0%95%EB%A0%AC/"},{"name":"브루트포스","slug":"브루트포스","link":"/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4/"},{"name":"수학","slug":"수학","link":"/tags/%EC%88%98%ED%95%99/"},{"name":"이진탐색","slug":"이진탐색","link":"/tags/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/"},{"name":"문자열","slug":"문자열","link":"/tags/%EB%AC%B8%EC%9E%90%EC%97%B4/"},{"name":"KMP","slug":"KMP","link":"/tags/KMP/"},{"name":"연습문제","slug":"연습문제","link":"/tags/%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C/"},{"name":"프로그래머스","slug":"프로그래머스","link":"/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"스택&#x2F;큐","slug":"스택-큐","link":"/tags/%EC%8A%A4%ED%83%9D-%ED%81%90/"},{"name":"토비","slug":"토비","link":"/tags/%ED%86%A0%EB%B9%84/"},{"name":"다이나믹 프로그래밍","slug":"다이나믹-프로그래밍","link":"/tags/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"브루트 포스","slug":"브루트-포스","link":"/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8-%ED%8F%AC%EC%8A%A4/"},{"name":"순열","slug":"순열","link":"/tags/%EC%88%9C%EC%97%B4/"},{"name":"소수","slug":"소수","link":"/tags/%EC%86%8C%EC%88%98/"},{"name":"해쉬","slug":"해쉬","link":"/tags/%ED%95%B4%EC%89%AC/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"비트마스크","slug":"비트마스크","link":"/tags/%EB%B9%84%ED%8A%B8%EB%A7%88%EC%8A%A4%ED%81%AC/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"}],"categories":[{"name":"개발","slug":"개발","link":"/categories/%EA%B0%9C%EB%B0%9C/"}]}